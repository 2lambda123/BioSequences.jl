{
    "docs": [
        {
            "location": "/", 
            "text": "BioSequences.jl \nBiological sequences for julia\n\n\nLatest release:\n\n\n \n \n \n \n \n \n\n\nDevelopment status:\n\n\n \n \n \n\n\n\n\nDescription\n\n\nBioSequences.jl provides DNA, RNA and amino acid sequence data types for the julia language, with a comprehensive set of methods for common operations and IO of major sequence data formats.   \n\n\n\n\nInstallation\n\n\nInstall BioSequences from the Julia REPL:\n\n\njulia\n \nPkg\n.\nadd\n(\nBioSequences\n)\n\n\n\n\n\n\nIf you are interested in the cutting edge of the development, please check out the master branch to try new features before release.", 
            "title": "Home"
        }, 
        {
            "location": "/#biosequencesjl-biological-sequences-for-julia", 
            "text": "Latest release:               Development status:", 
            "title": "BioSequences.jl Biological sequences for julia"
        }, 
        {
            "location": "/#description", 
            "text": "BioSequences.jl provides DNA, RNA and amino acid sequence data types for the julia language, with a comprehensive set of methods for common operations and IO of major sequence data formats.", 
            "title": "Description"
        }, 
        {
            "location": "/#installation", 
            "text": "Install BioSequences from the Julia REPL:  julia   Pkg . add ( BioSequences )   If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.", 
            "title": "Installation"
        }, 
        {
            "location": "/symbols/", 
            "text": "Biological symbols\n\n\nThe \nBioSequences\n module provides three biological symbol (character) types:\n\n\n\n\n\n\n\n\nType\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nDNA\n\n\nDNA nucleotide\n\n\n\n\n\n\nRNA\n\n\nRNA nucleotide\n\n\n\n\n\n\nAminoAcid\n\n\nAmino acid\n\n\n\n\n\n\n\n\nThese symbols are elements of biological sequences, just as characters are elements of strings. See sections beginning from \nIntroduction to the sequence data-types\n section for details.\n\n\n\n\nDNA and RNA nucleotides\n\n\nSet of nucleotide symbols in BioSequences.jl covers IUPAC nucleotide base plus a gap symbol:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'A'\n\n\nDNA_A\n / \nRNA_A\n\n\nA; Adenine\n\n\n\n\n\n\n'C'\n\n\nDNA_C\n / \nRNA_C\n\n\nC; Cytosine\n\n\n\n\n\n\n'G'\n\n\nDNA_G\n / \nRNA_G\n\n\nG; Guanine\n\n\n\n\n\n\n'T'\n\n\nDNA_T\n\n\nT; Thymine (DNA only)\n\n\n\n\n\n\n'U'\n\n\nRNA_U\n\n\nU; Uracil (RNA only)\n\n\n\n\n\n\n'M'\n\n\nDNA_M\n / \nRNA_M\n\n\nA or C\n\n\n\n\n\n\n'R'\n\n\nDNA_R\n / \nRNA_R\n\n\nA or G\n\n\n\n\n\n\n'W'\n\n\nDNA_W\n / \nRNA_W\n\n\nA or T/U\n\n\n\n\n\n\n'S'\n\n\nDNA_S\n / \nRNA_S\n\n\nC or G\n\n\n\n\n\n\n'Y'\n\n\nDNA_Y\n / \nRNA_Y\n\n\nC or T/U\n\n\n\n\n\n\n'K'\n\n\nDNA_K\n / \nRNA_K\n\n\nG or T/U\n\n\n\n\n\n\n'V'\n\n\nDNA_V\n / \nRNA_V\n\n\nA or C or G; not T/U\n\n\n\n\n\n\n'H'\n\n\nDNA_H\n / \nRNA_H\n\n\nA or C or T; not G\n\n\n\n\n\n\n'D'\n\n\nDNA_D\n / \nRNA_D\n\n\nA or G or T/U; not C\n\n\n\n\n\n\n'B'\n\n\nDNA_B\n / \nRNA_B\n\n\nC or G or T/U; not A\n\n\n\n\n\n\n'N'\n\n\nDNA_N\n / \nRNA_N\n\n\nA or C or G or T/U\n\n\n\n\n\n\n'-'\n\n\nDNA_Gap\n / \nRNA_Gap\n\n\nGap (none of the above)\n\n\n\n\n\n\n\n\nhttp://www.insdc.org/documents/feature_table.html#7.4.1\n\n\nSymbols are accessible as constants with \nDNA_\n or \nRNA_\n prefix:\n\n\njulia\n DNA_A\nDNA_A\n\njulia\n DNA_T\nDNA_T\n\njulia\n RNA_U\nRNA_U\n\njulia\n DNA_Gap\nDNA_Gap\n\njulia\n typeof(DNA_A)\nBioSymbols.DNA\n\njulia\n typeof(RNA_A)\nBioSymbols.RNA\n\n\n\n\n\nSymbols can be constructed by converting regular characters:\n\n\njulia\n convert(DNA, \nC\n)\nDNA_C\n\njulia\n convert(DNA, \nC\n) === DNA_C\ntrue\n\n\n\n\n\nEvery nucleotide is encoded using the lower 4 bits of a byte. An unambiguous nucleotide has only one set bit and the other bits are unset. The table below summarizes all unambiguous nucleotides and their corresponding bits. An ambiguous nucleotide is the bitwise OR of unambiguous nucleotides that the ambiguous nucleotide can take. For example, \nDNA_R\n (meaning the nucleotide is either \nDNA_A\n or \nDNA_G\n) is encoded as \n0101\n because \n0101\n is the bitwise OR of \n0001\n (\nDNA_A\n) and \n0100\n (\nDNA_G\n). The gap symbol is always \n0000\n.\n\n\n\n\n\n\n\n\nNucleicAcid\n\n\nBits\n\n\n\n\n\n\n\n\n\n\nDNA_A\n, \nRNA_A\n\n\n0001\n\n\n\n\n\n\nDNA_C\n, \nRNA_C\n\n\n0010\n\n\n\n\n\n\nDNA_G\n, \nRNA_G\n\n\n0100\n\n\n\n\n\n\nDNA_T\n, \nRNA_U\n\n\n1000\n\n\n\n\n\n\n\n\nThe next examples demonstrate bit operations of DNA:\n\n\njulia\n bits(reinterpret(UInt8, DNA_A))\n\n00000001\n\n\njulia\n bits(reinterpret(UInt8, DNA_G))\n\n00000100\n\n\njulia\n bits(reinterpret(UInt8, DNA_R))\n\n00000101\n\n\njulia\n bits(reinterpret(UInt8, DNA_B))\n\n00001110\n\n\njulia\n ~DNA_A\nDNA_B\n\njulia\n DNA_A | DNA_G\nDNA_R\n\njulia\n DNA_R \n DNA_B\nDNA_G\n\n\n\n\n\n\n\nAmino acids\n\n\nSet of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:\n\n\n\n\n\n\n\n\nSymbol\n\n\nConstant\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n'A'\n\n\nAA_A\n\n\nAlanine\n\n\n\n\n\n\n'R'\n\n\nAA_R\n\n\nArginine\n\n\n\n\n\n\n'N'\n\n\nAA_N\n\n\nAsparagine\n\n\n\n\n\n\n'D'\n\n\nAA_D\n\n\nAspartic acid (Aspartate)\n\n\n\n\n\n\n'C'\n\n\nAA_C\n\n\nCysteine\n\n\n\n\n\n\n'Q'\n\n\nAA_Q\n\n\nGlutamine\n\n\n\n\n\n\n'E'\n\n\nAA_E\n\n\nGlutamic acid (Glutamate)\n\n\n\n\n\n\n'G'\n\n\nAA_G\n\n\nGlycine\n\n\n\n\n\n\n'H'\n\n\nAA_H\n\n\nHistidine\n\n\n\n\n\n\n'I'\n\n\nAA_I\n\n\nIsoleucine\n\n\n\n\n\n\n'L'\n\n\nAA_L\n\n\nLeucine\n\n\n\n\n\n\n'K'\n\n\nAA_K\n\n\nLysine\n\n\n\n\n\n\n'M'\n\n\nAA_M\n\n\nMethionine\n\n\n\n\n\n\n'F'\n\n\nAA_F\n\n\nPhenylalanine\n\n\n\n\n\n\n'P'\n\n\nAA_P\n\n\nProline\n\n\n\n\n\n\n'S'\n\n\nAA_S\n\n\nSerine\n\n\n\n\n\n\n'T'\n\n\nAA_T\n\n\nThreonine\n\n\n\n\n\n\n'W'\n\n\nAA_W\n\n\nTryptophan\n\n\n\n\n\n\n'Y'\n\n\nAA_Y\n\n\nTyrosine\n\n\n\n\n\n\n'V'\n\n\nAA_V\n\n\nValine\n\n\n\n\n\n\n'O'\n\n\nAA_O\n\n\nPyrrolysine\n\n\n\n\n\n\n'U'\n\n\nAA_U\n\n\nSelenocysteine\n\n\n\n\n\n\n'B'\n\n\nAA_B\n\n\nAspartic acid or Asparagine\n\n\n\n\n\n\n'J'\n\n\nAA_J\n\n\nLeucine or Isoleucine\n\n\n\n\n\n\n'Z'\n\n\nAA_Z\n\n\nGlutamine or Glutamic acid\n\n\n\n\n\n\n'X'\n\n\nAA_X\n\n\nAny amino acid\n\n\n\n\n\n\n'*'\n\n\nAA_Term\n\n\nTermination codon\n\n\n\n\n\n\n'-'\n\n\nAA_Gap\n\n\nGap (none of the above)\n\n\n\n\n\n\n\n\nhttp://www.insdc.org/documents/feature_table.html#7.4.3\n\n\nSymbols are accessible as constants with \nAA_\n prefix:\n\n\njulia\n AA_A\nAA_A\n\njulia\n AA_Q\nAA_Q\n\njulia\n AA_Term\nAA_Term\n\njulia\n typeof(AA_A)\nBioSymbols.AminoAcid\n\n\n\n\n\nSymbols can be constructed by converting regular characters:\n\n\njulia\n convert(AminoAcid, \nA\n)\nAA_A\n\njulia\n convert(AminoAcid, \nP\n) === AA_P\ntrue\n\n\n\n\n\n\n\nOther functions\n\n\n#\n\n\nBioSymbols.alphabet\n \n \nFunction\n.\n\n\nalphabet(DNA)\n\n\n\n\n\nGet all symbols of \nDNA\n in sorted order.\n\n\nExamples\n\n\njulia\n alphabet(DNA)\n(DNA_Gap, DNA_A, DNA_C, DNA_M, DNA_G, DNA_R, DNA_S, DNA_V, DNA_T, DNA_W, DNA_Y, DNA_H, DNA_K, DNA_D, DNA_B, DNA_N)\n\njulia\n issorted(alphabet(DNA))\ntrue\n\n\n\n\n\nsource\n\n\nalphabet(RNA)\n\n\n\n\n\nGet all symbols of \nRNA\n in sorted order.\n\n\nExamples\n\n\njulia\n alphabet(RNA)\n(RNA_Gap, RNA_A, RNA_C, RNA_M, RNA_G, RNA_R, RNA_S, RNA_V, RNA_U, RNA_W, RNA_Y, RNA_H, RNA_K, RNA_D, RNA_B, RNA_N)\n\njulia\n issorted(alphabet(RNA))\ntrue\n\n\n\n\n\nsource\n\n\nalphabet(AminoAcid)\n\n\n\n\n\nGet all symbols of \nAminoAcid\n in sorted order.\n\n\nExamples\n\n\njulia\n alphabet(AminoAcid)\n(AA_A, AA_R, AA_N, AA_D, AA_C, AA_Q, AA_E, AA_G, AA_H, AA_I, AA_L, AA_K, AA_M, AA_F, AA_P, AA_S, AA_T, AA_W, AA_Y, AA_V, AA_O, AA_U, AA_B, AA_J, AA_Z, AA_X, AA_Term, AA_Gap)\n\njulia\n issorted(alphabet(AminoAcid))\ntrue\n\n\n\n\n\nsource\n\n\nGets the alphabet encoding of a given BioSequence.\n\n\nsource\n\n\n#\n\n\nBioSymbols.gap\n \n \nFunction\n.\n\n\ngap(DNA)\n\n\n\n\n\nReturn \nDNA_Gap\n.\n\n\nsource\n\n\ngap(RNA)\n\n\n\n\n\nReturn \nRNA_Gap\n.\n\n\nsource\n\n\ngap(AminoAcid)\n\n\n\n\n\nReturn \nAA_Gap\n.\n\n\nsource\n\n\n#\n\n\nBioSymbols.iscompatible\n \n \nFunction\n.\n\n\niscompatible(x::T, y::T) where T \n: NucleicAcid\n\n\n\n\n\nTest if \nx\n and \ny\n are compatible with each other (i.e. \nx\n and \ny\n can be the same symbol).\n\n\nx\n and \ny\n must be the same type.\n\n\nExamples\n\n\njulia\n iscompatible(DNA_A, DNA_A)\ntrue\n\njulia\n iscompatible(DNA_C, DNA_N)  # DNA_N can be DNA_C\ntrue\n\njulia\n iscompatible(DNA_C, DNA_R)  # DNA_R (A or G) cannot be DNA_C\nfalse\n\n\n\n\n\nsource\n\n\niscompatible(x::AminoAcid, y::AminoAcid)\n\n\n\n\n\nTest if \nx\n and \ny\n are compatible with each other.\n\n\nExamples\n\n\njulia\n iscompatible(AA_A, AA_R)\nfalse\n\njulia\n iscompatible(AA_A, AA_X)\ntrue\n\n\n\n\n\nsource\n\n\n#\n\n\nBioSymbols.isambiguous\n \n \nFunction\n.\n\n\nisambiguous(nt::NucleicAcid)\n\n\n\n\n\nTest if \nnt\n is an ambiguous nucleotide.\n\n\nsource\n\n\nisambiguous(aa::AminoAcid)\n\n\n\n\n\nTest if \naa\n is an ambiguous amino acid.\n\n\nsource", 
            "title": "Biological Symbols"
        }, 
        {
            "location": "/symbols/#biological-symbols", 
            "text": "The  BioSequences  module provides three biological symbol (character) types:     Type  Meaning      DNA  DNA nucleotide    RNA  RNA nucleotide    AminoAcid  Amino acid     These symbols are elements of biological sequences, just as characters are elements of strings. See sections beginning from  Introduction to the sequence data-types  section for details.", 
            "title": "Biological symbols"
        }, 
        {
            "location": "/symbols/#dna-and-rna-nucleotides", 
            "text": "Set of nucleotide symbols in BioSequences.jl covers IUPAC nucleotide base plus a gap symbol:     Symbol  Constant  Meaning      'A'  DNA_A  /  RNA_A  A; Adenine    'C'  DNA_C  /  RNA_C  C; Cytosine    'G'  DNA_G  /  RNA_G  G; Guanine    'T'  DNA_T  T; Thymine (DNA only)    'U'  RNA_U  U; Uracil (RNA only)    'M'  DNA_M  /  RNA_M  A or C    'R'  DNA_R  /  RNA_R  A or G    'W'  DNA_W  /  RNA_W  A or T/U    'S'  DNA_S  /  RNA_S  C or G    'Y'  DNA_Y  /  RNA_Y  C or T/U    'K'  DNA_K  /  RNA_K  G or T/U    'V'  DNA_V  /  RNA_V  A or C or G; not T/U    'H'  DNA_H  /  RNA_H  A or C or T; not G    'D'  DNA_D  /  RNA_D  A or G or T/U; not C    'B'  DNA_B  /  RNA_B  C or G or T/U; not A    'N'  DNA_N  /  RNA_N  A or C or G or T/U    '-'  DNA_Gap  /  RNA_Gap  Gap (none of the above)     http://www.insdc.org/documents/feature_table.html#7.4.1  Symbols are accessible as constants with  DNA_  or  RNA_  prefix:  julia  DNA_A\nDNA_A\n\njulia  DNA_T\nDNA_T\n\njulia  RNA_U\nRNA_U\n\njulia  DNA_Gap\nDNA_Gap\n\njulia  typeof(DNA_A)\nBioSymbols.DNA\n\njulia  typeof(RNA_A)\nBioSymbols.RNA  Symbols can be constructed by converting regular characters:  julia  convert(DNA,  C )\nDNA_C\n\njulia  convert(DNA,  C ) === DNA_C\ntrue  Every nucleotide is encoded using the lower 4 bits of a byte. An unambiguous nucleotide has only one set bit and the other bits are unset. The table below summarizes all unambiguous nucleotides and their corresponding bits. An ambiguous nucleotide is the bitwise OR of unambiguous nucleotides that the ambiguous nucleotide can take. For example,  DNA_R  (meaning the nucleotide is either  DNA_A  or  DNA_G ) is encoded as  0101  because  0101  is the bitwise OR of  0001  ( DNA_A ) and  0100  ( DNA_G ). The gap symbol is always  0000 .     NucleicAcid  Bits      DNA_A ,  RNA_A  0001    DNA_C ,  RNA_C  0010    DNA_G ,  RNA_G  0100    DNA_T ,  RNA_U  1000     The next examples demonstrate bit operations of DNA:  julia  bits(reinterpret(UInt8, DNA_A)) 00000001 \n\njulia  bits(reinterpret(UInt8, DNA_G)) 00000100 \n\njulia  bits(reinterpret(UInt8, DNA_R)) 00000101 \n\njulia  bits(reinterpret(UInt8, DNA_B)) 00001110 \n\njulia  ~DNA_A\nDNA_B\n\njulia  DNA_A | DNA_G\nDNA_R\n\njulia  DNA_R   DNA_B\nDNA_G", 
            "title": "DNA and RNA nucleotides"
        }, 
        {
            "location": "/symbols/#amino-acids", 
            "text": "Set of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:     Symbol  Constant  Meaning      'A'  AA_A  Alanine    'R'  AA_R  Arginine    'N'  AA_N  Asparagine    'D'  AA_D  Aspartic acid (Aspartate)    'C'  AA_C  Cysteine    'Q'  AA_Q  Glutamine    'E'  AA_E  Glutamic acid (Glutamate)    'G'  AA_G  Glycine    'H'  AA_H  Histidine    'I'  AA_I  Isoleucine    'L'  AA_L  Leucine    'K'  AA_K  Lysine    'M'  AA_M  Methionine    'F'  AA_F  Phenylalanine    'P'  AA_P  Proline    'S'  AA_S  Serine    'T'  AA_T  Threonine    'W'  AA_W  Tryptophan    'Y'  AA_Y  Tyrosine    'V'  AA_V  Valine    'O'  AA_O  Pyrrolysine    'U'  AA_U  Selenocysteine    'B'  AA_B  Aspartic acid or Asparagine    'J'  AA_J  Leucine or Isoleucine    'Z'  AA_Z  Glutamine or Glutamic acid    'X'  AA_X  Any amino acid    '*'  AA_Term  Termination codon    '-'  AA_Gap  Gap (none of the above)     http://www.insdc.org/documents/feature_table.html#7.4.3  Symbols are accessible as constants with  AA_  prefix:  julia  AA_A\nAA_A\n\njulia  AA_Q\nAA_Q\n\njulia  AA_Term\nAA_Term\n\njulia  typeof(AA_A)\nBioSymbols.AminoAcid  Symbols can be constructed by converting regular characters:  julia  convert(AminoAcid,  A )\nAA_A\n\njulia  convert(AminoAcid,  P ) === AA_P\ntrue", 
            "title": "Amino acids"
        }, 
        {
            "location": "/symbols/#other-functions", 
            "text": "#  BioSymbols.alphabet     Function .  alphabet(DNA)  Get all symbols of  DNA  in sorted order.  Examples  julia  alphabet(DNA)\n(DNA_Gap, DNA_A, DNA_C, DNA_M, DNA_G, DNA_R, DNA_S, DNA_V, DNA_T, DNA_W, DNA_Y, DNA_H, DNA_K, DNA_D, DNA_B, DNA_N)\n\njulia  issorted(alphabet(DNA))\ntrue  source  alphabet(RNA)  Get all symbols of  RNA  in sorted order.  Examples  julia  alphabet(RNA)\n(RNA_Gap, RNA_A, RNA_C, RNA_M, RNA_G, RNA_R, RNA_S, RNA_V, RNA_U, RNA_W, RNA_Y, RNA_H, RNA_K, RNA_D, RNA_B, RNA_N)\n\njulia  issorted(alphabet(RNA))\ntrue  source  alphabet(AminoAcid)  Get all symbols of  AminoAcid  in sorted order.  Examples  julia  alphabet(AminoAcid)\n(AA_A, AA_R, AA_N, AA_D, AA_C, AA_Q, AA_E, AA_G, AA_H, AA_I, AA_L, AA_K, AA_M, AA_F, AA_P, AA_S, AA_T, AA_W, AA_Y, AA_V, AA_O, AA_U, AA_B, AA_J, AA_Z, AA_X, AA_Term, AA_Gap)\n\njulia  issorted(alphabet(AminoAcid))\ntrue  source  Gets the alphabet encoding of a given BioSequence.  source  #  BioSymbols.gap     Function .  gap(DNA)  Return  DNA_Gap .  source  gap(RNA)  Return  RNA_Gap .  source  gap(AminoAcid)  Return  AA_Gap .  source  #  BioSymbols.iscompatible     Function .  iscompatible(x::T, y::T) where T  : NucleicAcid  Test if  x  and  y  are compatible with each other (i.e.  x  and  y  can be the same symbol).  x  and  y  must be the same type.  Examples  julia  iscompatible(DNA_A, DNA_A)\ntrue\n\njulia  iscompatible(DNA_C, DNA_N)  # DNA_N can be DNA_C\ntrue\n\njulia  iscompatible(DNA_C, DNA_R)  # DNA_R (A or G) cannot be DNA_C\nfalse  source  iscompatible(x::AminoAcid, y::AminoAcid)  Test if  x  and  y  are compatible with each other.  Examples  julia  iscompatible(AA_A, AA_R)\nfalse\n\njulia  iscompatible(AA_A, AA_X)\ntrue  source  #  BioSymbols.isambiguous     Function .  isambiguous(nt::NucleicAcid)  Test if  nt  is an ambiguous nucleotide.  source  isambiguous(aa::AminoAcid)  Test if  aa  is an ambiguous amino acid.  source", 
            "title": "Other functions"
        }, 
        {
            "location": "/sequences/sequences/", 
            "text": "Biological sequences\n\n\nThe \nBioSequences\n module provides representations and tools for manipulating nucleotide and amino acid sequences.\n\n\n\n\nIntroduction to the sequence data-types\n\n\nSequences in BioSequences.jl are more strictly typed than in many other libraries; elements in a sequence are typed as biological symbol instead of character or byte. They are special purpose types rather than simply strings and hence offer additional functionality that naive string types don't have. Though this strictness sacrifices some convenience, it also means you can always rely on a DNA sequence type to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on. Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using either four bits per base (which is the default), or two bits per base. This makes them memory efficient and allows us to speed up many common operations and transformations, like nucleotide composition, reverse complement, and \nk\n-mer enumeration.\n\n\nThe \nBioSequences\n provides three different sequence types: \nBioSequence\n, \nKmer\n and \nReferenceSequence\n. Each of these types is a subtype of an abstract type called \nSequence\n and supports various string-like operations such as random access and iteration. Different sequence types have different features. In most situations, \nBioSequence\n type will do and is used as the default representation. But sometimes other types are much more preferable in terms of memory efficiency and computation performance.  Here is the summary table of these three types:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nElement type\n\n\nMutability\n\n\nAllocation\n\n\n\n\n\n\n\n\n\n\nBioSequence{A\n:Alphabet}\n\n\ngeneral-purpose biological sequences\n\n\nDNA, RNA, Amino acids\n\n\nmutable\n\n\nheap\n\n\n\n\n\n\nKmer{T\n:NucleicAcid,k}\n\n\nspecialized for short nucleotide sequences\n\n\nDNA, RNA\n\n\nimmutable\n\n\nstack / register\n\n\n\n\n\n\nReferenceSequence\n\n\nspecialized for long reference genomes\n\n\nDNA\n\n\nimmutable\n\n\nheap\n\n\n\n\n\n\n\n\nDetails of these different representations are explained in the following sections:\n\n\n\n\nBioSequence\n: \nGeneral-purpose sequences\n\n\nKmer\n: \nNucleic acid k-mers\n\n\nReferenceSequence\n: \nReference sequences", 
            "title": "Overview"
        }, 
        {
            "location": "/sequences/sequences/#biological-sequences", 
            "text": "The  BioSequences  module provides representations and tools for manipulating nucleotide and amino acid sequences.", 
            "title": "Biological sequences"
        }, 
        {
            "location": "/sequences/sequences/#introduction-to-the-sequence-data-types", 
            "text": "Sequences in BioSequences.jl are more strictly typed than in many other libraries; elements in a sequence are typed as biological symbol instead of character or byte. They are special purpose types rather than simply strings and hence offer additional functionality that naive string types don't have. Though this strictness sacrifices some convenience, it also means you can always rely on a DNA sequence type to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on. Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using either four bits per base (which is the default), or two bits per base. This makes them memory efficient and allows us to speed up many common operations and transformations, like nucleotide composition, reverse complement, and  k -mer enumeration.  The  BioSequences  provides three different sequence types:  BioSequence ,  Kmer  and  ReferenceSequence . Each of these types is a subtype of an abstract type called  Sequence  and supports various string-like operations such as random access and iteration. Different sequence types have different features. In most situations,  BioSequence  type will do and is used as the default representation. But sometimes other types are much more preferable in terms of memory efficiency and computation performance.  Here is the summary table of these three types:     Type  Description  Element type  Mutability  Allocation      BioSequence{A :Alphabet}  general-purpose biological sequences  DNA, RNA, Amino acids  mutable  heap    Kmer{T :NucleicAcid,k}  specialized for short nucleotide sequences  DNA, RNA  immutable  stack / register    ReferenceSequence  specialized for long reference genomes  DNA  immutable  heap     Details of these different representations are explained in the following sections:   BioSequence :  General-purpose sequences  Kmer :  Nucleic acid k-mers  ReferenceSequence :  Reference sequences", 
            "title": "Introduction to the sequence data-types"
        }, 
        {
            "location": "/sequences/bioseq/", 
            "text": "General-purpose sequences\n\n\nBioSequence{A}\n is a generic sequence type parameterized by an alphabet type \nA\n that defines the domain (or set) of biological symbols, and each alphabet has an associated symbol type. For example, \nAminoAcidAlphabet\n is associated with \nAminoAcid\n and hence an object of the \nBioSequence{AminoAcidAlphabet}\n type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.\n\n\nThe following table summarizes common sequence types that are defined in the \nBioSequences\n module:\n\n\n\n\n\n\n\n\nType\n\n\nSymbol type\n\n\nType alias\n\n\n\n\n\n\n\n\n\n\nBioSequence{DNAAlphabet{4}}\n\n\nDNA\n\n\nDNASequence\n\n\n\n\n\n\nBioSequence{RNAAlphabet{4}}\n\n\nRNA\n\n\nRNASequence\n\n\n\n\n\n\nBioSequence{AminoAcidAlphabet}\n\n\nAminoAcid\n\n\nAminoAcidSequence\n\n\n\n\n\n\nBioSequence{CharAlphabet}\n\n\nChar\n\n\nCharSequence\n\n\n\n\n\n\n\n\nParameterized definition of the \nBioSequence{A}\n type is for the purpose of unifying the data structure and operations of any symbol type. In most cases, users don't have to care about it and can use \ntype aliases\n listed above. However, the alphabet type fixes the internal memory encoding and plays an important role when optimizing performance of a program (see \nUsing a more compact sequence representation\n section for low-memory encodings).  It also enables a user to define their own alphabet only by defining few numbers of methods. This is described in \nDefining a new alphabet\n section.\n\n\n\n\nConstructing sequences\n\n\n\n\nUsing string literals\n\n\nMost immediately, sequence literals can be constructed using the string macros \ndna\n, \nrna\n, \naa\n, and \nchar\n:\n\n\njulia\n dna\nTACGTANNATC\n\n11nt DNA Sequence:\nTACGTANNATC\n\njulia\n rna\nAUUUGNCCANU\n\n11nt RNA Sequence:\nAUUUGNCCANU\n\njulia\n aa\nARNDCQEGHILKMFPSTWYVX\n\n21aa Amino Acid Sequence:\nARNDCQEGHILKMFPSTWYVX\n\njulia\n char\n\u03b1\u03b2\u03b3\u03b4\u03f5\n\n5char Char Sequence:\n\u03b1\u03b2\u03b3\u03b4\u03f5\n\n\n\n\n\nHowever it should be noted that by default these sequence literals allocate the \nBioSequence\n object before the code containing the sequence literal is run. This means there may be occasions where your program does not behave as you first expect. For example consider the following code:\n\n\njulia\n function foo()\n           s = dna\nCTT\n\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)\n\n\n\n\n\nYou might expect that every time you call \nfoo\n, that a DNA sequence \nCTTA\n would be returned. You might expect that this is because every time \nfoo\n is called, a new DNA sequence variable \nCTT\n is created, and and \nA\n nucleotide is pushed to it, and the result, \nCTTA\n is returned. In other words you might expect the following output:\n\n\njulia\n foo()\n4nt DNA Sequence:\nCTTA\n\njulia\n foo()\n4nt DNA Sequence:\nCTTA\n\njulia\n foo()\n4nt DNA Sequence:\nCTTA\n\n\n\n\n\nHowever, this is not what happens, instead the following happens:\n\n\njulia\n foo()\n4nt DNA Sequence:\nCTTA\n\njulia\n foo()\n5nt DNA Sequence:\nCTTAA\n\njulia\n foo()\n6nt DNA Sequence:\nCTTAAA\n\n\n\n\n\nThe reason for this is because the sequence literal is allocated only once before the first time the function \nfoo\n is called and run. Therefore, \ns\n in \nfoo\n is always a reference to that one sequence that was allocated. So one sequence is created before \nfoo\n is called, and then it is pushed to every time \nfoo\n is called. Thus, that one allocated sequence grows with every call of \nfoo\n.\n\n\nIf you wanted \nfoo\n to create a new sequence each time it is called, then you can add a flag to the end of the sequence literal to dictate behaviour: A flag of 's' means 'static': the sequence will be allocated before code is run, as is the default behaviour described above. However providing 'd' flag changes the behaviour: 'd' means 'dynamic': the sequence will be allocated at whilst the code is running, and not before. So to change \nfoo\n so as it creates a new sequence each time it is called, simply add the 'd' flag to the sequence literal:\n\n\njulia\n function foo()\n           s = dna\nCTT\nd     # \nd\n flag appended to the string literal.\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)\n\n\n\n\n\nNow every time \nfoo\n is called, a new sequence \nCTT\n is created, and an \nA\n nucleotide is pushed to it:\n\n\njulia\n foo()\n4nt DNA Sequence:\nCTTA\n\njulia\n foo()\n4nt DNA Sequence:\nCTTA\n\njulia\n foo()\n4nt DNA Sequence:\nCTTA\n\n\n\n\n\nSo the take home message of sequence literals is this:\n\n\nBe careful when you are using sequence literals inside of functions, and inside the bodies of things like for loops. And if you use them and are unsure, use the  's' and 'd' flags to ensure the behaviour you get is the behaviour you intend.\n\n\n\n\nOther constructors and conversion\n\n\nSequences can also be constructed from strings or arrays of nucleotide or amino acid symbols using constructors or the \nconvert\n function:\n\n\njulia\n DNASequence(\nTTANC\n)\n5nt DNA Sequence:\nTTANC\n\njulia\n DNASequence([DNA_T, DNA_T, DNA_A, DNA_N, DNA_C])\n5nt DNA Sequence:\nTTANC\n\njulia\n convert(DNASequence, [DNA_T, DNA_T, DNA_A, DNA_N, DNA_C])\n5nt DNA Sequence:\nTTANC\n\n\n\n\n\nUsing \nconvert\n, these operations are reversible: sequences can be converted to strings or arrays:\n\n\njulia\n convert(String, dna\nTTANGTA\n)\n\nTTANGTA\n\n\njulia\n convert(Vector{DNA}, dna\nTTANGTA\n)\n7-element Array{BioSymbols.DNA,1}:\n DNA_T\n DNA_T\n DNA_A\n DNA_N\n DNA_G\n DNA_T\n DNA_A\n\n\n\n\n\nSequences can also be concatenated into longer sequences:\n\n\njulia\n DNASequence(dna\nACGT\n, dna\nNNNN\n, dna\nTGCA\n)\n12nt DNA Sequence:\nACGTNNNNTGCA\n\njulia\n dna\nACGT\n * dna\nTGCA\n\n8nt DNA Sequence:\nACGTTGCA\n\njulia\n repeat(dna\nTA\n, 10)\n20nt DNA Sequence:\nTATATATATATATATATATA\n\njulia\n dna\nTA\n ^ 10\n20nt DNA Sequence:\nTATATATATATATATATATA\n\n\n\n\n\nDespite being separate types, \nDNASequence\n and \nRNASequence\n can freely be converted between efficiently without copying the underlying data:\n\n\njulia\n dna = dna\nTTANGTAGACCG\n\n12nt DNA Sequence:\nTTANGTAGACCG\n\njulia\n rna = convert(RNASequence, dna)\n12nt RNA Sequence:\nUUANGUAGACCG\n\njulia\n dna.data === rna.data  # underlying data are same\ntrue\n\n\n\n\n\nA random sequence can be obtained by the \nranddnaseq\n, \nrandrnaseq\n and \nrandaaseq\n functions, which generate \nDNASequence\n, \nRNASequence\n and \nAminoAcidSequence\n, respectively. Generated sequences are composed of the standard symbols without ambiguity and gap. For example, \nranddnaseq(6)\n may generate \ndna\"TCATAG\"\n but never generates \ndna\"TNANAG\"\n or \ndna\"T-ATAG\"\n.\n\n\nA translatable \nRNASequence\n can also be converted to an \nAminoAcidSequence\n using the \ntranslate\n function.\n\n\n\n\nIndexing, modifying and transformations\n\n\n\n\nGetindex\n\n\nSequences for the most part behave like other vector or string types. They can be indexed using integers or ranges:\n\n\njulia\n seq = dna\nACGTTTANAGTNNAGTACC\n\n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia\n seq[5]\nDNA_T\n\njulia\n seq[6:end]\n14nt DNA Sequence:\nTANAGTNNAGTACC\n\n\n\n\n\nNote that, indexing a biological sequence by range creates a subsequence of the original sequence. Unlike \nArrays\n in the standard library, creating a subsequence is copy-free: a subsequence simply points to the original sequence data with its range. You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:\n\n\njulia\n seq = dna\nAAAA\n    # create a sequence\n4nt DNA Sequence:\nAAAA\n\njulia\n subseq = seq[1:2]  # create a subsequence from `seq`\n2nt DNA Sequence:\nAA\n\njulia\n subseq[2] = DNA_T  # modify the second element of it\nDNA_T\n\njulia\n subseq             # the subsequence is modified\n2nt DNA Sequence:\nAT\n\njulia\n seq                # but the original sequence is not\n4nt DNA Sequence:\nAAAA\n\n\n\n\n\nThis is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called \ncopy-on-write\n strategy and users don't need to care about it because it is transparent: If the user modifies a sequence with or subsequence, the job of managing and protecting the underlying data of sequences is handled for them.\n\n\n\n\nSetindex and modifying DNA sequences\n\n\nThe biological symbol at a given locus in a biological sequence can be set using setindex:\n\n\njulia\n seq = dna\nACGTTTANAGTNNAGTACC\n\n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia\n seq[5] = DNA_A\nDNA_A\n\n\n\n\n\nIn addition, many other modifying operations are possible for biological sequences such as \npush!\n, \npop!\n, and \ninsert!\n, which should be familiar to people used to editing arrays.\n\n\npush!\npop!\nshift!\nunshift!\ninsert!\ndeleteat!(::BioSequences.BioSequence, ::Integer)\nappend!\ncopy!\n\n\n\n\n\nHere are some examples:\n\n\njulia\n seq = dna\nACG\n\n3nt DNA Sequence:\nACG\n\njulia\n push!(seq, DNA_T)\n4nt DNA Sequence:\nACGT\n\njulia\n append!(seq, dna\nAT\n)\n6nt DNA Sequence:\nACGTAT\n\njulia\n reverse!(seq)\n6nt DNA Sequence:\nTATGCA\n\njulia\n complement!(seq)\n6nt DNA Sequence:\nATACGT\n\njulia\n reverse_complement!(seq)\n6nt DNA Sequence:\nACGTAT\n\njulia\n deleteat!(seq, 2)\n5nt DNA Sequence:\nAGTAT\n\njulia\n deleteat!(seq, 2:3)\n3nt DNA Sequence:\nAAT\n\n\n\n\n\n\n\nAdditional transformations\n\n\nIn addition to these basic modifying functions, other sequence transformations which are common in bioinformatics are also provided.\n\n\n#\n\n\nBase.reverse!\n \n \nFunction\n.\n\n\nreverse!(v [, start=1 [, stop=length(v) ]]) -\n v\n\n\n\n\n\nIn-place version of \nreverse\n.\n\n\nsource\n\n\n#\n\n\nBioSequences.complement!\n \n \nFunction\n.\n\n\ncomplement!(seq)\n\n\n\n\n\nMake a complement sequence of \nseq\n in place.\n\n\nsource\n\n\ncomplement!(seq)\n\n\n\n\n\nTransform \nseq\n into it's complement.\n\n\nsource\n\n\n#\n\n\nBioSequences.reverse_complement!\n \n \nFunction\n.\n\n\nreverse_complement!(seq)\n\n\n\n\n\nMake a reversed complement sequence of \nseq\n in place.\n\n\nAmbiguous nucleotides are left as-is.\n\n\nsource\n\n\n#\n\n\nBioSequences.ungap\n \n \nFunction\n.\n\n\nCreate a copy of a sequence with gap characters removed.\n\n\nsource\n\n\n#\n\n\nBioSequences.ungap!\n \n \nFunction\n.\n\n\nRemove gap characters from a sequence. Modifies the input sequence.\n\n\nsource\n\n\njulia\n seq = dna\nACG\n\n3nt DNA Sequence:\nACG\n\njulia\n push!(seq, DNA_T)\n4nt DNA Sequence:\nACGT\n\njulia\n append!(seq, dna\nAT\n)\n6nt DNA Sequence:\nACGTAT\n\njulia\n reverse!(seq)\n6nt DNA Sequence:\nTATGCA\n\njulia\n complement!(seq)\n6nt DNA Sequence:\nATACGT\n\njulia\n reverse_complement!(seq)\n6nt DNA Sequence:\nACGTAT\n\n\n\n\n\n\n\nTranslation\n\n\nTranslation is a slightly more complex transformation for RNA Sequences and so we describe it here in more detail.\n\n\nThe \ntranslate\n funtion translates a sequence of codons in a RNA sequence to a amino acid sequence besed on a genetic code mapping. The \nBioSequences\n module contains all NCBI defined genetic codes and they are registered in \nncbi_trans_table\n.\n\n\n#\n\n\nBioSequences.translate\n \n \nFunction\n.\n\n\ntranslate(rna_seq, code=standard_genetic_code, allow_ambiguous_codons=true)\n\n\n\n\n\nTranslate an \nRNASequence\n to an \nAminoAcidSequence\n.\n\n\nTranslation uses genetic code \ncode\n to map codons to amino acids. See \nncbi_trans_table\n for available genetic codes. If codons in the given RNA sequence cannot determine a unique amino acid, they will be translated to \nAA_X\n if \nallow_ambiguous_codons\n is \ntrue\n and otherwise result in an error.\n\n\nsource\n\n\n#\n\n\nBioSequences.ncbi_trans_table\n \n \nConstant\n.\n\n\nGenetic code list of NCBI.\n\n\nThe standard genetic code is \nncbi_trans_table[1]\n and others can be shown by \nshow(ncbi_trans_table)\n. For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.\n\n\nsource\n\n\njulia\n ncbi_trans_table\nTranslation Tables:\n  1. The Standard Code (standard_genetic_code)\n  2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)\n  3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)\n  4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)\n  5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)\n  6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)\n  9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)\n 10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)\n 11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)\n 12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)\n 13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)\n 14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)\n 16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)\n 21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)\n 22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)\n 23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)\n 24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)\n 25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)\n\n\n\n\n\nhttp://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes\n\n\n\n\nSite counting\n\n\nBioSequences extends the \nBase.count\n method to provide some useful utilities for counting the number of sites in biological sequences.\n\n\n\n\nSite types\n\n\nDifferent types of site can be counted. Each of these types is a concrete subtype of the abstract type \nSite\n:\n\n\n#\n\n\nBioSequences.Certain\n \n \nType\n.\n\n\nA \nCertain\n site describes a site where both of two aligned sites are not an ambiguity symbol or a gap.\n\n\nsource\n\n\n#\n\n\nBioSequences.Gap\n \n \nType\n.\n\n\nAn \nGap\n site describes a site where either of two aligned sites are a gap symbol '-'.\n\n\nsource\n\n\n#\n\n\nBioSequences.Ambiguous\n \n \nType\n.\n\n\nAn \nAmbiguous\n site describes a site where either of two aligned sites are an ambiguity symbol.\n\n\nsource\n\n\n#\n\n\nBioSequences.Match\n \n \nType\n.\n\n\nA \nMatch\n site describes a site where two aligned nucleotides are the same biological symbol.\n\n\nsource\n\n\n#\n\n\nBioSequences.Mismatch\n \n \nType\n.\n\n\nA \nMismatch\n site describes a site where two aligned nucleotides are not the same biological symbol.\n\n\nsource\n\n\n\n\nBase.count\n methods\n\n\nThe count method can be used with two sequences and a concrete subtype of \nSite\n:\n\n\njulia\n count(Match, dna\nATCGATCG\n, dna\nAAGGTTCG\n)\n5\n\n\n\n\n\nBy providing a \nwindow\n and \nstep\n size, counting can be done from within a sliding window:\n\n\njulia\n count(Match, dna\nATCGATCG\n, dna\nAAGGTTCG\n, 3, 1)\n6-element Array{IntervalTrees.IntervalValue{Int64,Int64},1}:\n IntervalTrees.IntervalValue{Int64,Int64}\n(1,3) =\n 1\n IntervalTrees.IntervalValue{Int64,Int64}\n(2,4) =\n 1\n IntervalTrees.IntervalValue{Int64,Int64}\n(3,5) =\n 1\n IntervalTrees.IntervalValue{Int64,Int64}\n(4,6) =\n 2\n IntervalTrees.IntervalValue{Int64,Int64}\n(5,7) =\n 2\n IntervalTrees.IntervalValue{Int64,Int64}\n(6,8) =\n 3\n\n\n\n\n\n\n\nThe \npairwise_count\n function\n\n\nCounting can also be done on a set of sequences in a pairwise manner with the \ncount_pairwise\n function:\n\n\njulia\n count_pairwise(Match, dna\nATCGCCA-\n, dna\nATCGCCTA\n, dna\nATCGCCT-\n, dna\nGTCGCCTA\n)\n4\u00d74 Array{Int64,2}:\n 0  6  7  5\n 6  0  7  7\n 7  7  0  6\n 5  7  6  0\n\n\n\n\n\n\n\nIteration\n\n\nSequences also work as iterators over symbols:\n\n\njulia\n n = 0\n0\n\njulia\n for nt in dna\nATNGNNT\n\n           if nt == DNA_N\n               n += 1\n           end\n       end\n\njulia\n n\n3\n\n\n\n\n\n\n\nUsing a more compact sequence representation\n\n\nAs we saw above, DNA and RNA sequences can store any ambiguous nucleotides like 'N'.  If you are sure that nucleotide sequences store unambiguous nucleotides only, you can save the memory space of sequences. \nDNAAlphabet{2}\n is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). To create a sequence of this alphabet, you need to explicitly pass \nDNAAlphabet{2}\n to \nBioSequence\n as its type parameter:\n\n\njulia\n seq = BioSequence{DNAAlphabet{2}}(\nACGT\n)\n4nt DNA Sequence:\nACGT\n\n\n\n\n\nRecall that \nDNASequence\n is a type alias of \nBioSequence{DNAAlphabet{4}}\n, which uses four bits per base. That is, \nBioSequence{DNAAlphabet{2}}\n saves half of memory footprint compared to \nBioSequence{DNAAlphabet{4}}\n. If you need to handle reference genomes that are composed of five nucleotides, ACGTN, consider to use the \nReferenceSequence\n type described in the \nReference sequences\n section.\n\n\n\n\nDefining a new alphabet\n\n\nThe alphabet type parameter \nA\n of \nBioSequence{A}\n enables a user to extend functionality of \nBioSequence\n with minimum effort. As an example, definition of a new alphabet type representing a sequence of boolean values is shown below:\n\n\njulia\n immutable BoolAlphabet \n: Alphabet end\n\njulia\n BioSequences.bitsof(::Type{BoolAlphabet}) = 1\n\njulia\n BioSequences.eltype(::Type{BoolAlphabet}) = Bool\n\njulia\n BioSequences.alphabet(::Type{BoolAlphabet}) = false:true\n\njulia\n function BioSequences.encode(::Type{BoolAlphabet}, x::Bool)\n           return UInt64(ifelse(x, 0x01, 0x00))\n       end\n\njulia\n function BioSequences.decode(::Type{BoolAlphabet}, x::UInt64)\n           if x \n 0x01\n               throw(BioSequences.DecodeError(BoolAlphabet, x))\n           end\n           return ifelse(x == 0x00, false, true)\n       end", 
            "title": "BioSequence"
        }, 
        {
            "location": "/sequences/bioseq/#general-purpose-sequences", 
            "text": "BioSequence{A}  is a generic sequence type parameterized by an alphabet type  A  that defines the domain (or set) of biological symbols, and each alphabet has an associated symbol type. For example,  AminoAcidAlphabet  is associated with  AminoAcid  and hence an object of the  BioSequence{AminoAcidAlphabet}  type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.  The following table summarizes common sequence types that are defined in the  BioSequences  module:     Type  Symbol type  Type alias      BioSequence{DNAAlphabet{4}}  DNA  DNASequence    BioSequence{RNAAlphabet{4}}  RNA  RNASequence    BioSequence{AminoAcidAlphabet}  AminoAcid  AminoAcidSequence    BioSequence{CharAlphabet}  Char  CharSequence     Parameterized definition of the  BioSequence{A}  type is for the purpose of unifying the data structure and operations of any symbol type. In most cases, users don't have to care about it and can use  type aliases  listed above. However, the alphabet type fixes the internal memory encoding and plays an important role when optimizing performance of a program (see  Using a more compact sequence representation  section for low-memory encodings).  It also enables a user to define their own alphabet only by defining few numbers of methods. This is described in  Defining a new alphabet  section.", 
            "title": "General-purpose sequences"
        }, 
        {
            "location": "/sequences/bioseq/#constructing-sequences", 
            "text": "", 
            "title": "Constructing sequences"
        }, 
        {
            "location": "/sequences/bioseq/#using-string-literals", 
            "text": "Most immediately, sequence literals can be constructed using the string macros  dna ,  rna ,  aa , and  char :  julia  dna TACGTANNATC \n11nt DNA Sequence:\nTACGTANNATC\n\njulia  rna AUUUGNCCANU \n11nt RNA Sequence:\nAUUUGNCCANU\n\njulia  aa ARNDCQEGHILKMFPSTWYVX \n21aa Amino Acid Sequence:\nARNDCQEGHILKMFPSTWYVX\n\njulia  char \u03b1\u03b2\u03b3\u03b4\u03f5 \n5char Char Sequence:\n\u03b1\u03b2\u03b3\u03b4\u03f5  However it should be noted that by default these sequence literals allocate the  BioSequence  object before the code containing the sequence literal is run. This means there may be occasions where your program does not behave as you first expect. For example consider the following code:  julia  function foo()\n           s = dna CTT \n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)  You might expect that every time you call  foo , that a DNA sequence  CTTA  would be returned. You might expect that this is because every time  foo  is called, a new DNA sequence variable  CTT  is created, and and  A  nucleotide is pushed to it, and the result,  CTTA  is returned. In other words you might expect the following output:  julia  foo()\n4nt DNA Sequence:\nCTTA\n\njulia  foo()\n4nt DNA Sequence:\nCTTA\n\njulia  foo()\n4nt DNA Sequence:\nCTTA  However, this is not what happens, instead the following happens:  julia  foo()\n4nt DNA Sequence:\nCTTA\n\njulia  foo()\n5nt DNA Sequence:\nCTTAA\n\njulia  foo()\n6nt DNA Sequence:\nCTTAAA  The reason for this is because the sequence literal is allocated only once before the first time the function  foo  is called and run. Therefore,  s  in  foo  is always a reference to that one sequence that was allocated. So one sequence is created before  foo  is called, and then it is pushed to every time  foo  is called. Thus, that one allocated sequence grows with every call of  foo .  If you wanted  foo  to create a new sequence each time it is called, then you can add a flag to the end of the sequence literal to dictate behaviour: A flag of 's' means 'static': the sequence will be allocated before code is run, as is the default behaviour described above. However providing 'd' flag changes the behaviour: 'd' means 'dynamic': the sequence will be allocated at whilst the code is running, and not before. So to change  foo  so as it creates a new sequence each time it is called, simply add the 'd' flag to the sequence literal:  julia  function foo()\n           s = dna CTT d     #  d  flag appended to the string literal.\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)  Now every time  foo  is called, a new sequence  CTT  is created, and an  A  nucleotide is pushed to it:  julia  foo()\n4nt DNA Sequence:\nCTTA\n\njulia  foo()\n4nt DNA Sequence:\nCTTA\n\njulia  foo()\n4nt DNA Sequence:\nCTTA  So the take home message of sequence literals is this:  Be careful when you are using sequence literals inside of functions, and inside the bodies of things like for loops. And if you use them and are unsure, use the  's' and 'd' flags to ensure the behaviour you get is the behaviour you intend.", 
            "title": "Using string literals"
        }, 
        {
            "location": "/sequences/bioseq/#other-constructors-and-conversion", 
            "text": "Sequences can also be constructed from strings or arrays of nucleotide or amino acid symbols using constructors or the  convert  function:  julia  DNASequence( TTANC )\n5nt DNA Sequence:\nTTANC\n\njulia  DNASequence([DNA_T, DNA_T, DNA_A, DNA_N, DNA_C])\n5nt DNA Sequence:\nTTANC\n\njulia  convert(DNASequence, [DNA_T, DNA_T, DNA_A, DNA_N, DNA_C])\n5nt DNA Sequence:\nTTANC  Using  convert , these operations are reversible: sequences can be converted to strings or arrays:  julia  convert(String, dna TTANGTA ) TTANGTA \n\njulia  convert(Vector{DNA}, dna TTANGTA )\n7-element Array{BioSymbols.DNA,1}:\n DNA_T\n DNA_T\n DNA_A\n DNA_N\n DNA_G\n DNA_T\n DNA_A  Sequences can also be concatenated into longer sequences:  julia  DNASequence(dna ACGT , dna NNNN , dna TGCA )\n12nt DNA Sequence:\nACGTNNNNTGCA\n\njulia  dna ACGT  * dna TGCA \n8nt DNA Sequence:\nACGTTGCA\n\njulia  repeat(dna TA , 10)\n20nt DNA Sequence:\nTATATATATATATATATATA\n\njulia  dna TA  ^ 10\n20nt DNA Sequence:\nTATATATATATATATATATA  Despite being separate types,  DNASequence  and  RNASequence  can freely be converted between efficiently without copying the underlying data:  julia  dna = dna TTANGTAGACCG \n12nt DNA Sequence:\nTTANGTAGACCG\n\njulia  rna = convert(RNASequence, dna)\n12nt RNA Sequence:\nUUANGUAGACCG\n\njulia  dna.data === rna.data  # underlying data are same\ntrue  A random sequence can be obtained by the  randdnaseq ,  randrnaseq  and  randaaseq  functions, which generate  DNASequence ,  RNASequence  and  AminoAcidSequence , respectively. Generated sequences are composed of the standard symbols without ambiguity and gap. For example,  randdnaseq(6)  may generate  dna\"TCATAG\"  but never generates  dna\"TNANAG\"  or  dna\"T-ATAG\" .  A translatable  RNASequence  can also be converted to an  AminoAcidSequence  using the  translate  function.", 
            "title": "Other constructors and conversion"
        }, 
        {
            "location": "/sequences/bioseq/#indexing-modifying-and-transformations", 
            "text": "", 
            "title": "Indexing, modifying and transformations"
        }, 
        {
            "location": "/sequences/bioseq/#getindex", 
            "text": "Sequences for the most part behave like other vector or string types. They can be indexed using integers or ranges:  julia  seq = dna ACGTTTANAGTNNAGTACC \n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia  seq[5]\nDNA_T\n\njulia  seq[6:end]\n14nt DNA Sequence:\nTANAGTNNAGTACC  Note that, indexing a biological sequence by range creates a subsequence of the original sequence. Unlike  Arrays  in the standard library, creating a subsequence is copy-free: a subsequence simply points to the original sequence data with its range. You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:  julia  seq = dna AAAA     # create a sequence\n4nt DNA Sequence:\nAAAA\n\njulia  subseq = seq[1:2]  # create a subsequence from `seq`\n2nt DNA Sequence:\nAA\n\njulia  subseq[2] = DNA_T  # modify the second element of it\nDNA_T\n\njulia  subseq             # the subsequence is modified\n2nt DNA Sequence:\nAT\n\njulia  seq                # but the original sequence is not\n4nt DNA Sequence:\nAAAA  This is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called  copy-on-write  strategy and users don't need to care about it because it is transparent: If the user modifies a sequence with or subsequence, the job of managing and protecting the underlying data of sequences is handled for them.", 
            "title": "Getindex"
        }, 
        {
            "location": "/sequences/bioseq/#setindex-and-modifying-dna-sequences", 
            "text": "The biological symbol at a given locus in a biological sequence can be set using setindex:  julia  seq = dna ACGTTTANAGTNNAGTACC \n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia  seq[5] = DNA_A\nDNA_A  In addition, many other modifying operations are possible for biological sequences such as  push! ,  pop! , and  insert! , which should be familiar to people used to editing arrays.  push!\npop!\nshift!\nunshift!\ninsert!\ndeleteat!(::BioSequences.BioSequence, ::Integer)\nappend!\ncopy!  Here are some examples:  julia  seq = dna ACG \n3nt DNA Sequence:\nACG\n\njulia  push!(seq, DNA_T)\n4nt DNA Sequence:\nACGT\n\njulia  append!(seq, dna AT )\n6nt DNA Sequence:\nACGTAT\n\njulia  reverse!(seq)\n6nt DNA Sequence:\nTATGCA\n\njulia  complement!(seq)\n6nt DNA Sequence:\nATACGT\n\njulia  reverse_complement!(seq)\n6nt DNA Sequence:\nACGTAT\n\njulia  deleteat!(seq, 2)\n5nt DNA Sequence:\nAGTAT\n\njulia  deleteat!(seq, 2:3)\n3nt DNA Sequence:\nAAT", 
            "title": "Setindex and modifying DNA sequences"
        }, 
        {
            "location": "/sequences/bioseq/#additional-transformations", 
            "text": "In addition to these basic modifying functions, other sequence transformations which are common in bioinformatics are also provided.  #  Base.reverse!     Function .  reverse!(v [, start=1 [, stop=length(v) ]]) -  v  In-place version of  reverse .  source  #  BioSequences.complement!     Function .  complement!(seq)  Make a complement sequence of  seq  in place.  source  complement!(seq)  Transform  seq  into it's complement.  source  #  BioSequences.reverse_complement!     Function .  reverse_complement!(seq)  Make a reversed complement sequence of  seq  in place.  Ambiguous nucleotides are left as-is.  source  #  BioSequences.ungap     Function .  Create a copy of a sequence with gap characters removed.  source  #  BioSequences.ungap!     Function .  Remove gap characters from a sequence. Modifies the input sequence.  source  julia  seq = dna ACG \n3nt DNA Sequence:\nACG\n\njulia  push!(seq, DNA_T)\n4nt DNA Sequence:\nACGT\n\njulia  append!(seq, dna AT )\n6nt DNA Sequence:\nACGTAT\n\njulia  reverse!(seq)\n6nt DNA Sequence:\nTATGCA\n\njulia  complement!(seq)\n6nt DNA Sequence:\nATACGT\n\njulia  reverse_complement!(seq)\n6nt DNA Sequence:\nACGTAT", 
            "title": "Additional transformations"
        }, 
        {
            "location": "/sequences/bioseq/#translation", 
            "text": "Translation is a slightly more complex transformation for RNA Sequences and so we describe it here in more detail.  The  translate  funtion translates a sequence of codons in a RNA sequence to a amino acid sequence besed on a genetic code mapping. The  BioSequences  module contains all NCBI defined genetic codes and they are registered in  ncbi_trans_table .  #  BioSequences.translate     Function .  translate(rna_seq, code=standard_genetic_code, allow_ambiguous_codons=true)  Translate an  RNASequence  to an  AminoAcidSequence .  Translation uses genetic code  code  to map codons to amino acids. See  ncbi_trans_table  for available genetic codes. If codons in the given RNA sequence cannot determine a unique amino acid, they will be translated to  AA_X  if  allow_ambiguous_codons  is  true  and otherwise result in an error.  source  #  BioSequences.ncbi_trans_table     Constant .  Genetic code list of NCBI.  The standard genetic code is  ncbi_trans_table[1]  and others can be shown by  show(ncbi_trans_table) . For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.  source  julia  ncbi_trans_table\nTranslation Tables:\n  1. The Standard Code (standard_genetic_code)\n  2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)\n  3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)\n  4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)\n  5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)\n  6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)\n  9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)\n 10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)\n 11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)\n 12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)\n 13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)\n 14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)\n 16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)\n 21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)\n 22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)\n 23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)\n 24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)\n 25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)  http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes", 
            "title": "Translation"
        }, 
        {
            "location": "/sequences/bioseq/#site-counting", 
            "text": "BioSequences extends the  Base.count  method to provide some useful utilities for counting the number of sites in biological sequences.", 
            "title": "Site counting"
        }, 
        {
            "location": "/sequences/bioseq/#site-types", 
            "text": "Different types of site can be counted. Each of these types is a concrete subtype of the abstract type  Site :  #  BioSequences.Certain     Type .  A  Certain  site describes a site where both of two aligned sites are not an ambiguity symbol or a gap.  source  #  BioSequences.Gap     Type .  An  Gap  site describes a site where either of two aligned sites are a gap symbol '-'.  source  #  BioSequences.Ambiguous     Type .  An  Ambiguous  site describes a site where either of two aligned sites are an ambiguity symbol.  source  #  BioSequences.Match     Type .  A  Match  site describes a site where two aligned nucleotides are the same biological symbol.  source  #  BioSequences.Mismatch     Type .  A  Mismatch  site describes a site where two aligned nucleotides are not the same biological symbol.  source", 
            "title": "Site types"
        }, 
        {
            "location": "/sequences/bioseq/#basecount-methods", 
            "text": "The count method can be used with two sequences and a concrete subtype of  Site :  julia  count(Match, dna ATCGATCG , dna AAGGTTCG )\n5  By providing a  window  and  step  size, counting can be done from within a sliding window:  julia  count(Match, dna ATCGATCG , dna AAGGTTCG , 3, 1)\n6-element Array{IntervalTrees.IntervalValue{Int64,Int64},1}:\n IntervalTrees.IntervalValue{Int64,Int64}\n(1,3) =  1\n IntervalTrees.IntervalValue{Int64,Int64}\n(2,4) =  1\n IntervalTrees.IntervalValue{Int64,Int64}\n(3,5) =  1\n IntervalTrees.IntervalValue{Int64,Int64}\n(4,6) =  2\n IntervalTrees.IntervalValue{Int64,Int64}\n(5,7) =  2\n IntervalTrees.IntervalValue{Int64,Int64}\n(6,8) =  3", 
            "title": "Base.count methods"
        }, 
        {
            "location": "/sequences/bioseq/#the-pairwise_count-function", 
            "text": "Counting can also be done on a set of sequences in a pairwise manner with the  count_pairwise  function:  julia  count_pairwise(Match, dna ATCGCCA- , dna ATCGCCTA , dna ATCGCCT- , dna GTCGCCTA )\n4\u00d74 Array{Int64,2}:\n 0  6  7  5\n 6  0  7  7\n 7  7  0  6\n 5  7  6  0", 
            "title": "The pairwise_count function"
        }, 
        {
            "location": "/sequences/bioseq/#iteration", 
            "text": "Sequences also work as iterators over symbols:  julia  n = 0\n0\n\njulia  for nt in dna ATNGNNT \n           if nt == DNA_N\n               n += 1\n           end\n       end\n\njulia  n\n3", 
            "title": "Iteration"
        }, 
        {
            "location": "/sequences/bioseq/#using-a-more-compact-sequence-representation", 
            "text": "As we saw above, DNA and RNA sequences can store any ambiguous nucleotides like 'N'.  If you are sure that nucleotide sequences store unambiguous nucleotides only, you can save the memory space of sequences.  DNAAlphabet{2}  is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). To create a sequence of this alphabet, you need to explicitly pass  DNAAlphabet{2}  to  BioSequence  as its type parameter:  julia  seq = BioSequence{DNAAlphabet{2}}( ACGT )\n4nt DNA Sequence:\nACGT  Recall that  DNASequence  is a type alias of  BioSequence{DNAAlphabet{4}} , which uses four bits per base. That is,  BioSequence{DNAAlphabet{2}}  saves half of memory footprint compared to  BioSequence{DNAAlphabet{4}} . If you need to handle reference genomes that are composed of five nucleotides, ACGTN, consider to use the  ReferenceSequence  type described in the  Reference sequences  section.", 
            "title": "Using a more compact sequence representation"
        }, 
        {
            "location": "/sequences/bioseq/#defining-a-new-alphabet", 
            "text": "The alphabet type parameter  A  of  BioSequence{A}  enables a user to extend functionality of  BioSequence  with minimum effort. As an example, definition of a new alphabet type representing a sequence of boolean values is shown below:  julia  immutable BoolAlphabet  : Alphabet end\n\njulia  BioSequences.bitsof(::Type{BoolAlphabet}) = 1\n\njulia  BioSequences.eltype(::Type{BoolAlphabet}) = Bool\n\njulia  BioSequences.alphabet(::Type{BoolAlphabet}) = false:true\n\njulia  function BioSequences.encode(::Type{BoolAlphabet}, x::Bool)\n           return UInt64(ifelse(x, 0x01, 0x00))\n       end\n\njulia  function BioSequences.decode(::Type{BoolAlphabet}, x::UInt64)\n           if x   0x01\n               throw(BioSequences.DecodeError(BoolAlphabet, x))\n           end\n           return ifelse(x == 0x00, false, true)\n       end", 
            "title": "Defining a new alphabet"
        }, 
        {
            "location": "/sequences/refseq/", 
            "text": "Reference sequences\n\n\nDNASequence\n (alias of \nBioSequence{DNAAlphabet{4}}\n) is a flexible data structure but always consumes 4 bits per base, which will waste a large part of the memory space when storing reference genome sequences.  In such a case, \nReferenceSequence\n is helpful because it compresses positions of 'N' symbols so that long DNA sequences are stored with almost 2 bits per base. An important limitation is that the \nReferenceSequence\n type is immutable due to the compression. Other sequence-like operations are supported:\n\n\njulia\n \nseq\n \n=\n \nReferenceSequence\n(\ndna\nNNCGTATTTTCN\n)\n\n\n12nt Reference Sequence:\n\n\nNNCGTATTTTCN\n\n\n\njulia\n \nseq\n[\n1\n]\n\n\nDNA_N\n\n\n\njulia\n \nseq\n[\n5\n]\n\n\nDNA_T\n\n\n\njulia\n \nseq\n[\n2\n:\n6\n]\n\n\n5nt Reference Sequence:\n\n\nNCGTA\n\n\n\njulia\n \nReferenceSequence\n(\ndna\nATGM\n)\n  \n# DNA_M is not accepted\n\n\nERROR: ArgumentError: invalid symbol M \u2209 {A,C,G,T,N} at 4\n\n\n in convert at /Users/kenta/.julia/v0.4/Bio/src/seq/refseq.jl:58\n\n\n in call at essentials.jl:56", 
            "title": "Reference Sequences"
        }, 
        {
            "location": "/sequences/refseq/#reference-sequences", 
            "text": "DNASequence  (alias of  BioSequence{DNAAlphabet{4}} ) is a flexible data structure but always consumes 4 bits per base, which will waste a large part of the memory space when storing reference genome sequences.  In such a case,  ReferenceSequence  is helpful because it compresses positions of 'N' symbols so that long DNA sequences are stored with almost 2 bits per base. An important limitation is that the  ReferenceSequence  type is immutable due to the compression. Other sequence-like operations are supported:  julia   seq   =   ReferenceSequence ( dna NNCGTATTTTCN )  12nt Reference Sequence:  NNCGTATTTTCN  julia   seq [ 1 ]  DNA_N  julia   seq [ 5 ]  DNA_T  julia   seq [ 2 : 6 ]  5nt Reference Sequence:  NCGTA  julia   ReferenceSequence ( dna ATGM )    # DNA_M is not accepted  ERROR: ArgumentError: invalid symbol M \u2209 {A,C,G,T,N} at 4   in convert at /Users/kenta/.julia/v0.4/Bio/src/seq/refseq.jl:58   in call at essentials.jl:56", 
            "title": "Reference sequences"
        }, 
        {
            "location": "/sequences/kmer/", 
            "text": "Nucleic acid k-mers\n\n\nA common strategy to simplify the analysis of sequence data is to operate or short k-mers, for size fixed size \nk\n. These can be packed into machine integers allowing extremely efficient code. The \nBioSequences\n module has built in support for representing short sequences in 64-bit integers. Besides being fixed length, \nKmer\n types, unlike other sequence types cannot contain ambiguous symbols like 'N'.\n\n\nThe \nKmer{T,k}\n type parameterized on symbol type (\nT\n, either \nDNA\n, or \nRNA\n) and size \nk\n. For ease of writing code, two type aliases for each nucleotide type are defined and named as \nDNAKmer{k}\n and \nRNAKmer{k}\n:\n\n\njulia\n DNAKmer(\nACGT\n)  # create a DNA 4-mer from a string\nDNA 4-mer:\nACGT\n\njulia\n RNAKmer(\nACGU\n)  # create an RNA 4-mer from a string\nRNA 4-mer:\nACGU\n\njulia\n kmer\nACGT\n # DNA k-mers may also be written as literals\nDNA 4-mer:\nACGT\n\njulia\n typeof(DNAKmer(\nACGT\n))\nBioSequences.Kmer{BioSymbols.DNA,4}\n\n\n\n\n\n#\n\n\nBioSequences.each\n \n \nFunction\n.\n\n\neach(::Type{Kmer{T,k}}, seq::Sequence[, step=1])\n\n\n\n\n\nInitialize an iterator over all k-mers in a sequence \nseq\n skipping ambiguous nucleotides without changing the reading frame.\n\n\nArguments\n\n\n\n\nKmer{T,k}\n: k-mer type to enumerate.\n\n\nseq\n: a nucleotide sequence.\n\n\nstep=1\n: the number of positions between iterated k-mers\n\n\n\n\nExamples\n\n\n# iterate over DNA codons\nfor (pos, codon) in each(DNAKmer{3}, dna\nATCCTANAGNTACT\n, 3)\n    @show pos, codon\nend\n\n\n\n\n\nsource\n\n\n#\n\n\nBioSequences.canonical\n \n \nFunction\n.\n\n\ncanonical(kmer::Kmer)\n\n\n\n\n\nReturn the canonical k-mer of \nx\n.\n\n\nA canonical k-mer is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting k-mers in data that is not strand specific, and thus observing k-mer is equivalent to observing its reverse complement.\n\n\nsource\n\n\n#\n\n\nBioSequences.neighbors\n \n \nFunction\n.\n\n\nneighbors(kmer::Kmer)\n\n\n\n\n\nReturn an iterator through k-mers neighboring \nkmer\n on a de Bruijn graph.\n\n\nsource", 
            "title": "Nucleic acid k-mers"
        }, 
        {
            "location": "/sequences/kmer/#nucleic-acid-k-mers", 
            "text": "A common strategy to simplify the analysis of sequence data is to operate or short k-mers, for size fixed size  k . These can be packed into machine integers allowing extremely efficient code. The  BioSequences  module has built in support for representing short sequences in 64-bit integers. Besides being fixed length,  Kmer  types, unlike other sequence types cannot contain ambiguous symbols like 'N'.  The  Kmer{T,k}  type parameterized on symbol type ( T , either  DNA , or  RNA ) and size  k . For ease of writing code, two type aliases for each nucleotide type are defined and named as  DNAKmer{k}  and  RNAKmer{k} :  julia  DNAKmer( ACGT )  # create a DNA 4-mer from a string\nDNA 4-mer:\nACGT\n\njulia  RNAKmer( ACGU )  # create an RNA 4-mer from a string\nRNA 4-mer:\nACGU\n\njulia  kmer ACGT  # DNA k-mers may also be written as literals\nDNA 4-mer:\nACGT\n\njulia  typeof(DNAKmer( ACGT ))\nBioSequences.Kmer{BioSymbols.DNA,4}  #  BioSequences.each     Function .  each(::Type{Kmer{T,k}}, seq::Sequence[, step=1])  Initialize an iterator over all k-mers in a sequence  seq  skipping ambiguous nucleotides without changing the reading frame.  Arguments   Kmer{T,k} : k-mer type to enumerate.  seq : a nucleotide sequence.  step=1 : the number of positions between iterated k-mers   Examples  # iterate over DNA codons\nfor (pos, codon) in each(DNAKmer{3}, dna ATCCTANAGNTACT , 3)\n    @show pos, codon\nend  source  #  BioSequences.canonical     Function .  canonical(kmer::Kmer)  Return the canonical k-mer of  x .  A canonical k-mer is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting k-mers in data that is not strand specific, and thus observing k-mer is equivalent to observing its reverse complement.  source  #  BioSequences.neighbors     Function .  neighbors(kmer::Kmer)  Return an iterator through k-mers neighboring  kmer  on a de Bruijn graph.  source", 
            "title": "Nucleic acid k-mers"
        }, 
        {
            "location": "/io/fasta/", 
            "text": "IO - FASTA formatted files\n\n\nFASTA is a text-based file format for representing biological sequences. A FASTA file stores a list of sequence records with name, description, and sequence.\n\n\nThe template of a sequence record is:\n\n\n{name} {description}?\n{sequence}\n\n\n\n\n\nHere is an example of a chromosomal sequence:\n\n\nchrI chromosome 1\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACC\nCACACACACACATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTG\n\n\n\n\n\n\n\nReaders and Writers\n\n\nThe reader and writer for FASTA formatted files, are found within the \nBioSequences.FASTA\n module.\n\n\n#\n\n\nBioSequences.FASTA.Reader\n \n \nType\n.\n\n\nFASTA\n.\nReader\n(\ninput\n::\nIO\n;\n \nindex\n=\nnothing\n)\n\n\n\n\n\n\nCreate a data reader of the FASTA file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\nindex=nothing\n: filepath to a random access index (currently \nfai\n is supported)\n\n\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTA.Writer\n \n \nType\n.\n\n\nFASTA\n.\nWriter\n(\noutput\n::\nIO\n;\n \nwidth\n=\n70\n)\n\n\n\n\n\n\nCreate a data writer of the FASTA file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nwidth=70\n: wrapping width of sequence characters\n\n\n\n\nsource\n\n\nThey can be created with IOStreams:\n\n\nr = FASTA.Reader(open(\nMyInput.fasta\n, \nr\n))\n\n\nw = FASTA.Writer(open(\nMyFile.fasta\n, \nw\n))\n\n\n\n\n\n\nUsually sequence records will be read sequentially from a file by iteration.\n\n\nusing BioSequences\n\n\nreader = FASTA.Reader(open(\nhg38.fa\n, \nr\n))\n\n\nfor record in reader\n\n\n    # Do something\n\n\nend\n\n\nclose(reader)\n\n\n\n\n\n\nBut if the FASTA file has an auxiliary index file formatted in fai, the reader supports random access to FASTA records, which would be useful when accessing specific parts of a huge genome sequence:\n\n\nreader = open(FASTAReader, \nsacCer.fa\n, index=\nsacCer.fa.fai\n)\n\n\nchrIV = reader[\nchrIV\n]  # directly read sequences called chrIV.\n\n\n\n\n\n\nReading in a sequence from a FASTA formatted file will give you a variable of type \nFASTA.Record\n.\n\n\n#\n\n\nBioSequences.FASTA.Record\n \n \nType\n.\n\n\nFASTA.Record()\n\n\n\n\n\nCreate an unfilled FASTA record.\n\n\nsource\n\n\nFASTA.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a FASTA record object from \ndata\n.\n\n\nThis function verifies and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record object.\n\n\nsource\n\n\nFASTA.Record(str::AbstractString)\n\n\n\n\n\nCreate a FASTA record object from \nstr\n.\n\n\nThis function verifies and indexes fields for accessors.\n\n\nsource\n\n\nFASTA.Record(identifier, sequence)\n\n\n\n\n\nCreate a FASTA record object from \nidentifier\n and \nsequence\n.\n\n\nsource\n\n\nFASTA.Record(identifier, description, sequence)\n\n\n\n\n\nCreate a FASTA record object from \nidentifier\n, \ndescription\n and \nsequence\n.\n\n\nsource\n\n\nVarious getters and setters are available for \nFASTA.Record\ns:\n\n\n#\n\n\nBioSequences.FASTA.hasidentifier\n \n \nFunction\n.\n\n\nhasidentifier(record::Record)\n\n\n\n\n\nChecks whether or not the \nrecord\n has an identifier.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTA.identifier\n \n \nFunction\n.\n\n\nidentifier(record::Record)::String\n\n\n\n\n\nGet the sequence identifier of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTA.hasdescription\n \n \nFunction\n.\n\n\nhasdescription(record::Record)\n\n\n\n\n\nChecks whether or not the \nrecord\n has a description.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTA.description\n \n \nFunction\n.\n\n\ndescription(record::Record)::String\n\n\n\n\n\nGet the description of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTA.hassequence\n \n \nFunction\n.\n\n\nhassequence(record::Record)\n\n\n\n\n\nChecks whether or not a sequence record contains a sequence.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTA.sequence\n \n \nMethod\n.\n\n\nsequence(record::Record, [part::UnitRange{Int}])\n\n\n\n\n\nGet the sequence of \nrecord\n.\n\n\nThis function infers the sequence type from the data. When it is wrong or unreliable, use \nsequence(::Type{S}, record::Record)\n.  If \npart\n argument is given, it returns the specified part of the sequence.\n\n\nsource\n\n\nTo write a \nBioSequence\n to FASTA file, you first have to create a \nFASTA.Record\n:\n\n\nusing BioSequences\n\n\nx = dna\naaaaatttttcccccggggg\n\n\nrec = FASTA.Record(\nMySeq\n, x)\n\n\nw = FASTA.Writer(open(\nMyFile.fasta\n, \nw\n))\n\n\nwrite(w, rec)\n\n\n\n\n\n\nAs always with julia IO types, remember to close your file readers and writer after you are finished.", 
            "title": "FASTA formatted files"
        }, 
        {
            "location": "/io/fasta/#io-fasta-formatted-files", 
            "text": "FASTA is a text-based file format for representing biological sequences. A FASTA file stores a list of sequence records with name, description, and sequence.  The template of a sequence record is:  {name} {description}?\n{sequence}  Here is an example of a chromosomal sequence:  chrI chromosome 1\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACC\nCACACACACACATCCTAACACTACCCTAACACAGCCCTAATCTAACCCTG", 
            "title": "IO - FASTA formatted files"
        }, 
        {
            "location": "/io/fasta/#readers-and-writers", 
            "text": "The reader and writer for FASTA formatted files, are found within the  BioSequences.FASTA  module.  #  BioSequences.FASTA.Reader     Type .  FASTA . Reader ( input :: IO ;   index = nothing )   Create a data reader of the FASTA file format.  Arguments   input : data source  index=nothing : filepath to a random access index (currently  fai  is supported)   source  #  BioSequences.FASTA.Writer     Type .  FASTA . Writer ( output :: IO ;   width = 70 )   Create a data writer of the FASTA file format.  Arguments   output : data sink  width=70 : wrapping width of sequence characters   source  They can be created with IOStreams:  r = FASTA.Reader(open( MyInput.fasta ,  r ))  w = FASTA.Writer(open( MyFile.fasta ,  w ))   Usually sequence records will be read sequentially from a file by iteration.  using BioSequences  reader = FASTA.Reader(open( hg38.fa ,  r ))  for record in reader      # Do something  end  close(reader)   But if the FASTA file has an auxiliary index file formatted in fai, the reader supports random access to FASTA records, which would be useful when accessing specific parts of a huge genome sequence:  reader = open(FASTAReader,  sacCer.fa , index= sacCer.fa.fai )  chrIV = reader[ chrIV ]  # directly read sequences called chrIV.   Reading in a sequence from a FASTA formatted file will give you a variable of type  FASTA.Record .  #  BioSequences.FASTA.Record     Type .  FASTA.Record()  Create an unfilled FASTA record.  source  FASTA.Record(data::Vector{UInt8})  Create a FASTA record object from  data .  This function verifies and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record object.  source  FASTA.Record(str::AbstractString)  Create a FASTA record object from  str .  This function verifies and indexes fields for accessors.  source  FASTA.Record(identifier, sequence)  Create a FASTA record object from  identifier  and  sequence .  source  FASTA.Record(identifier, description, sequence)  Create a FASTA record object from  identifier ,  description  and  sequence .  source  Various getters and setters are available for  FASTA.Record s:  #  BioSequences.FASTA.hasidentifier     Function .  hasidentifier(record::Record)  Checks whether or not the  record  has an identifier.  source  #  BioSequences.FASTA.identifier     Function .  identifier(record::Record)::String  Get the sequence identifier of  record .  source  #  BioSequences.FASTA.hasdescription     Function .  hasdescription(record::Record)  Checks whether or not the  record  has a description.  source  #  BioSequences.FASTA.description     Function .  description(record::Record)::String  Get the description of  record .  source  #  BioSequences.FASTA.hassequence     Function .  hassequence(record::Record)  Checks whether or not a sequence record contains a sequence.  source  #  BioSequences.FASTA.sequence     Method .  sequence(record::Record, [part::UnitRange{Int}])  Get the sequence of  record .  This function infers the sequence type from the data. When it is wrong or unreliable, use  sequence(::Type{S}, record::Record) .  If  part  argument is given, it returns the specified part of the sequence.  source  To write a  BioSequence  to FASTA file, you first have to create a  FASTA.Record :  using BioSequences  x = dna aaaaatttttcccccggggg  rec = FASTA.Record( MySeq , x)  w = FASTA.Writer(open( MyFile.fasta ,  w ))  write(w, rec)   As always with julia IO types, remember to close your file readers and writer after you are finished.", 
            "title": "Readers and Writers"
        }, 
        {
            "location": "/io/fastq/", 
            "text": "IO - FASTQ formatted files\n\n\nFASTQ is a text-based file format for representing DNA sequences along with qualities for each base. A FASTQ file stores a list of sequence records in the following format:\n\n\n@{name} {description}?\n{sequence}\n+\n{qualities}\n\n\n\n\n\nHere is an example of one record from a FASTQ file:\n\n\n@FSRRS4401BE7HA\ntcagTTAAGATGGGAT\n+\n###EEEEEEEEE##E#\n\n\n\n\n\n\n\nReaders and Writers\n\n\nThe reader and writer for FASTQ formatted files, are found within the \nBioSequences.FASTQ\n module.\n\n\n#\n\n\nBioSequences.FASTQ.Reader\n \n \nType\n.\n\n\nFASTQ\n.\nReader\n(\ninput\n::\nIO\n;\n \nfill_ambiguous\n=\nnothing\n)\n\n\n\n\n\n\nCreate a data reader of the FASTQ file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\nfill_ambiguous=nothing\n: fill ambiguous symbols with the given symbol\n\n\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTQ.Writer\n \n \nType\n.\n\n\nFASTQ\n.\nWriter\n(\noutput\n::\nIO\n;\n \nquality_header\n=\nfalse\n)\n\n\n\n\n\n\nCreate a data writer of the FASTQ file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nquality_header=false\n: output the title line at the third line just after '+'\n\n\n\n\nsource\n\n\nThey can be created with IOStreams:\n\n\nr = FASTQ.Reader(open(\nMyInput.fastq\n, \nr\n))\n\n\nw = FASTQ.Writer(open(\nMyFile.fastq\n, \nw\n))\n\n\n\n\n\n\nNote that \nFASTQ.Reader\n does not support line-wraps within sequence and quality. Usually sequence records will be read sequentially from a file by iteration.\n\n\nusing BioSequences\n\n\nreader = FASTQ.Reader(open(\nhg38.fastq\n, \nr\n))\n\n\nfor record in reader\n\n\n    # Do something\n\n\nend\n\n\nclose(reader)\n\n\n\n\n\n\nReading in a record from a FASTQ formatted file will give you a variable of type \nFASTQ.Record\n.\n\n\n#\n\n\nBioSequences.FASTQ.Record\n \n \nType\n.\n\n\nFASTQ.Record()\n\n\n\n\n\nCreate an unfilled FASTQ record.\n\n\nsource\n\n\nFASTQ.Record(data::Vector{UInt8})\n\n\n\n\n\nCreate a FASTQ record object from \ndata\n.\n\n\nThis function verifies and indexes fields for accessors. Note that the ownership of \ndata\n is transferred to a new record object.\n\n\nsource\n\n\nFASTQ.Record(str::AbstractString)\n\n\n\n\n\nCreate a FASTQ record object from \nstr\n.\n\n\nThis function verifies and indexes fields for accessors.\n\n\nsource\n\n\nFASTQ.Record(identifier, sequence, quality; offset=33)\n\n\n\n\n\nCreate a FASTQ record from \nidentifier\n, \nsequence\n and \nquality\n.\n\n\nsource\n\n\nFASTQ.Record(identifier, description, sequence, quality; offset=33)\n\n\n\n\n\nCreate a FASTQ record from \nidentifier\n, \ndescription\n, \nsequence\n and \nquality\n.\n\n\nsource\n\n\nVarious getters and setters are available for \nFASTQ.Record\ns:\n\n\n#\n\n\nBioSequences.FASTQ.hasidentifier\n \n \nFunction\n.\n\n\nhasidentifier(record::Record)\n\n\n\n\n\nChecks whether or not the \nrecord\n has an identifier.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTQ.identifier\n \n \nFunction\n.\n\n\nidentifier(record::Record)::String\n\n\n\n\n\nGet the sequence identifier of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTQ.hasdescription\n \n \nFunction\n.\n\n\nhasdescription(record::Record)\n\n\n\n\n\nChecks whether or not the \nrecord\n has a description.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTQ.description\n \n \nFunction\n.\n\n\ndescription(record::Record)::String\n\n\n\n\n\nGet the description of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTQ.hassequence\n \n \nFunction\n.\n\n\nhassequence(record::Record)\n\n\n\n\n\nChecks whether or not a sequence record contains a sequence.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTQ.sequence\n \n \nMethod\n.\n\n\nsequence(record::Record, [part::UnitRange{Int}])::BioSequences.DNASequence\n\n\n\n\n\nGet the sequence of \nrecord\n.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTQ.hasquality\n \n \nFunction\n.\n\n\nhasquality(record::Record)\n\n\n\n\n\nCheck whether the given FASTQ \nrecord\n has a quality string.\n\n\nsource\n\n\n#\n\n\nBioSequences.FASTQ.quality\n \n \nFunction\n.\n\n\nquality(record::Record, [offset::Integer=33, [part::UnitRange]])::Vector{UInt8}\n\n\n\n\n\nGet the base quality of \nrecord\n.\n\n\nsource\n\n\nquality(record::Record, encoding_name::Symbol, [part::UnitRange])::Vector{UInt8}\n\n\n\n\n\nGet the base quality of \nrecord\n by decoding with \nencoding_name\n.\n\n\nThe \nencoding_name\n can be either \n:sanger\n, \n:solexa\n, \n:illumina13\n, \n:illumina15\n, or \n:illumina18\n.\n\n\nsource\n\n\nTo write a \nBioSequence\n to FASTQ file, you first have to create a \nFASTQ.Record\n:\n\n\n#\n\n\nBioSequences.FASTQ.Record\n \n \nMethod\n.\n\n\nFASTQ.Record(identifier, description, sequence, quality; offset=33)\n\n\n\n\n\nCreate a FASTQ record from \nidentifier\n, \ndescription\n, \nsequence\n and \nquality\n.\n\n\nsource\n\n\nAs always with julia IO types, remember to close your file readers and writer after you are finished.", 
            "title": "FASTQ formatted files"
        }, 
        {
            "location": "/io/fastq/#io-fastq-formatted-files", 
            "text": "FASTQ is a text-based file format for representing DNA sequences along with qualities for each base. A FASTQ file stores a list of sequence records in the following format:  @{name} {description}?\n{sequence}\n+\n{qualities}  Here is an example of one record from a FASTQ file:  @FSRRS4401BE7HA\ntcagTTAAGATGGGAT\n+\n###EEEEEEEEE##E#", 
            "title": "IO - FASTQ formatted files"
        }, 
        {
            "location": "/io/fastq/#readers-and-writers", 
            "text": "The reader and writer for FASTQ formatted files, are found within the  BioSequences.FASTQ  module.  #  BioSequences.FASTQ.Reader     Type .  FASTQ . Reader ( input :: IO ;   fill_ambiguous = nothing )   Create a data reader of the FASTQ file format.  Arguments   input : data source  fill_ambiguous=nothing : fill ambiguous symbols with the given symbol   source  #  BioSequences.FASTQ.Writer     Type .  FASTQ . Writer ( output :: IO ;   quality_header = false )   Create a data writer of the FASTQ file format.  Arguments   output : data sink  quality_header=false : output the title line at the third line just after '+'   source  They can be created with IOStreams:  r = FASTQ.Reader(open( MyInput.fastq ,  r ))  w = FASTQ.Writer(open( MyFile.fastq ,  w ))   Note that  FASTQ.Reader  does not support line-wraps within sequence and quality. Usually sequence records will be read sequentially from a file by iteration.  using BioSequences  reader = FASTQ.Reader(open( hg38.fastq ,  r ))  for record in reader      # Do something  end  close(reader)   Reading in a record from a FASTQ formatted file will give you a variable of type  FASTQ.Record .  #  BioSequences.FASTQ.Record     Type .  FASTQ.Record()  Create an unfilled FASTQ record.  source  FASTQ.Record(data::Vector{UInt8})  Create a FASTQ record object from  data .  This function verifies and indexes fields for accessors. Note that the ownership of  data  is transferred to a new record object.  source  FASTQ.Record(str::AbstractString)  Create a FASTQ record object from  str .  This function verifies and indexes fields for accessors.  source  FASTQ.Record(identifier, sequence, quality; offset=33)  Create a FASTQ record from  identifier ,  sequence  and  quality .  source  FASTQ.Record(identifier, description, sequence, quality; offset=33)  Create a FASTQ record from  identifier ,  description ,  sequence  and  quality .  source  Various getters and setters are available for  FASTQ.Record s:  #  BioSequences.FASTQ.hasidentifier     Function .  hasidentifier(record::Record)  Checks whether or not the  record  has an identifier.  source  #  BioSequences.FASTQ.identifier     Function .  identifier(record::Record)::String  Get the sequence identifier of  record .  source  #  BioSequences.FASTQ.hasdescription     Function .  hasdescription(record::Record)  Checks whether or not the  record  has a description.  source  #  BioSequences.FASTQ.description     Function .  description(record::Record)::String  Get the description of  record .  source  #  BioSequences.FASTQ.hassequence     Function .  hassequence(record::Record)  Checks whether or not a sequence record contains a sequence.  source  #  BioSequences.FASTQ.sequence     Method .  sequence(record::Record, [part::UnitRange{Int}])::BioSequences.DNASequence  Get the sequence of  record .  source  #  BioSequences.FASTQ.hasquality     Function .  hasquality(record::Record)  Check whether the given FASTQ  record  has a quality string.  source  #  BioSequences.FASTQ.quality     Function .  quality(record::Record, [offset::Integer=33, [part::UnitRange]])::Vector{UInt8}  Get the base quality of  record .  source  quality(record::Record, encoding_name::Symbol, [part::UnitRange])::Vector{UInt8}  Get the base quality of  record  by decoding with  encoding_name .  The  encoding_name  can be either  :sanger ,  :solexa ,  :illumina13 ,  :illumina15 , or  :illumina18 .  source  To write a  BioSequence  to FASTQ file, you first have to create a  FASTQ.Record :  #  BioSequences.FASTQ.Record     Method .  FASTQ.Record(identifier, description, sequence, quality; offset=33)  Create a FASTQ record from  identifier ,  description ,  sequence  and  quality .  source  As always with julia IO types, remember to close your file readers and writer after you are finished.", 
            "title": "Readers and Writers"
        }, 
        {
            "location": "/io/twobit/", 
            "text": "IO - 2bit formatted files\n\n\n2bit is a binary file format designed for storing a genome consists of multiple chromosomal sequences. The reading speed is often an order of magnitude faster than that of FASTA and the file size is smaller. However, since the .2bit file format is specialized for genomic sequences, it cannot store either RNA or amino acid sequences.\n\n\n\n\nReaders and Writers\n\n\nThe reader and writer for 2bit formatted files, are found within the \nBioSequences.TwoBit\n module.\n\n\n#\n\n\nBioSequences.TwoBit.Reader\n \n \nType\n.\n\n\nTwoBit.Reader(input::IO)\n\n\n\n\n\nCreate a data reader of the 2bit file format.\n\n\nArguments\n\n\n\n\ninput\n: data source\n\n\n\n\nsource\n\n\n#\n\n\nBioSequences.TwoBit.Writer\n \n \nType\n.\n\n\nTwoBitWriter(output::IO, names::AbstractVector)\n\n\n\n\n\nCreate a data writer of the 2bit file format.\n\n\nArguments\n\n\n\n\noutput\n: data sink\n\n\nnames\n: a vector of sequence names written to \noutput\n\n\n\n\nsource\n\n\nThe 2bit reader supports random access using an index included in the header section of a .2bit file:\n\n\nreader = TwoBit.Reader(open(\nsacCer.2bit\n, \nr\n))\n\n\nchrIV = reader[\nchrIV\n] # directly read chromosome 4\n\n\n\n\n\n\nIf you want to know the names of the sequences available in the file, you can use the \nseqnames\n method on the reader.\n\n\nseqnames(reader)\n\n\n\n\n\n\nReading from a \nTwoBit.Reader\n will yield a \nTwoBit.Record\n type variable:\n\n\n#\n\n\nBioSequences.TwoBit.Record\n \n \nType\n.\n\n\nTwoBit.Record()\n\n\n\n\n\nCreate an unfilled 2bit record.\n\n\nsource\n\n\nRecord()\n\n\n\n\n\nPrepare a record for writing to a 2bit formatted file.\n\n\nNeeds a \nname\n, a \nsequence\n, and (optionally) \nmasks\n: a vector of ranges that delineate masked regions of sequence.\n\n\nsource\n\n\nTo write a sequence to a TwoBit file, first a record must be created.\n\n\n#\n\n\nBioSequences.TwoBit.Record\n \n \nType\n.\n\n\nRecord()\n\n\n\n\n\nPrepare a record for writing to a 2bit formatted file.\n\n\nNeeds a \nname\n, a \nsequence\n, and (optionally) \nmasks\n: a vector of ranges that delineate masked regions of sequence.\n\n\nsource", 
            "title": "2bit formatted files"
        }, 
        {
            "location": "/io/twobit/#io-2bit-formatted-files", 
            "text": "2bit is a binary file format designed for storing a genome consists of multiple chromosomal sequences. The reading speed is often an order of magnitude faster than that of FASTA and the file size is smaller. However, since the .2bit file format is specialized for genomic sequences, it cannot store either RNA or amino acid sequences.", 
            "title": "IO - 2bit formatted files"
        }, 
        {
            "location": "/io/twobit/#readers-and-writers", 
            "text": "The reader and writer for 2bit formatted files, are found within the  BioSequences.TwoBit  module.  #  BioSequences.TwoBit.Reader     Type .  TwoBit.Reader(input::IO)  Create a data reader of the 2bit file format.  Arguments   input : data source   source  #  BioSequences.TwoBit.Writer     Type .  TwoBitWriter(output::IO, names::AbstractVector)  Create a data writer of the 2bit file format.  Arguments   output : data sink  names : a vector of sequence names written to  output   source  The 2bit reader supports random access using an index included in the header section of a .2bit file:  reader = TwoBit.Reader(open( sacCer.2bit ,  r ))  chrIV = reader[ chrIV ] # directly read chromosome 4   If you want to know the names of the sequences available in the file, you can use the  seqnames  method on the reader.  seqnames(reader)   Reading from a  TwoBit.Reader  will yield a  TwoBit.Record  type variable:  #  BioSequences.TwoBit.Record     Type .  TwoBit.Record()  Create an unfilled 2bit record.  source  Record()  Prepare a record for writing to a 2bit formatted file.  Needs a  name , a  sequence , and (optionally)  masks : a vector of ranges that delineate masked regions of sequence.  source  To write a sequence to a TwoBit file, first a record must be created.  #  BioSequences.TwoBit.Record     Type .  Record()  Prepare a record for writing to a 2bit formatted file.  Needs a  name , a  sequence , and (optionally)  masks : a vector of ranges that delineate masked regions of sequence.  source", 
            "title": "Readers and Writers"
        }, 
        {
            "location": "/search/", 
            "text": "Sequence search\n\n\nThree kinds of on-line search functions are provided:\n\n\n\n\nExact search\n\n\nApproximate search\n\n\nRegular expression search\n\n\n\n\nThese are all specialized for biological sequences and ambiguities of symbols are considered.\n\n\n\n\nExact search\n\n\nExact search functions search for an occurrence of the query symbol or sequence. Four functions, \nsearch\n, \nsearchindex\n, \nrsearch\n, and \nrsearchindex\n are available:\n\n\njulia\n seq = dna\nACAGCGTAGCT\n;\n\njulia\n search(seq, DNA_G)  # search a query symbol\n4:4\n\njulia\n query = dna\nAGC\n;\n\njulia\n search(seq, query)  # search a query sequence\n3:5\n\njulia\n searchindex(seq, query)\n3\n\njulia\n rsearch(seq, query)  # similar to `search` but in the reverse direction\n8:10\n\njulia\n rsearchindex(seq, query)  # similar to `searchindex` but in the reverse direction\n8\n\n\n\n\n\nThese search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g. \nDNA_A\n and \nDNA_N\n), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols:\n\n\njulia\n search(dna\nACNT\n, DNA_N)  # \nA\n matches \nN\n\n1:1\n\njulia\n search(dna\nACNT\n, dna\nCGT\n)  # \nN\n matches \nG\n\n2:4\n\njulia\n search(dna\nACGT\n, dna\nCNT\n)  # \nG\n matches \nN\n\n2:4\n\n\n\n\n\nThe exact sequence search needs preprocessing phase of query sequence before searching phase. This would be enough fast for most search applications. But when searching a query sequence to large amounts of target sequences, caching the result of preprocessing may save time. The \nExactSearchQuery\n creates such a preprocessed query object and is applicable to the search functions:\n\n\njulia\n query = ExactSearchQuery(dna\nATT\n);\n\njulia\n search(dna\nATTTATT\n, query)\n1:3\n\njulia\n rsearch(dna\nATTTATT\n, query)\n5:7\n\n\n\n\n\n\n\nApproximate search\n\n\nThe approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific \nLevenshtein distance\n of the query sequence:\n\n\njulia\n \nseq\n \n=\n \ndna\nACAGCGTAGCT\n;\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n0\n)\n  \n#\n \nnothing\n \nmatches\n \nwith\n \nno\n \nerrors\n\n\n0\n:-\n1\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n1\n)\n  \n#\n \nseq\n[\n3\n:\n5\n]\n \nmatches\n \nwith\n \none\n \nerror\n\n\n3\n:\n6\n\n\n\njulia\n \napproxsearch\n(\nseq\n,\n \ndna\nAGGG\n,\n \n2\n)\n  \n#\n \nseq\n[\n1\n:\n4\n]\n \nmatches\n \nwith\n \ntwo\n \nerrors\n\n\n1\n:\n4\n\n\n\n\n\n\nLike the exact search functions, four kinds of functions (\napproxsearch\n, \napproxsearchindex\n, \napproxrsearch\n, and \napproxrsearchindex\n) are available:\n\n\njulia\n seq = dna\nACAGCGTAGCT\n; pat = dna\nAGGG\n;\n\njulia\n approxsearch(seq, pat, 2)        # return the range (forward)\n1:4\n\njulia\n approxsearchindex(seq, pat, 2)   # return the starting index (forward)\n1\n\njulia\n approxrsearch(seq, pat, 2)       # return the range (backward)\n8:11\n\njulia\n approxrsearchindex(seq, pat, 2)  # return the starting index (backward)\n8\n\n\n\n\n\nPreprocessing can be cached in an \nApproximateSearchQuery\n object:\n\n\njulia\n query = ApproximateSearchQuery(dna\nAGGG\n);\n\njulia\n approxsearch(dna\nAAGAGG\n, query, 1)\n2:5\n\njulia\n approxsearch(dna\nACTACGT\n, query, 2)\n4:6\n\n\n\n\n\n\n\nRegular expression search\n\n\nQuery patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.\n\n\nThe Perl-like syntax starts with \nbiore\n (\nbio\nlogical \nre\ngular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example, \nbiore\"A+\"dna\n is a regular expression for DNA sequences and \nbiore\"A+\"aa\n is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.\n\n\nHere are examples of using the regular expression for \nBioSequence\ns:\n\n\njulia\n match(biore\nA+C*\ndna, dna\nAAAACC\n)\nNullable{BioSequences.RE.RegexMatch{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}}}}(RegexMatch(\nAAAACC\n))\n\njulia\n match(biore\nA+C*\nd, dna\nAAAACC\n)\nNullable{BioSequences.RE.RegexMatch{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}}}}(RegexMatch(\nAAAACC\n))\n\njulia\n ismatch(biore\nA+C*\ndna, dna\nAAC\n)\ntrue\n\njulia\n ismatch(biore\nA+C*\ndna, dna\nC\n)\nfalse\n\n\n\n\n\nmatch\n always returns a \nNullable\n object and it should be null if no match is found.\n\n\nThe table below summarizes available syntax elements.\n\n\n\n\n\n\n\n\nSyntax\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\n\\|\n\n\nalternation\n\n\n\"A\\|T\"\n matches \n\"A\"\n and \n\"T\"\n\n\n\n\n\n\n*\n\n\nzero or more times repeat\n\n\n\"TA*\"\n matches \n\"T\"\n, \n\"TA\"\n and \n\"TAA\"\n\n\n\n\n\n\n+\n\n\none or more times repeat\n\n\n\"TA+\"\n matches \n\"TA\"\n and \n\"TAA\"\n\n\n\n\n\n\n?\n\n\nzero or one time\n\n\n\"TA?\"\n matches \n\"T\"\n and \n\"TA\"\n\n\n\n\n\n\n{n,}\n\n\nn\n or more times repeat\n\n\n\"A{3,}\"\n matches \n\"AAA\"\n and \n\"AAAA\"\n\n\n\n\n\n\n{n,m}\n\n\nn\n-\nm\n times repeat\n\n\n\"A{3,5}\"\n matches \n\"AAA\"\n, \n\"AAAA\"\n and \n\"AAAAA\"\n\n\n\n\n\n\n^\n\n\nthe start of the sequence\n\n\n\"^TAN*\"\n matches \n\"TATGT\"\n\n\n\n\n\n\n$\n\n\nthe end of the sequence\n\n\n\"N*TA$\"\n matches \n\"GCTA\"\n\n\n\n\n\n\n(...)\n\n\npattern grouping\n\n\n\"(TA)+\"\n matches \n\"TA\"\n and \n\"TATA\"\n\n\n\n\n\n\n[...]\n\n\none of symbols\n\n\n\"[ACG]+\"\n matches \n\"AGGC\"\n\n\n\n\n\n\n\n\neachmatch\n, \nmatchall\n, and \nsearch\n are also defined like usual strings:\n\n\njulia\n matchall(biore\nTATA*?\nd, dna\nTATTATAATTA\n)  # overlap (default)\n4-element Array{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}},1}:\n TAT  \n TAT  \n TATA\n TATAA\n\njulia\n matchall(biore\nTATA*\nd, dna\nTATTATAATTA\n, false)  # no overlap\n2-element Array{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}},1}:\n TAT  \n TATAA\n\njulia\n search(dna\nTATTATAATTA\n, biore\nTATA*\nd)\n1:3\n\njulia\n search(dna\nTATTATAATTA\n, biore\nTATA*\nd, 2)\n4:8\n\n\n\n\n\nNotewothy differences from strings are:\n\n\n\n\nAmbiguous characters match any compatible characters (e.g. \nbiore\"N\"d\n is equivalent to \nbiore\"[ACGT]\"d\n).\n\n\nWhitespaces are ignored (e.g. \nbiore\"A C G\"d\n is equivalent to \nbiore\"ACG\"d\n).\n\n\n\n\nThe PROSITE notation is described in \nScanProsite - user manual\n. The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with \nprosite\n prefix and no symbol option is needed because it always describes patterns of amino acid sequences:\n\n\njulia\n match(prosite\n[AC]-x-V-x(4)-{ED}\n, aa\nCPVPQARG\n)\nNullable{BioSequences.RE.RegexMatch{BioSequences.BioSequence{BioSequences.AminoAcidAlphabet}}}(RegexMatch(\nCPVPQARG\n))\n\njulia\n match(prosite\n[AC]xVx(4){ED}\n, aa\nCPVPQARG\n)\nNullable{BioSequences.RE.RegexMatch{BioSequences.BioSequence{BioSequences.AminoAcidAlphabet}}}(RegexMatch(\nCPVPQARG\n))\n\n\n\n\n\n\n\nSequence composition\n\n\nSequence composition can be easily calculated using the \ncomposition\n function:\n\n\njulia\n comp = composition(dna\nACGAG\n)\nDNA Composition:\n  DNA_A =\n 2\n  DNA_G =\n 2\n  DNA_C =\n 1\n\njulia\n comp[DNA_A]\n2\n\njulia\n comp[DNA_T]\n0\n\n\n\n\n\nTo accumulate composition statistics of multiple sequences, \nmerge!\n can be used as follows:\n\n\njulia\n # initiaize an empty composition counter\n       comp = composition(dna\n);\nERROR: UndefVarError: @dna_str not defined\n\njulia\n # iterate over sequences and accumulate composition statistics into `comp`\n       for seq in seqs\n           merge!(comp, composition(seq))\n       end\nERROR: UndefVarError: seqs not defined\n\njulia\n # or functional programming style in one line\n       foldl((x, y) -\n merge(x, composition(y)), composition(dna\n), seqs)\nERROR: UndefVarError: @dna_str not defined\n\n\n\n\n\ncomposition\n is also applicable to a \nk\n-mer iterator:\n\n\njulia\n comp = composition(each(DNAKmer{4}, dna\nACGT\n^100));\n\njulia\n comp[DNAKmer(\nACGT\n)]\n100\n\njulia\n comp[DNAKmer(\nCGTA\n)]\n99", 
            "title": "Searching"
        }, 
        {
            "location": "/search/#sequence-search", 
            "text": "Three kinds of on-line search functions are provided:   Exact search  Approximate search  Regular expression search   These are all specialized for biological sequences and ambiguities of symbols are considered.", 
            "title": "Sequence search"
        }, 
        {
            "location": "/search/#exact-search", 
            "text": "Exact search functions search for an occurrence of the query symbol or sequence. Four functions,  search ,  searchindex ,  rsearch , and  rsearchindex  are available:  julia  seq = dna ACAGCGTAGCT ;\n\njulia  search(seq, DNA_G)  # search a query symbol\n4:4\n\njulia  query = dna AGC ;\n\njulia  search(seq, query)  # search a query sequence\n3:5\n\njulia  searchindex(seq, query)\n3\n\njulia  rsearch(seq, query)  # similar to `search` but in the reverse direction\n8:10\n\njulia  rsearchindex(seq, query)  # similar to `searchindex` but in the reverse direction\n8  These search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g.  DNA_A  and  DNA_N ), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols:  julia  search(dna ACNT , DNA_N)  #  A  matches  N \n1:1\n\njulia  search(dna ACNT , dna CGT )  #  N  matches  G \n2:4\n\njulia  search(dna ACGT , dna CNT )  #  G  matches  N \n2:4  The exact sequence search needs preprocessing phase of query sequence before searching phase. This would be enough fast for most search applications. But when searching a query sequence to large amounts of target sequences, caching the result of preprocessing may save time. The  ExactSearchQuery  creates such a preprocessed query object and is applicable to the search functions:  julia  query = ExactSearchQuery(dna ATT );\n\njulia  search(dna ATTTATT , query)\n1:3\n\njulia  rsearch(dna ATTTATT , query)\n5:7", 
            "title": "Exact search"
        }, 
        {
            "location": "/search/#approximate-search", 
            "text": "The approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific  Levenshtein distance  of the query sequence:  julia   seq   =   dna ACAGCGTAGCT ;  julia   approxsearch ( seq ,   dna AGGG ,   0 )    #   nothing   matches   with   no   errors  0 :- 1  julia   approxsearch ( seq ,   dna AGGG ,   1 )    #   seq [ 3 : 5 ]   matches   with   one   error  3 : 6  julia   approxsearch ( seq ,   dna AGGG ,   2 )    #   seq [ 1 : 4 ]   matches   with   two   errors  1 : 4   Like the exact search functions, four kinds of functions ( approxsearch ,  approxsearchindex ,  approxrsearch , and  approxrsearchindex ) are available:  julia  seq = dna ACAGCGTAGCT ; pat = dna AGGG ;\n\njulia  approxsearch(seq, pat, 2)        # return the range (forward)\n1:4\n\njulia  approxsearchindex(seq, pat, 2)   # return the starting index (forward)\n1\n\njulia  approxrsearch(seq, pat, 2)       # return the range (backward)\n8:11\n\njulia  approxrsearchindex(seq, pat, 2)  # return the starting index (backward)\n8  Preprocessing can be cached in an  ApproximateSearchQuery  object:  julia  query = ApproximateSearchQuery(dna AGGG );\n\njulia  approxsearch(dna AAGAGG , query, 1)\n2:5\n\njulia  approxsearch(dna ACTACGT , query, 2)\n4:6", 
            "title": "Approximate search"
        }, 
        {
            "location": "/search/#regular-expression-search", 
            "text": "Query patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.  The Perl-like syntax starts with  biore  ( bio logical  re gular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example,  biore\"A+\"dna  is a regular expression for DNA sequences and  biore\"A+\"aa  is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.  Here are examples of using the regular expression for  BioSequence s:  julia  match(biore A+C* dna, dna AAAACC )\nNullable{BioSequences.RE.RegexMatch{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}}}}(RegexMatch( AAAACC ))\n\njulia  match(biore A+C* d, dna AAAACC )\nNullable{BioSequences.RE.RegexMatch{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}}}}(RegexMatch( AAAACC ))\n\njulia  ismatch(biore A+C* dna, dna AAC )\ntrue\n\njulia  ismatch(biore A+C* dna, dna C )\nfalse  match  always returns a  Nullable  object and it should be null if no match is found.  The table below summarizes available syntax elements.     Syntax  Description  Example      \\|  alternation  \"A\\|T\"  matches  \"A\"  and  \"T\"    *  zero or more times repeat  \"TA*\"  matches  \"T\" ,  \"TA\"  and  \"TAA\"    +  one or more times repeat  \"TA+\"  matches  \"TA\"  and  \"TAA\"    ?  zero or one time  \"TA?\"  matches  \"T\"  and  \"TA\"    {n,}  n  or more times repeat  \"A{3,}\"  matches  \"AAA\"  and  \"AAAA\"    {n,m}  n - m  times repeat  \"A{3,5}\"  matches  \"AAA\" ,  \"AAAA\"  and  \"AAAAA\"    ^  the start of the sequence  \"^TAN*\"  matches  \"TATGT\"    $  the end of the sequence  \"N*TA$\"  matches  \"GCTA\"    (...)  pattern grouping  \"(TA)+\"  matches  \"TA\"  and  \"TATA\"    [...]  one of symbols  \"[ACG]+\"  matches  \"AGGC\"     eachmatch ,  matchall , and  search  are also defined like usual strings:  julia  matchall(biore TATA*? d, dna TATTATAATTA )  # overlap (default)\n4-element Array{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}},1}:\n TAT  \n TAT  \n TATA\n TATAA\n\njulia  matchall(biore TATA* d, dna TATTATAATTA , false)  # no overlap\n2-element Array{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}},1}:\n TAT  \n TATAA\n\njulia  search(dna TATTATAATTA , biore TATA* d)\n1:3\n\njulia  search(dna TATTATAATTA , biore TATA* d, 2)\n4:8  Notewothy differences from strings are:   Ambiguous characters match any compatible characters (e.g.  biore\"N\"d  is equivalent to  biore\"[ACGT]\"d ).  Whitespaces are ignored (e.g.  biore\"A C G\"d  is equivalent to  biore\"ACG\"d ).   The PROSITE notation is described in  ScanProsite - user manual . The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with  prosite  prefix and no symbol option is needed because it always describes patterns of amino acid sequences:  julia  match(prosite [AC]-x-V-x(4)-{ED} , aa CPVPQARG )\nNullable{BioSequences.RE.RegexMatch{BioSequences.BioSequence{BioSequences.AminoAcidAlphabet}}}(RegexMatch( CPVPQARG ))\n\njulia  match(prosite [AC]xVx(4){ED} , aa CPVPQARG )\nNullable{BioSequences.RE.RegexMatch{BioSequences.BioSequence{BioSequences.AminoAcidAlphabet}}}(RegexMatch( CPVPQARG ))", 
            "title": "Regular expression search"
        }, 
        {
            "location": "/search/#sequence-composition", 
            "text": "Sequence composition can be easily calculated using the  composition  function:  julia  comp = composition(dna ACGAG )\nDNA Composition:\n  DNA_A =  2\n  DNA_G =  2\n  DNA_C =  1\n\njulia  comp[DNA_A]\n2\n\njulia  comp[DNA_T]\n0  To accumulate composition statistics of multiple sequences,  merge!  can be used as follows:  julia  # initiaize an empty composition counter\n       comp = composition(dna );\nERROR: UndefVarError: @dna_str not defined\n\njulia  # iterate over sequences and accumulate composition statistics into `comp`\n       for seq in seqs\n           merge!(comp, composition(seq))\n       end\nERROR: UndefVarError: seqs not defined\n\njulia  # or functional programming style in one line\n       foldl((x, y) -  merge(x, composition(y)), composition(dna ), seqs)\nERROR: UndefVarError: @dna_str not defined  composition  is also applicable to a  k -mer iterator:  julia  comp = composition(each(DNAKmer{4}, dna ACGT ^100));\n\njulia  comp[DNAKmer( ACGT )]\n100\n\njulia  comp[DNAKmer( CGTA )]\n99", 
            "title": "Sequence composition"
        }, 
        {
            "location": "/demultiplexer/", 
            "text": "Sequence demultiplexing\n\n\nMultiplex sequencing is a technology to sequence multiple samples at the same time on a high-throughput DNA sequencer. Samples are distinguished by the short prefix of a DNA sequence called DNA barcode. The \nBioSequences\n offers the \nDemultiplexer\n type and the \ndemultiplex\n function to identify the DNA barcode of a longer DNA sequence allowing small errors.\n\n\nIn the following example, four kinds of DNA sequences of length 4 are used as DNA barcodes. \nDemultiplexer\n takes these barcodes as its first argument with a few options:\n\n\njulia\n barcodes = DNASequence[\nATGG\n, \nCAGA\n, \nGGAA\n, \nTACG\n];\n\njulia\n dplxr = Demultiplexer(barcodes, n_max_errors=1, distance=:hamming)\nBioSequences.Demultiplexer{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}}}:\n  distance: hamming\n  number of barcodes: 4\n  number of correctable errors: 1\n\n\n\n\n\nn_max_errors\n specifies the number of maximum correctable errors in a barcode. The type of correctable errors depends on the \ndistance\n parameter. When \ndistance = :hamming\n as shown above only substitutions are correctable. When \ndistance = :levenshtein\n substitutions, deletions, and insertions are correctable. The user is responsible for keeping enough distances among barcodes; \nDemultiplexer\n will throw an exception if two barcodes are within \nn_max_errors * 2\n.\n\n\nThe \ndemultiplex\n function takes a demultiplexer object and a DNA sequence, and returns a tuple of a barcode index and a distance between the original barcode sequence and the prefix sequence:\n\n\njulia\n demultiplex(dplxr, dna\nATGGCGNT\n)  # 1st barcode with no errors\n(1, 0)\n\njulia\n demultiplex(dplxr, dna\nCAGGCGNT\n)  # 2nd barcode with one error\n(2, 1)\n\njulia\n demultiplex(dplxr, dna\nGGAACGNT\n)  # 3rd barcode with no errors\n(3, 0)\n\njulia\n demultiplex(dplxr, dna\nTGACCGNT\n)  # no matching barcode\n(0, -1)\n\n\n\n\n\nThe optional third argument controls the search strategy. \ndemultiplex\n uses an index to search the closest barcode within \nn_max_errors\n in the barcode set and returns it if any by default. If the third argument is \ntrue\n it falls back to a linear search after the index search and returns one of the closest barcodes at random. The next example shows the difference of these two strategies:\n\n\njulia\n demultiplex(dplxr, dna\nTGACCGNT\n, false)  # linear search off (default)\n(0, -1)\n\njulia\n demultiplex(dplxr, dna\nTGACCGNT\n, true)   # linear search on\n(3, 2)", 
            "title": "Demultiplexing"
        }, 
        {
            "location": "/demultiplexer/#sequence-demultiplexing", 
            "text": "Multiplex sequencing is a technology to sequence multiple samples at the same time on a high-throughput DNA sequencer. Samples are distinguished by the short prefix of a DNA sequence called DNA barcode. The  BioSequences  offers the  Demultiplexer  type and the  demultiplex  function to identify the DNA barcode of a longer DNA sequence allowing small errors.  In the following example, four kinds of DNA sequences of length 4 are used as DNA barcodes.  Demultiplexer  takes these barcodes as its first argument with a few options:  julia  barcodes = DNASequence[ ATGG ,  CAGA ,  GGAA ,  TACG ];\n\njulia  dplxr = Demultiplexer(barcodes, n_max_errors=1, distance=:hamming)\nBioSequences.Demultiplexer{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}}}:\n  distance: hamming\n  number of barcodes: 4\n  number of correctable errors: 1  n_max_errors  specifies the number of maximum correctable errors in a barcode. The type of correctable errors depends on the  distance  parameter. When  distance = :hamming  as shown above only substitutions are correctable. When  distance = :levenshtein  substitutions, deletions, and insertions are correctable. The user is responsible for keeping enough distances among barcodes;  Demultiplexer  will throw an exception if two barcodes are within  n_max_errors * 2 .  The  demultiplex  function takes a demultiplexer object and a DNA sequence, and returns a tuple of a barcode index and a distance between the original barcode sequence and the prefix sequence:  julia  demultiplex(dplxr, dna ATGGCGNT )  # 1st barcode with no errors\n(1, 0)\n\njulia  demultiplex(dplxr, dna CAGGCGNT )  # 2nd barcode with one error\n(2, 1)\n\njulia  demultiplex(dplxr, dna GGAACGNT )  # 3rd barcode with no errors\n(3, 0)\n\njulia  demultiplex(dplxr, dna TGACCGNT )  # no matching barcode\n(0, -1)  The optional third argument controls the search strategy.  demultiplex  uses an index to search the closest barcode within  n_max_errors  in the barcode set and returns it if any by default. If the third argument is  true  it falls back to a linear search after the index search and returns one of the closest barcodes at random. The next example shows the difference of these two strategies:  julia  demultiplex(dplxr, dna TGACCGNT , false)  # linear search off (default)\n(0, -1)\n\njulia  demultiplex(dplxr, dna TGACCGNT , true)   # linear search on\n(3, 2)", 
            "title": "Sequence demultiplexing"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing\n\n\nWe appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.\n\n\nIf you have a question about contributing or using this package, you are encouraged to use the \nBio category of the Julia discourse site\n.\n\n\nDetailed guidance for contributing to all BioJulia packages is provided at the \nBioJulia Contribution Documentation\n.\n\n\nHere we list specific details about contributing and maintainership pertaining specifically to the BioSequences.jl package.\n\n\n\n\nNamed maintainers\n\n\nThe named maintainers of this package are Kenta Sato and Ben Ward. It is their responsibility to make final choices about pull requests and issues, although because of our community structure, you will find other maintainers assisting them.\n\n\n\n\nBranching model\n\n\nThe branching model used to develop and make releases of this package is the \nOneFlow\n model summarized in the \nBioJulia Contribution Documentation", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contributing", 
            "text": "We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.  If you have a question about contributing or using this package, you are encouraged to use the  Bio category of the Julia discourse site .  Detailed guidance for contributing to all BioJulia packages is provided at the  BioJulia Contribution Documentation .  Here we list specific details about contributing and maintainership pertaining specifically to the BioSequences.jl package.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#named-maintainers", 
            "text": "The named maintainers of this package are Kenta Sato and Ben Ward. It is their responsibility to make final choices about pull requests and issues, although because of our community structure, you will find other maintainers assisting them.", 
            "title": "Named maintainers"
        }, 
        {
            "location": "/contributing/#branching-model", 
            "text": "The branching model used to develop and make releases of this package is the  OneFlow  model summarized in the  BioJulia Contribution Documentation", 
            "title": "Branching model"
        }
    ]
}