var documenterSearchIndex = {"docs":
[{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"symbols/#Biological-symbols-1","page":"Biological Symbols","title":"Biological symbols","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"The BioSequences module reexports the biological symbol (character) types that are provided by BioSymbols.jl:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Type Meaning\nDNA DNA nucleotide\nRNA RNA nucleotide\nAminoAcid Amino acid","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"These symbols are elements of biological sequences, just as characters are elements of strings. See sections beginning from Sequence Types section for details.","category":"page"},{"location":"symbols/#DNA-and-RNA-nucleotides-1","page":"Biological Symbols","title":"DNA and RNA nucleotides","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Set of nucleotide symbols in BioSequences covers IUPAC nucleotide base plus a gap symbol:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbol Constant Meaning\n'A' DNA_A / RNA_A A; Adenine\n'C' DNA_C / RNA_C C; Cytosine\n'G' DNA_G / RNA_G G; Guanine\n'T' DNA_T T; Thymine (DNA only)\n'U' RNA_U U; Uracil (RNA only)\n'M' DNA_M / RNA_M A or C\n'R' DNA_R / RNA_R A or G\n'W' DNA_W / RNA_W A or T/U\n'S' DNA_S / RNA_S C or G\n'Y' DNA_Y / RNA_Y C or T/U\n'K' DNA_K / RNA_K G or T/U\n'V' DNA_V / RNA_V A or C or G; not T/U\n'H' DNA_H / RNA_H A or C or T; not G\n'D' DNA_D / RNA_D A or G or T/U; not C\n'B' DNA_B / RNA_B C or G or T/U; not A\n'N' DNA_N / RNA_N A or C or G or T/U\n'-' DNA_Gap / RNA_Gap Gap (none of the above)","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"https://www.bioinformatics.org/sms/iupac.html","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols are accessible as constants with DNA_ or RNA_ prefix:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> DNA_A\nDNA_A\n\njulia> DNA_T\nDNA_T\n\njulia> RNA_U\nRNA_U\n\njulia> DNA_Gap\nDNA_Gap\n\njulia> typeof(DNA_A)\nDNA\n\njulia> typeof(RNA_A)\nRNA\n","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols can be constructed by converting regular characters:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> convert(DNA, 'C')\nDNA_C\n\njulia> convert(DNA, 'C') === DNA_C\ntrue\n","category":"page"},{"location":"symbols/#Amino-acids-1","page":"Biological Symbols","title":"Amino acids","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Set of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbol Constant Meaning\n'A' AA_A Alanine\n'R' AA_R Arginine\n'N' AA_N Asparagine\n'D' AA_D Aspartic acid (Aspartate)\n'C' AA_C Cysteine\n'Q' AA_Q Glutamine\n'E' AA_E Glutamic acid (Glutamate)\n'G' AA_G Glycine\n'H' AA_H Histidine\n'I' AA_I Isoleucine\n'L' AA_L Leucine\n'K' AA_K Lysine\n'M' AA_M Methionine\n'F' AA_F Phenylalanine\n'P' AA_P Proline\n'S' AA_S Serine\n'T' AA_T Threonine\n'W' AA_W Tryptophan\n'Y' AA_Y Tyrosine\n'V' AA_V Valine\n'O' AA_O Pyrrolysine\n'U' AA_U Selenocysteine\n'B' AA_B Aspartic acid or Asparagine\n'J' AA_J Leucine or Isoleucine\n'Z' AA_Z Glutamine or Glutamic acid\n'X' AA_X Any amino acid\n'*' AA_Term Termination codon\n'-' AA_Gap Gap (none of the above)","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"https://www.bioinformatics.org/sms/iupac.html","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols are accessible as constants with AA_ prefix:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> AA_A\nAA_A\n\njulia> AA_Q\nAA_Q\n\njulia> AA_Term\nAA_Term\n\njulia> typeof(AA_A)\nAminoAcid\n","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols can be constructed by converting regular characters:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> convert(AminoAcid, 'A')\nAA_A\n\njulia> convert(AminoAcid, 'P') === AA_P\ntrue\n","category":"page"},{"location":"symbols/#Other-functions-1","page":"Biological Symbols","title":"Other functions","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"alphabet\ngap\niscompatible\nisambiguous","category":"page"},{"location":"symbols/#BioSymbols.alphabet","page":"Biological Symbols","title":"BioSymbols.alphabet","text":"alphabet(DNA)\n\nGet all symbols of DNA in sorted order.\n\nExamples\n\njulia> alphabet(DNA)\n(DNA_Gap, DNA_A, DNA_C, DNA_M, DNA_G, DNA_R, DNA_S, DNA_V, DNA_T, DNA_W, DNA_Y, DNA_H, DNA_K, DNA_D, DNA_B, DNA_N)\n\njulia> issorted(alphabet(DNA))\ntrue\n\n\n\n\n\n\nalphabet(RNA)\n\nGet all symbols of RNA in sorted order.\n\nExamples\n\njulia> alphabet(RNA)\n(RNA_Gap, RNA_A, RNA_C, RNA_M, RNA_G, RNA_R, RNA_S, RNA_V, RNA_U, RNA_W, RNA_Y, RNA_H, RNA_K, RNA_D, RNA_B, RNA_N)\n\njulia> issorted(alphabet(RNA))\ntrue\n\n\n\n\n\n\nalphabet(AminoAcid)\n\nGet all symbols of AminoAcid in sorted order.\n\nExamples\n\njulia> alphabet(AminoAcid)\n(AA_A, AA_R, AA_N, AA_D, AA_C, AA_Q, AA_E, AA_G, AA_H, AA_I, AA_L, AA_K, AA_M, AA_F, AA_P, AA_S, AA_T, AA_W, AA_Y, AA_V, AA_O, AA_U, AA_B, AA_J, AA_Z, AA_X, AA_Term, AA_Gap)\n\njulia> issorted(alphabet(AminoAcid))\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.gap","page":"Biological Symbols","title":"BioSymbols.gap","text":"gap(DNA)\n\nReturn DNA_Gap.\n\n\n\n\n\ngap(RNA)\n\nReturn RNA_Gap.\n\n\n\n\n\ngap(AminoAcid)\n\nReturn AA_Gap.\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.iscompatible","page":"Biological Symbols","title":"BioSymbols.iscompatible","text":"iscompatible(x::S, y::S) where S <: BioSymbol\n\nTest if x and y are compatible with each other.\n\nExamples\n\njulia> iscompatible(AA_A, AA_R)\nfalse\n\njulia> iscompatible(AA_A, AA_X)\ntrue\n\njulia> iscompatible(DNA_A, DNA_A)\ntrue\n\njulia> iscompatible(DNA_C, DNA_N)  # DNA_N can be DNA_C\ntrue\n\njulia> iscompatible(DNA_C, DNA_R)  # DNA_R (A or G) cannot be DNA_C\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.isambiguous","page":"Biological Symbols","title":"BioSymbols.isambiguous","text":"isambiguous(nt::NucleicAcid)\n\nTest if nt is an ambiguous nucleotide.\n\n\n\n\n\nisambiguous(aa::AminoAcid)\n\nTest if aa is an ambiguous amino acid.\n\n\n\n\n\n","category":"function"},{"location":"io/#I/O-for-sequencing-file-formats-1","page":"I/O","title":"I/O for sequencing file formats","text":"","category":"section"},{"location":"io/#","page":"I/O","title":"I/O","text":"Versions of BioSequences prior to v2.0 provided a FASTA, FASTQ, and 2Bit submodule for working with formatted sequence files.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"After version v2.0, in order to neatly separate concerns, these submodules were removed.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"Instead there will now be dedicated BioJulia packages for each format. Each of these will be compatible with BioSequences.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"A list of all of the different formats and packages is provided below to help you find them quickly.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"Format Package\nFASTA FASTX.jl\nFASTQ FASTX.jl\n2Bit TwoBit.jl","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"counting/#Counting-1","page":"Counting","title":"Counting","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"BioSequences extends the Base.count method to provide some useful utilities for counting the number of sites in biological sequences.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"Most generically you can count the number of sites that satisfy some condition i.e. cause some function to return true:","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"julia> count(isambiguous, dna\"ATCGM\")\n1\n","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"You can also use two sequences, for example to compute the number of matching or mismatching symbols:","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"julia> count(!=, dna\"ATCGM\", dna\"GCCGM\")\n2\n\njulia> count(==, dna\"ATCGM\", dna\"GCCGM\")\n3\n","category":"page"},{"location":"counting/#Alias-functions-1","page":"Counting","title":"Alias functions","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"A number of functions which are aliases for various invocations of Base.count are provided.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"Alias function Base.count call(s)\nn_ambiguous count(isambiguous, seq), count(isambiguous, seqa, seqb)\nn_certain count(iscertain, seq), count(iscertain, seqa, seqb)\nn_gap count(isgap, seq), count(isgap, seqa, seqb)\nmatches count(==, seqa, seqb)\nmismatches count(!=, seqa, seqb)","category":"page"},{"location":"counting/#Bit-parallel-optimisations-1","page":"Counting","title":"Bit-parallel optimisations","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"For the vast majority of Base.count(f, seq) and Base.count(f, seqa, seqb) methods, a naive counting is done: the internal count_naive function is called, which simply loops over each position, applies f, and accumulates the result.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"However, for some functions, it is possible to implement highly efficient methods that use bit-parallelism to check many elements at one time. This is made possible by the succinct encoding of BioSequences. Usually f is one of the functions provided by BioSymbols.jl or by BioSequences.jl","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"For such sequence and function combinations, Base.count(f, seq) is overloaded to call an internal BioSequences.count_*_bitpar function, which is passed the sequence(s). If you want to force BioSequences to use naive counting for the purposes of testing or debugging for example, then you can call BioSequences.count_naive directly.","category":"page"},{"location":"interfaces/#BioSequences-Interfaces-1","page":"Interfaces","title":"BioSequences Interfaces","text":"","category":"section"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"This page describes the interfaces for BioSequences' core types for developers or other packages implementing their own sequence types or extending BioSequences functionality.","category":"page"},{"location":"interfaces/#Alphabets-1","page":"Interfaces","title":"Alphabets","text":"","category":"section"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Alphabet is an abstract type defined by BioSequences.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Subtypes of Alphabet are singleton structs that may or may not be parameterized.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Alphabets determine a finite list of biological symbols that can be encoded in the given sequence type.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Alphabets controls the encoding/decoding between a decoded element type and an internal data representation type.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"An Alphabet must never encode (using encode) or decode (using decode) invalid data, but must error in cases where invalid data could have been produced. Other methods for check-free encoding/decoding methods may be added.","category":"page"},{"location":"interfaces/#Required-implementation-1","page":"Interfaces","title":"Required implementation","text":"","category":"section"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Every subtype A of Alphabet must implement:","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Base.eltype(::Type{A})::Type{E} for some eltype E.\nsymbols(::A)::Tuple{Vararg{E}}. This gives an ordered tuples of all elements of A.\nencode(::A, ::E)::X encodes an element to the internal data eltype X\ndecode(::A, ::X)::E decodes an X to an element E.\nExcept for eltype which must follow Base conventions, all functions operating on Alphabet should operate on instances of the alphabet, not the type.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"If you want interoperation with existing subtypes of BioSequence, the element type E must be UInt, and you must also implement:","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"BitsPerSymbol(::A)::BitsPerSymbol{N}, where the N must be zero or a power of two in [1, 8 * sizeof(UInt)].","category":"page"},{"location":"interfaces/#Minimal-example-1","page":"Interfaces","title":"Minimal example","text":"","category":"section"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"This example implements a restricted AminoAcid alphabet, that does not contain all possible IUPAC symbols.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"struct ReducedAAAlphabet <: Alphabet end\n\nBase.eltype(::Type{ReducedAAAlphabet}) = AminoAcid\n\nBioSequences.BitsPerSymbol(::ReducedAAAlphabet) = BioSequences.BitsPerSymbol{4}()\n\nfunction BioSequences.symbols(::ReducedAAAlphabet)\n    (AA_L, AA_C, AA_A, AA_G, AA_S, AA_T, AA_P, AA_F,\n     AA_W, AA_E, AA_D, AA_N, AA_Q, AA_K, AA_H, AA_M)\nend\n\nconst (ENC_LUT, DEC_LUT) = let\n    enc_lut = fill(0xff, length(alphabet(AminoAcid)))\n    dec_lut = fill(AA_A, length(symbols(ReducedAAAlphabet())))\n    for (i, aa) in enumerate(symbols(ReducedAAAlphabet()))\n        enc_lut[reinterpret(UInt8, aa) + 0x01] = i - 1\n        dec_lut[i] = aa\n    end\n    (Tuple(enc_lut), Tuple(dec_lut))\nend\n\nfunction BioSequences.encode(::ReducedAAAlphabet, aa::AminoAcid)\n    i = reinterpret(UInt8, aa) + 0x01\n    (i ≥ length(ENC_LUT) || @inbounds ENC_LUT[i] === 0xff) && throw(DomainError(aa))\n    (@inbounds ENC_LUT[i]) % UInt\nend\n\nfunction BioSequences.decode(::ReducedAAAlphabet, x::UInt)\n    x ≥ length(DEC_LUT) && throw(DomainError(aa))\n    @inbounds DEC_LUT[x + UInt(1)]\nend","category":"page"},{"location":"interfaces/#BioSequences-1","page":"Interfaces","title":"BioSequences","text":"","category":"section"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"BioSequence subtypes are linear container types, with random access and indices Base.OneTo(length(x)).","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"They contain zero or more coding elements of type encoded_data_eltype(typeof(x)).","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"They may or may not be mutable, therefore generic functions cannot assume mutability.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"They are associated with an Alphabet, A by being a subtype of BioSequence{A}.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"The concrete type, together with its associated Alphabet, and no other properties, determines how to extract individual elements from the encoded data and the index.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"The BioSequence subtype with the index, and optionally with the Alphabet, determines how to extract the internally encoded elements.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"The Alphabet then controls how to decode it to an element.","category":"page"},{"location":"interfaces/#Required-implementation-2","page":"Interfaces","title":"Required implementation","text":"","category":"section"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Every subtype T of BioSequence{A} must implement the following methods, where x in an instance of the subtype:","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Base.length(x)::Int\nencoded_data_eltype(::Type{T})::Type{E}\nextract_encoded_element(x, ::Int)::E\nT must be able to be constructed from any iterable with length defined and with a known, compatible element type.","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"Furthermore, mutable sequences should implement","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"encoded_setindex!(x, ::E, ::Int)","category":"page"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"For compatibility with existing Alphabets, the encoded data eltype must be UInt.","category":"page"},{"location":"interfaces/#Minimal-example-2","page":"Interfaces","title":"Minimal example","text":"","category":"section"},{"location":"interfaces/#","page":"Interfaces","title":"Interfaces","text":"struct Codon <: BioSequence{RNAAlphabet{2}}\n    x::UInt8\nend\n\nfunction Codon(iterable)\n    length(iterable) == 3 || error(\"Must have length 3\")\n    x = zero(UInt)\n    for (i, nt) in enumerate(iterable)\n        x |= BioSequences.encode(Alphabet(Codon), convert(RNA, nt)) << (6-2i)\n    end\n    Codon(x)\nend \n\nBase.length(::Codon) = 3\nBioSequences.encoded_data_eltype(::Type{Codon}) = UInt\nfunction BioSequences.extract_encoded_element(x::Codon, i::Int)\n    (x.x >>> ((i-1) & 7)) % UInt\nend","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"iteration/#Iteration-1","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"As you might expect, sequence types are iterators over their elements:","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"julia> n = 0\n0\n\njulia> for nt in dna\"ATNGNNT\"\n           if nt == DNA_N\n               global n += 1\n           end\n       end\n\njulia> n\n3\n","category":"page"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"random/#Generating-random-sequences-1","page":"Random sequences","title":"Generating random sequences","text":"","category":"section"},{"location":"random/#Long-sequences-1","page":"Random sequences","title":"Long sequences","text":"","category":"section"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"You can generate random long sequences using the randdna function and the Sampler's implemented in BioSequences:","category":"page"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"randseq\nranddnaseq\nrandrnaseq\nrandaaseq\nSamplerUniform\nSamplerWeighted","category":"page"},{"location":"random/#BioSequences.randseq","page":"Random sequences","title":"BioSequences.randseq","text":"randseq([rng::AbstractRNG], A::Alphabet, sp::Sampler, len::Integer)\n\nGenerate a LongSequence{A} of length len with elements drawn from the given sampler.\n\nExample:\n\n# Generate 1000-length RNA with 4% chance of N, 24% for A, C, G, or U\njulia> sp = SamplerWeighted(rna\"ACGUN\", fill(0.24, 4))\njulia> seq = randseq(RNAAlphabet{4}(), sp, 50)\n50nt RNA Sequence:\nCUNGGGCCCGGGNAAACGUGGUACACCCUGUUAAUAUCAACNNGCGCUNU\n\n\n\n\n\nrandseq([rng::AbstractRNG], A::Alphabet, len::Integer)\n\nGenerate a LongSequence{A} of length len from the specified alphabet, drawn from the default distribution. User-defined alphabets should implement this method to implement random LongSequence generation.\n\nFor RNA and DNA alphabets, the default distribution is uniform across A, C, G, and T/U. For AminoAcidAlphabet, it is uniform across the 20 standard amino acids. For a user-defined alphabet A, default is uniform across all elements of symbols(A).\n\nExample:\n\njulia> seq = randseq(AminoAcidAlphabet(), 50)\n50aa Amino Acid Sequence:\nVFMHSIRMIRLMVHRSWKMHSARHVNFIRCQDKKWKSADGIYTDICKYSM\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randdnaseq","page":"Random sequences","title":"BioSequences.randdnaseq","text":"randdnaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{DNAAlphabet{4}} sequence of length len, with bases sampled uniformly from [A, C, G, T]\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randrnaseq","page":"Random sequences","title":"BioSequences.randrnaseq","text":"randrnaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{RNAAlphabet{4}} sequence of length len, with bases sampled uniformly from [A, C, G, U]\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randaaseq","page":"Random sequences","title":"BioSequences.randaaseq","text":"randaaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{AminoAcidAlphabet} sequence of length len, with amino acids sampled uniformly from the 20 standard amino acids.\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.SamplerUniform","page":"Random sequences","title":"BioSequences.SamplerUniform","text":"SamplerUniform{T}\n\nUniform sampler of type T. Instantiate with a collection of eltype T containing the elements to sample.\n\nExamples\n\njulia> sp = SamplerUniform(rna\"ACGU\");\n\n\n\n\n\n","category":"type"},{"location":"random/#BioSequences.SamplerWeighted","page":"Random sequences","title":"BioSequences.SamplerWeighted","text":"SamplerWeighted{T}\n\nWeighted sampler of type T. Instantiate with a collection of eltype T containing the elements to sample, and an orderen collection of probabilities to sample each element except the last. The last probability is the remaining probability up to 1.\n\nExamples\n\njulia> sp = SamplerWeighted(rna\"ACGUN\", fill(0.2475, 4));\n\n\n\n\n\n","category":"type"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"transforms/#Indexing-and-modifying-sequences-1","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"","category":"section"},{"location":"transforms/#Indexing-1","page":"Indexing & modifying sequences","title":"Indexing","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Most BioSequence concrete subtypes for the most part behave like other vector or string types. They can be indexed using integers or ranges:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"For example, with LongSequences:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTTTANAGTNNAGTACC\"\n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia> seq[5]\nDNA_T\n\njulia> seq[6:end]\n14nt DNA Sequence:\nTANAGTNNAGTACC\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"The biological symbol at a given locus in a biological sequence can be set using setindex:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTTTANAGTNNAGTACC\"\n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia> seq[5] = DNA_A\nDNA_A\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"note: Note\nSome types such as Kmer can be indexed using integers but not using ranges.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"For LongSequence types, indexing a sequence by range creates a copy of the original sequence, similar to Array in Julia's Base library. If you find yourself slowed down by the allocation of these subsequences, consider using a sequence view instead.","category":"page"},{"location":"transforms/#Modifying-sequences-1","page":"Indexing & modifying sequences","title":"Modifying sequences","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"In addition to setindex, many other modifying operations are possible for biological sequences such as push!, pop!, and insert!, which should be familiar to anyone used to editing arrays.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"push!\npop!\npushfirst!\npopfirst!\ninsert!\ndeleteat!(::BioSequences.BioSequence, ::Integer)\nappend!\nresize!\nempty!","category":"page"},{"location":"transforms/#Base.push!","page":"Indexing & modifying sequences","title":"Base.push!","text":"push!(collection, items...) -> collection\n\nInsert one or more items in collection. If collection is an ordered container, the items are inserted at the end (in the given order).\n\nExamples\n\njulia> push!([1, 2, 3], 4, 5, 6)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nIf collection is ordered, use append! to add all the elements of another collection to it. The result of the preceding example is equivalent to append!([1, 2, 3], [4, 5, 6]). For AbstractSet objects, union! can be used instead.\n\nSee sizehint! for notes about the performance model.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.pop!","page":"Indexing & modifying sequences","title":"Base.pop!","text":"pop!(collection) -> item\n\nRemove an item in collection and return it. If collection is an ordered container, the last item is returned; for unordered containers, an arbitrary element is returned.\n\nExamples\n\njulia> A=[1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> pop!(A)\n3\n\njulia> A\n2-element Vector{Int64}:\n 1\n 2\n\njulia> S = Set([1, 2])\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> pop!(S)\n2\n\njulia> S\nSet{Int64} with 1 element:\n  1\n\njulia> pop!(Dict(1=>2))\n1 => 2\n\n\n\n\n\npop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\npop!(seq::BioSequence)\n\nRemove the symbol from the end of a biological sequence seq and return it. Returns a variable of eltype(seq).\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.pushfirst!","page":"Indexing & modifying sequences","title":"Base.pushfirst!","text":"pushfirst!(collection, items...) -> collection\n\nInsert one or more items at the beginning of collection.\n\nExamples\n\njulia> pushfirst!([1, 2, 3, 4], 5, 6)\n6-element Vector{Int64}:\n 5\n 6\n 1\n 2\n 3\n 4\n\n\n\n\n\npushfirst!(seq, x)\n\nInsert a biological symbol x at the beginning of a biological sequence seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.popfirst!","page":"Indexing & modifying sequences","title":"Base.popfirst!","text":"popfirst!(collection) -> item\n\nRemove the first item from collection.\n\nExamples\n\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> popfirst!(A)\n1\n\njulia> A\n5-element Vector{Int64}:\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\npopfirst!(seq)\n\nRemove the symbol from the beginning of a biological sequence seq and return it. Returns a variable of eltype(seq).\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.insert!","page":"Indexing & modifying sequences","title":"Base.insert!","text":"insert!(a::Vector, index::Integer, item)\n\nInsert an item into a at the given index. index is the index of item in the resulting a.\n\nExamples\n\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\ninsert!(seq::BioSequence, i, x)\n\nInsert a biological symbol x into a biological sequence seq, at the given index i.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.deleteat!-Tuple{BioSequence, Integer}","page":"Indexing & modifying sequences","title":"Base.deleteat!","text":"deleteat!(seq::BioSequence, i::Integer)\n\nDelete a biological symbol at a single position i in a biological sequence seq.\n\nModifies the input sequence.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#Base.append!","page":"Indexing & modifying sequences","title":"Base.append!","text":"append!(collection, collections...) -> collection.\n\nFor an ordered container collection, add the elements of each collections to the end of it.\n\ncompat: Julia 1.6\nSpecifying multiple collections to be appended requires at least Julia 1.6.\n\nExamples\n\njulia> append!([1], [2, 3])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> append!([1, 2, 3], [4, 5], [6])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse push! to add individual items to collection which are not already themselves in another collection. The result of the preceding example is equivalent to push!([1, 2, 3], 4, 5, 6).\n\nSee sizehint! for notes about the performance model.\n\n\n\n\n\nappend!(seq, other)\n\nAdd a biological sequence other onto the end of biological sequence seq. Modifies and returns seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.resize!","page":"Indexing & modifying sequences","title":"Base.resize!","text":"resize!(a::Vector, n::Integer) -> Vector\n\nResize a to contain n elements. If n is smaller than the current collection length, the first n elements will be retained. If n is larger, the new elements are not guaranteed to be initialized.\n\nExamples\n\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Vector{Int64}:\n 6\n 5\n 4\n\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\n\njulia> length(a)\n8\n\njulia> a[1:6]\n6-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\nresize!(seq, size, [force::Bool])\n\nResize a biological sequence seq, to a given size. Does not resize the underlying data array unless the new size does not fit. If force, always resize underlying data array.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.empty!","page":"Indexing & modifying sequences","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String, Int64}()\n\n\n\n\n\nempty!(seq::BioSequence)\n\nCompletely empty a biological sequence seq of nucleotides.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Here are some examples:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACG\"\n3nt DNA Sequence:\nACG\n\njulia> push!(seq, DNA_T)\n4nt DNA Sequence:\nACGT\n\njulia> append!(seq, dna\"AT\")\n6nt DNA Sequence:\nACGTAT\n\njulia> deleteat!(seq, 2)\n5nt DNA Sequence:\nAGTAT\n\njulia> deleteat!(seq, 2:3)\n3nt DNA Sequence:\nAAT\n","category":"page"},{"location":"transforms/#Additional-transformations-1","page":"Indexing & modifying sequences","title":"Additional transformations","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"In addition to these basic modifying functions, other sequence transformations that are common in bioinformatics are also provided.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"reverse!(::BioSequences.LongSequence)\nreverse(::BioSequences.LongSequence{<:NucleicAcidAlphabet})\ncomplement!\ncomplement\nreverse_complement!\nreverse_complement\nungap!\nungap\ncanonical!\ncanonical","category":"page"},{"location":"transforms/#Base.reverse!-Tuple{LongSequence}","page":"Indexing & modifying sequences","title":"Base.reverse!","text":"reverse!(seq::LongSequence)\n\nReverse a biological sequence seq in place.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#Base.reverse-Tuple{LongSequence{var\"#s1\"} where var\"#s1\"<:NucleicAcidAlphabet}","page":"Indexing & modifying sequences","title":"Base.reverse","text":"reverse(seq::BioSequence)\n\nCreate reversed copy of a biological sequence.\n\n\n\n\n\nreverse(seq::LongSequence)\n\nCreate reversed copy of a biological sequence.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#BioSequences.complement!","page":"Indexing & modifying sequences","title":"BioSequences.complement!","text":"complement!(seq)\n\nMake a complement sequence of seq in place.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSymbols.complement","page":"Indexing & modifying sequences","title":"BioSymbols.complement","text":"complement(nt::NucleicAcid)\n\nReturn the complementary nucleotide of nt.\n\nThis function returns the union of all possible complementary nucleotides.\n\nExamples\n\njulia> complement(DNA_A)\nDNA_T\n\njulia> complement(DNA_N)\nDNA_N\n\njulia> complement(RNA_U)\nRNA_A\n\n\n\n\n\n\ncomplement(seq)\n\nMake a complement sequence of seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.reverse_complement!","page":"Indexing & modifying sequences","title":"BioSequences.reverse_complement!","text":"reverse_complement!(seq)\n\nMake a reversed complement sequence of seq in place.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.reverse_complement","page":"Indexing & modifying sequences","title":"BioSequences.reverse_complement","text":"reverse_complement(seq)\n\nMake a reversed complement sequence of seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ungap!","page":"Indexing & modifying sequences","title":"BioSequences.ungap!","text":"Remove gap characters from an input sequence.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ungap","page":"Indexing & modifying sequences","title":"BioSequences.ungap","text":"Create a copy of a sequence with gap characters removed.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.canonical!","page":"Indexing & modifying sequences","title":"BioSequences.canonical!","text":"canonical!(seq::NucleotideSeq)\n\nTransforms the seq into its canonical form, if it is not already canonical. Modifies the input sequence inplace.\n\nFor any sequence, there is a reverse complement, which is the same sequence, but on the complimentary strand of DNA:\n\n------->\nATCGATCG\nCGATCGAT\n<-------\n\nnote: Note\nUsing the reverse_complement of a DNA sequence will give give this reverse complement.\n\nOf the two sequences, the canonical of the two sequences is the lesser of the two i.e. canonical_seq < other_seq.\n\nUsing this function on a seq will ensure it is the canonical version.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.canonical","page":"Indexing & modifying sequences","title":"BioSequences.canonical","text":"canonical(seq::NucleotideSeq)\n\nCreate the canonical sequence of seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Some examples:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTAT\"\n6nt DNA Sequence:\nACGTAT\n\njulia> reverse!(seq)\n6nt DNA Sequence:\nTATGCA\n\njulia> complement!(seq)\n6nt DNA Sequence:\nATACGT\n\njulia> reverse_complement!(seq)\n6nt DNA Sequence:\nACGTAT\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Many of these methods also have a version which makes a copy of the input sequence, so you get a modified copy, and don't alter the original sequence. Such methods are named the same, but without the exclamation mark. E.g. reverse instead of reverse!, and ungap instead of ungap!.  ","category":"page"},{"location":"transforms/#Translation-1","page":"Indexing & modifying sequences","title":"Translation","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Translation is a slightly more complex transformation for RNA Sequences and so we describe it here in more detail.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"The translate function translates a sequence of codons in a RNA sequence to a amino acid sequence based on a genetic code. The BioSequences package provides all NCBI defined genetic codes and they are registered in ncbi_trans_table.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"translate\nncbi_trans_table","category":"page"},{"location":"transforms/#BioSequences.translate","page":"Indexing & modifying sequences","title":"BioSequences.translate","text":"translate(seq, code=standard_genetic_code, allow_ambiguous_codons=true, convert_start_codon=false)\n\nTranslate an LongRNASeq or a LongDNASeq to an LongAASeq.\n\nTranslation uses genetic code code to map codons to amino acids. See ncbi_trans_table for available genetic codes. If codons in the given sequence cannot determine a unique amino acid, they will be translated to AA_X if allow_ambiguous_codons is true and otherwise result in an error. For organisms that utilize alternative start codons, one can set alternative_start=true, in which case the first codon will always be converted to a methionine.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ncbi_trans_table","page":"Indexing & modifying sequences","title":"BioSequences.ncbi_trans_table","text":"Genetic code list of NCBI.\n\nThe standard genetic code is ncbi_trans_table[1] and others can be shown by show(ncbi_trans_table). For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.\n\n\n\n\n\n","category":"constant"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> ncbi_trans_table\nTranslation Tables:\n  1. The Standard Code (standard_genetic_code)\n  2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)\n  3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)\n  4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)\n  5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)\n  6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)\n  9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)\n 10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)\n 11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)\n 12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)\n 13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)\n 14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)\n 16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)\n 21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)\n 22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)\n 23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)\n 24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)\n 25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#Construction-and-conversion-1","page":"Constructing sequences","title":"Construction & conversion","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Here we will showcase the various ways you can construct the various sequence types in BioSequences.","category":"page"},{"location":"construction/#Constructing-sequences-1","page":"Constructing sequences","title":"Constructing sequences","text":"","category":"section"},{"location":"construction/#From-strings-1","page":"Constructing sequences","title":"From strings","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be constructed from strings using their constructors:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq(\"TTANC\")\n5nt DNA Sequence:\nTTANC\n\njulia> LongSequence{DNAAlphabet{2}}(\"TTAGC\")\n5nt DNA Sequence:\nTTAGC\n\njulia> LongRNASeq(\"UUANC\")\n5nt RNA Sequence:\nUUANC\n\njulia> LongSequence{RNAAlphabet{2}}(\"UUAGC\")\n5nt RNA Sequence:\nUUAGC\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"note: Note\nFrom version 2.0 onwards, the convert methods for converting a string or vector of symbols into a sequence type have been removed. These convert methods did nothing but pass their arguments to the appropriate constructor.These specific convert methods have been removed due to the semantics of convert: Even though convert(LongDNASeq, \"ATCG\") was previously the same as LongDNASeq(\"ATCG\"), unlike constructors, convert is sometimes implicitly called. So it's methods should be restricted to cases that are considered safe or unsurprising. convert should convert between types that represent the same basic kind of thing, like different representations of numbers. It is also usually lossless. Not all strings are valid sequences, and depending on the sequence type, not all vectors of BioSymbols are valid sequences either. A string only represents the \"same kind of thing\" as a biological sequence in some cases, so implicitly converting them to a sequence type was never safe or unsurprising. These convert methods have been renamed to Base.parse methods.","category":"page"},{"location":"construction/#Constructing-sequences-from-arrays-of-BioSymbols-1","page":"Constructing sequences","title":"Constructing sequences from arrays of BioSymbols","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be constructed using vectors or arrays of a BioSymbol type:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq([DNA_T, DNA_T, DNA_A, DNA_N, DNA_C])\n5nt DNA Sequence:\nTTANC\n\njulia> LongSequence{DNAAlphabet{2}}([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\n5nt DNA Sequence:\nTTAGC\n","category":"page"},{"location":"construction/#Constructing-sequences-from-other-sequences-1","page":"Constructing sequences","title":"Constructing sequences from other sequences","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You can create sequences, by concatenating other sequences together:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq(\"ACGT\") * LongDNASeq(\"TGCA\")\n8nt DNA Sequence:\nACGTTGCA\n\njulia> repeat(LongDNASeq(\"TA\"), 10)\n20nt DNA Sequence:\nTATATATATATATATATATA\n\njulia> LongDNASeq(\"TA\") ^ 10\n20nt DNA Sequence:\nTATATATATATATATATATA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequence views (LongSubSeqs) are special, in that they do not own their own data, and must be constructed from a LongSequence or another LongSubSeq:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> seq = LongDNASeq(\"TACGGACATTA\")\n11nt DNA Sequence:\nTACGGACATTA\n\njulia> seqview = LongSubSeq(seq, 3:7)\n5nt DNA Sequence:\nCGGAC\n\njulia> seqview2 = @view seq[1:3]\n3nt DNA Sequence:\nTAC\n\njulia> typeof(seqview) == typeof(seqviev2) && typeof(seqview) <: LongSubSeq\ntrue\n","category":"page"},{"location":"construction/#Conversion-of-sequence-types-1","page":"Constructing sequences","title":"Conversion of sequence types","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You can convert between sequence types.","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna = dna\"TTANGTAGACCG\"\n12nt DNA Sequence:\nTTANGTAGACCG\n\njulia> rna = convert(LongRNASeq, dna)\n12nt RNA Sequence:\nUUANGUAGACCG\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be converted explicitly and implicitly, into arrays and strings:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna = dna\"TTANGTAGACCG\"\n12nt DNA Sequence:\nTTANGTAGACCG\n\njulia> dnastr = convert(String, dna)\n\"TTANGTAGACCG\"\n\njulia> # Implicit conversion to string - putting dna sequence in String vector \n\njulia> arr = String[dna]\n1-element Vector{String}:\n \"TTANGTAGACCG\"\n ","category":"page"},{"location":"construction/#String-literals-1","page":"Constructing sequences","title":"String literals","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"BioSequences provides several string literal macros for creating sequences.","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"note: Note\nWhen you use literals you may mix the case of characters.","category":"page"},{"location":"construction/#Long-sequence-literals-1","page":"Constructing sequences","title":"Long sequence literals","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna\"TACGTANNATC\"\n11nt DNA Sequence:\nTACGTANNATC\n\njulia> rna\"AUUUGNCCANU\"\n11nt RNA Sequence:\nAUUUGNCCANU\n\njulia> aa\"ARNDCQEGHILKMFPSTWYVX\"\n21aa Amino Acid Sequence:\nARNDCQEGHILKMFPSTWYVX","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"However, it should be noted that by default these sequence literals allocate the LongSequence object before the code containing the sequence literal is run. This means there may be occasions where your program does not behave as you first expect. For example consider the following code:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> function foo()\n           s = dna\"CTT\"\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"d\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You might expect that every time you call foo, that a DNA sequence CTTA would be returned. You might expect that this is because every time foo is called, a new DNA sequence variable CTT is created, and the A nucleotide is pushed to it, and the result, CTTA is returned. In other words you might expect the following output:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"However, this is not what happens, instead the following happens:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"s\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n5nt DNA Sequence:\nCTTAA\n\njulia> foo()\n6nt DNA Sequence:\nCTTAAA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"The reason for this is because the sequence literal is allocated only once before the first time the function foo is called and run. Therefore, s in foo is always a reference to that one sequence that was allocated. So one sequence is created before foo is called, and then it is pushed to every time foo is called. Thus, that one allocated sequence grows with every call of foo.","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"If you wanted foo to create a new sequence each time it is called, then you can add a flag to the end of the sequence literal to dictate behaviour: A flag of 's' means 'static': the sequence will be allocated before code is run, as is the default behaviour described above. However providing 'd' flag changes the behaviour: 'd' means 'dynamic': the sequence will be allocated whilst the code is running, and not before. So to change foo so as it creates a new sequence each time it is called, simply add the 'd' flag to the sequence literal:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> function foo()\n           s = dna\"CTT\"d     # 'd' flag appended to the string literal.\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Now every time foo is called, a new sequence CTT is created, and an A nucleotide is pushed to it:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"d\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"So the take home message of sequence literals is this:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Be careful when you are using sequence literals inside of functions, and inside the bodies of things like for loops. And if you use them and are unsure, use the  's' and 'd' flags to ensure the behaviour you get is the behaviour you intend.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"sequence_search/#Sequence-search-1","page":"Pattern matching and searching","title":"Sequence search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Three kinds of on-line search functions are provided:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Exact search\nApproximate search\nRegular expression search","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"These are all specialized for biological sequences and ambiguities of symbols are considered.","category":"page"},{"location":"sequence_search/#Exact-search-1","page":"Pattern matching and searching","title":"Exact search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Similar to other Julia sequences like Vector, a BioSequence can be searched using a function. This returns the index of the element matching where the function returns true, or nothing if no elements were found:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> findfirst(isequal(DNA_A), dna\"GCTTAG\")\n5\n\njulia> findfirst(isequal(DNA_M), dna\"GCTTAG\") === nothing\ntrue","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Sequences may also be effectively searched for the occurence of subsequences:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\";\n\njulia> query = dna\"AGC\";\n\njulia> findfirst(query, seq)\n3:5\n\njulia> findlast(query, seq)\n8:10\n\njulia> occursin(query, seq)\ntrue","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"These search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g. DNA_A and DNA_N), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> findfirst(dna\"CGT\", dna\"ACNT\")  # 'N' matches 'G'\n2:4\n\njulia> findfirst(dna\"CNT\", dna\"ACGT\")  # 'G' matches 'N'\n2:4\n\njulia> occursin(dna\"CNT\", dna\"ACNT\")\ntrue","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The exact sequence search needs a preprocessing phase of query sequence before the searching phase. This would be fast enough for most search applications. But when searching a query sequence to many target sequences, caching the result of preprocessing may save time. You can do this by creating an ExactSearchQuery object and re-use it for each search:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> query = ExactSearchQuery(dna\"ATT\");\n\njulia> findfirst(query, dna\"ATTTATT\")\n1:3\n\njulia> findlast(query, dna\"ATTTATT\")\n5:7\n\njulia> occursin(query, dna\"ATTTATT\")\ntrue","category":"page"},{"location":"sequence_search/#Approximate-search-1","page":"Pattern matching and searching","title":"Approximate search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific Levenshtein distance of the query sequence:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\";\n\njulia> approxsearch(seq, dna\"AGGG\", 0)  # nothing matches with no errors\n0:-1\n\njulia> approxsearch(seq, dna\"AGGG\", 1)  # seq[3:6] matches with one error\n3:6\n\njulia> approxsearch(seq, dna\"AGGG\", 2)  # seq[1:4] matches with two errors\n1:4\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Like the exact search functions, four kinds of functions (approxsearch, approxsearchindex, approxrsearch, and approxrsearchindex) are available:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\"; pat = dna\"AGGG\";\n\njulia> approxsearch(seq, pat, 2)        # return the range (forward)\n1:4\n\njulia> approxsearchindex(seq, pat, 2)   # return the starting index (forward)\n1\n\njulia> approxrsearch(seq, pat, 2)       # return the range (backward)\n8:11\n\njulia> approxrsearchindex(seq, pat, 2)  # return the starting index (backward)\n8\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Preprocessing can be cached in an ApproximateSearchQuery object:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> query = ApproximateSearchQuery(dna\"AGGG\");\n\njulia> approxsearch(dna\"AAGAGG\", query, 1)\n2:5\n\njulia> approxsearch(dna\"ACTACGT\", query, 2)\n4:6\n","category":"page"},{"location":"sequence_search/#Regular-expression-search-1","page":"Pattern matching and searching","title":"Regular expression search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Query patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The Perl-like syntax starts with biore (BIOlogical REgular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example, biore\"A+\"dna is a regular expression for DNA sequences and biore\"A+\"aa is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Here are examples of using the regular expression for BioSequences:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> match(biore\"A+C*\"dna, dna\"AAAACC\")\nRegexMatch(\"AAAACC\")\n\njulia> match(biore\"A+C*\"d, dna\"AAAACC\")\nRegexMatch(\"AAAACC\")\n\njulia> occursin(biore\"A+C*\"dna, dna\"AAC\")\ntrue\n\njulia> occursin(biore\"A+C*\"dna, dna\"C\")\nfalse\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"match will return a RegexMatch if a match is found, otherwise it will return nothing if no match is found.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The table below summarizes available syntax elements.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Syntax Description Example\n| alternation \"A|T\" matches \"A\" and \"T\"\n* zero or more times repeat \"TA*\" matches \"T\", \"TA\" and \"TAA\"\n+ one or more times repeat \"TA+\" matches \"TA\" and \"TAA\"\n? zero or one time \"TA?\" matches \"T\" and \"TA\"\n{n,} n or more times repeat \"A{3,}\" matches \"AAA\" and \"AAAA\"\n{n,m} n-m times repeat \"A{3,5}\" matches \"AAA\", \"AAAA\" and \"AAAAA\"\n^ the start of the sequence \"^TAN*\" matches \"TATGT\"\n$ the end of the sequence \"N*TA$\" matches \"GCTA\"\n(...) pattern grouping \"(TA)+\" matches \"TA\" and \"TATA\"\n[...] one of symbols \"[ACG]+\" matches \"AGGC\"","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"eachmatch and findfirst are also defined like usual strings:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> collect(matched(x) for x in eachmatch(biore\"TATA*?\"d, dna\"TATTATAATTA\")) # overlap\n4-element Vector{LongDNASeq}:\n TAT  \n TAT\n TATA\n TATAA\n\njulia> collect(matched(x) for x in eachmatch(biore\"TATA*\"d, dna\"TATTATAATTA\", false)) # no overlap\n2-element Vector{LongDNASeq}:\n TAT  \n TATAA\n\njulia> findfirst(biore\"TATA*\"d, dna\"TATTATAATTA\")\n1:3\n\njulia> findfirst(biore\"TATA*\"d, dna\"TATTATAATTA\", 2)\n4:8\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Noteworthy differences from strings are:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Ambiguous characters match any compatible characters (e.g. biore\"N\"d is equivalent to biore\"[ACGT]\"d).\nWhitespaces are ignored (e.g. biore\"A C G\"d is equivalent to biore\"ACG\"d).","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The PROSITE notation is described in ScanProsite - user manual. The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with prosite prefix and no symbol option is needed because it always describes patterns of amino acid sequences:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> match(prosite\"[AC]-x-V-x(4)-{ED}\", aa\"CPVPQARG\")\nRegexMatch(\"CPVPQARG\")\n\njulia> match(prosite\"[AC]xVx(4){ED}\", aa\"CPVPQARG\")\nRegexMatch(\"CPVPQARG\")\n","category":"page"},{"location":"sequence_search/#Position-weight-matrix-search-1","page":"Pattern matching and searching","title":"Position weight matrix search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"A motif can also be specified using position weight matrix (PWM) in a probabilistic way. search(seq, pwm, threshold) method searches for the first position in the sequence where a score calculated using the PWM is greater than or equal to the threshold. More formally, denoting the sequence as S and the PWM value of symbol s at position j as M_sj, the score starting from a position p is defined as","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"operatornamescore(S p) = sum_i=1^L M_Sp+i-1i","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"and search(S, M, t) returns the smallest p that satisfies operatornamescore(S p) ge t.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"There are two kinds of matrices in this package: PFM and PWM. The PFM type is a position frequency matrix and stores symbol frequencies for each position. The PWM is a position weight matrix and stores symbol scores for each position. You can create a PFM from a set of sequences with the same length and then create a PWM from the PFM object.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> motifs = [dna\"TTA\", dna\"CTA\", dna\"ACA\", dna\"TCA\", dna\"GTA\"]\n5-element Vector{LongDNASeq}:\n TTA\n CTA\n ACA\n TCA\n GTA\n\njulia> pfm = PFM(motifs)  # sequence set => PFM\n4×3 PFM{DNA, Int64}:\n A  1  0  5\n C  1  2  0\n G  1  0  0\n T  2  3  0\n\njulia> pwm = PWM(pfm)  # PFM => PWM\n4×3 PWM{DNA, Float64}:\n A -0.321928 -Inf       2.0\n C -0.321928  0.678072 -Inf\n G -0.321928 -Inf      -Inf\n T  0.678072  1.26303  -Inf\n\njulia> pwm = PWM(pfm .+ 0.01)  # add pseudo counts to avoid infinite values\n4×3 PWM{DNA, Float64}:\n A -0.319068 -6.97728   1.99139\n C -0.319068  0.673772 -6.97728\n G -0.319068 -6.97728  -6.97728\n T  0.673772  1.25634  -6.97728\n\njulia> pwm = PWM(pfm .+ 0.01, prior=[0.2, 0.3, 0.3, 0.2])  # GC-rich prior\n4×3 PWM{DNA, Float64}:\n A  0.00285965 -6.65535   2.31331\n C -0.582103    0.410737 -7.24031\n G -0.582103   -7.24031  -7.24031\n T  0.9957      1.57827  -6.65535\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The PWM_sj matrix is computed from PFM_sj and the prior probability p(s) as follows ([Wasserman2004]):","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"beginalign\n    PWM_sj = log_2 fracp(sj)p(s) \n    p(sj)  = fracPFM_sjsum_s PFM_sj\nendalign","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"[Wasserman2004]: https://doi.org/10.1038/nrg1315","category":"page"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"predicates/#Predicates-1","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"A number of predicate or query functions are supported for sequences, allowing you to check for certain properties of a sequence.","category":"page"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"isrepetitive\nispalindromic\nhasambiguity\niscanonical","category":"page"},{"location":"predicates/#BioSequences.isrepetitive","page":"Predicates","title":"BioSequences.isrepetitive","text":"isrepetitive(seq::BioSequence, n::Integer = length(seq))\n\nReturn true if and only if seq contains a repetitive subsequence of length ≥ n.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.ispalindromic","page":"Predicates","title":"BioSequences.ispalindromic","text":"ispalindromic(seq::BioSequence)\n\nReturn true if seq is a palindromic sequence; otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.hasambiguity","page":"Predicates","title":"BioSequences.hasambiguity","text":"hasambiguity(seq::BioSequence)\n\nReturns true if seq has an ambiguous symbol; otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.iscanonical","page":"Predicates","title":"BioSequences.iscanonical","text":"iscanonical(seq::NucleotideSeq)\n\nReturns true if seq is canonical.\n\nFor any sequence, there is a reverse complement, which is the same sequence, but on the complimentary strand of DNA:\n\n------->\nATCGATCG\nCGATCGAT\n<-------\n\nnote: Note\nUsing the reverse_complement of a DNA sequence will give give this reverse complement.\n\nOf the two sequences, the canonical of the two sequences is the lesser of the two i.e. canonical_seq < other_seq.\n\n\n\n\n\n","category":"function"},{"location":"#BioSequences-1","page":"Home","title":"BioSequences","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Latest Release) (Image: MIT license) (Image: Documentation) (Image: Pkg Status) (Image: Chat)","category":"page"},{"location":"#Description-1","page":"Home","title":"Description","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BioSequences provides data types and methods for common operations with biological sequences, including DNA, RNA, and amino acid sequences.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can install BioSequences from the julia REPL. Press ] to enter pkg mode again, and enter the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add BioSequences","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.","category":"page"},{"location":"#Testing-1","page":"Home","title":"Testing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BioSequences is tested against Julia 1.X on Linux, OS X, and Windows.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Unit tests) (Image: Documentation) (Image: )","category":"page"},{"location":"#Contributing-1","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Take a look at the contributing files detailed contributor and maintainer guidelines, and code of conduct.","category":"page"},{"location":"#Financial-contributions-1","page":"Home","title":"Financial contributions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We also welcome financial contributions in full transparency on our open collective. Anyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.","category":"page"},{"location":"#Backers-and-Sponsors-1","page":"Home","title":"Backers & Sponsors","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Thank you to all our backers and sponsors!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Love our work and community? Become a backer.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: backers)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Does your company use BioJulia? Help keep BioJulia feature rich and healthy by sponsoring the project Your logo will show up here with a link to your website.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"#Questions?-1","page":"Home","title":"Questions?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you have a question about contributing or using BioJulia software, come on over and chat to us on Gitter, or you can try the Bio category of the Julia discourse site.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"types/#Abstract-Types-1","page":"BioSequences Types","title":"Abstract Types","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences exports an abstract BioSequence type, and several concrete sequence types which inherit from it.","category":"page"},{"location":"types/#The-abstract-BioSequence-1","page":"BioSequences Types","title":"The abstract BioSequence","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences provides an abstract type called a BioSequence{A<:Alphabet}. This abstract type, and the methods and traits is supports, allows for many algorithms in BioSequences to be written as generically as possible, thus reducing the amount of code to read and understand, whilst maintaining high performance when such code is compiled for a concrete BioSequence subtype. Additionally, it allows new types to be implemented that are fully compatible with the rest of BioSequences, providing that key methods or traits are defined).","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequence","category":"page"},{"location":"types/#BioSequences.BioSequence","page":"BioSequences Types","title":"BioSequences.BioSequence","text":"BioSequence{A <: Alphabet}\n\nBioSequence is the main abstract type of BioSequences. Its subtypes are characterized by:\n\nBeing a linear container type with random access and indices Base.OneTo(length(x)).\nContaining zero or more internal data elements of type encoded_data_eltype(typeof(x)).\nBeing associated with an Alphabet, A by being a subtype of BioSequence{A}.\n\nA BioSequence{A} is indexed by an integer. The biosequence subtype, the index and the alphabet A determine how to extract the internal encoded data. The alphabet decides how to decode the data to the element type of the biosequence. Hence, the element type and container type of a BioSequence are separated.\n\nSubtypes T of BioSequence must implement the following, with E begin an encoded data type:\n\nBase.length(::T)::Int\nencoded_data_eltype(::Type{T})::Type{E}\nextract_encoded_element(::T, ::Integer)::E\ncopy(::T)\nT must be able to be constructed from any iterable with length defined and\n\nwith a known, compatible element type.\n\nFurthermore, mutable sequences should implement\n\nencoded_setindex!(::T, ::E, ::Integer)\nT(undef, ::Int)\nresize!(::T, ::Int)\n\nFor compatibility with existing Alphabets, the encoded data eltype must be UInt.\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Some aliases for BioSequence are also provided for your convenience:","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"NucleotideSeq\nAminoAcidSeq","category":"page"},{"location":"types/#BioSequences.NucleotideSeq","page":"BioSequences Types","title":"BioSequences.NucleotideSeq","text":"An alias for BioSequence{<:NucleicAcidAlphabet}\n\n\n\n\n\n","category":"type"},{"location":"types/#BioSequences.AminoAcidSeq","page":"BioSequences Types","title":"BioSequences.AminoAcidSeq","text":"An alias for BioSequence{AminoAcidAlphabet}\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Let's have a closer look at some of those methods that a subtype of BioSequence must implement. Check out julia base library docs for length, copy and resize!.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"encoded_data_eltype\nextract_encoded_element\nencoded_setindex!","category":"page"},{"location":"types/#BioSequences.encoded_data_eltype","page":"BioSequences Types","title":"BioSequences.encoded_data_eltype","text":"encoded_data_eltype(::Type{<:BioSequence})\n\nReturns the element type of the encoded data of the BioSequence. This is the return type of extract_encoded_element, i.e. the data type that stores the biological symbols in the biosequence.\n\nSee also: BioSequence \n\n\n\n\n\n","category":"function"},{"location":"types/#BioSequences.extract_encoded_element","page":"BioSequences Types","title":"BioSequences.extract_encoded_element","text":"extract_encoded_element(::BioSequence{A}, i::Integer)\n\nReturns the encoded element at position i. This data can be decoded using decode(A(), data) to yield the element type of the biosequence.\n\nSee also: BioSequence \n\n\n\n\n\n","category":"function"},{"location":"types/#BioSequences.encoded_setindex!","page":"BioSequences Types","title":"BioSequences.encoded_setindex!","text":"encoded_setindex!(seq::BioSequence, x::E, i::Integer)\n\nGiven encoded data x of type encoded_data_eltype(typeof(seq)), sets the internal sequence data at the given index.\n\nSee also: BioSequence \n\n\n\n\n\n","category":"function"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"A correctly defined subtype of BioSequence that satisfies the interface, will find the vast majority of methods described in the rest of this manual should work out of the box for that type. But they can always be overloaded if needed. Indeed the LongSequence type overloads Indeed some of the generic BioSequence methods, are overloaded for LongSequence, for example for transformation and counting operations where efficiency gains can be made due to the specific internal representation of a specific type.","category":"page"},{"location":"types/#The-abstract-Alphabet-1","page":"BioSequences Types","title":"The abstract Alphabet","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Alphabets control how biological symbols are encoded and decoded. They also confer many of the automatic traits and methods that any subtype of T<:BioSequence{A<:Alphabet} will get.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences.Alphabet","category":"page"},{"location":"types/#BioSequences.Alphabet","page":"BioSequences Types","title":"BioSequences.Alphabet","text":"Alphabets of biological symbols.\n\nAlphabet is the most important type trait for BioSequence. An Alphabet represents a set of biological symbols encoded by a sequence, e.g. A, C, G and T for a DNA Alphabet that requires only 2-bits to represent each symbol.\n\nSubtypes of Alphabet are singleton structs that may or may not be parameterized.\nAlphabets span over a finite set of biological symbols.\nThe alphabet controls the encoding from some internal \"encoded data\" to a BioSymbol \n\nof the alphabet's element type, as well as the decoding, the inverse process.\n\nAn Alphabet's encode and decode methods must not produce invalid data. \n\nEvery subtype A of Alphabet must implement:\n\nBase.eltype(::Type{A})::Type{S} for some eltype S, which must be a BioSymbol.\nsymbols(::A)::Tuple{Vararg{S}}. This gives tuples of all symbols in the set of A.\nencode(::A, ::S)::E encodes a symbol to an internal data eltype E.\ndecode(::A, ::E)::S decodes an internal data eltype E to a symbol S.\nExcept for eltype which must follow Base conventions, all functions operating\n\non Alphabet should operate on instances of the alphabet, not the type.\n\nIf you want interoperation with existing subtypes of BioSequence, the encoded representation E must be of type UInt, and you must also implement:\n\nBitsPerSymbol(::A)::BitsPerSymbol{N}, where the N must be zero\n\nor a power of two in [1, 2, 4, 8, 16, 32, [64 for 64-bit systems]].\n\n\n\n\n\n","category":"type"},{"location":"types/#Concrete-types-1","page":"BioSequences Types","title":"Concrete types","text":"","category":"section"},{"location":"types/#Implemented-alphabets-1","page":"BioSequences Types","title":"Implemented alphabets","text":"","category":"section"},{"location":"types/#Long-Sequences-1","page":"BioSequences Types","title":"Long Sequences","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Many genomics scripts and tools benefit from an efficient general purpose sequence type that allows you to create and edit sequences. In BioSequences, the LongSequence type fills this requirement.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"LongSequence{A<:Alphabet} <: BioSequence{A} is parameterized by a concrete Alphabet type A that defines the domain (or set) of biological symbols permitted. For example, AminoAcidAlphabet is associated with AminoAcid and hence an object of the LongSequence{AminoAcidAlphabet} type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"The following table summarizes common LongSequence types that have been given aliases for convenience.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Type Symbol type Type alias\nLongSequence{DNAAlphabet{4}} DNA LongDNASeq\nLongSequence{RNAAlphabet{4}} RNA LongRNASeq\nLongSequence{AminoAcidAlphabet} AminoAcid LongAminoAcidSeq","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"The LongDNASeq and LongRNASeq aliases use a DNAAlphabet{4}, which means the sequence may store ambiguous nucleotides. If you are sure that nucleotide sequences store unambiguous nucleotides only, you can reduce the memory required by sequences by using a slightly different parameter: DNAAlphabet{2} is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). Replacing LongSequence{DNAAlphabet{4}} in your code with LongSequence{DNAAlphabet{2}} is all you need to do in order to benefit. Some computations that use bitwise operations will also be dramatically faster.","category":"page"},{"location":"types/#Sequence-views-1","page":"BioSequences Types","title":"Sequence views","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Similar to how Base Julia offers views of array objects, BioSequences offers view of LongSequences - the LongSubSeq{A<:Alphabet}.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Conceptually, a LongSubSeq{A} is similar to a LongSequence{A}, but instead of storing their own data, they refer to the data of a LongSequence. Modiying the LongSequence will be reflected in the view, and vice versa. If the underlying LongSequence is truncated, the behaviour of a view is undefined. For the same reason, some operations are not supported for views, such as resizing.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"The purpose of LongSubSeq is that, since they only contain a pointer to the underlying array, an offset and a length, they are much lighter than LongSequences, and will be stack allocated on Julia 1.5 and newer. Thus, the user may construct millions of views without major performance implications.","category":"page"}]
}
