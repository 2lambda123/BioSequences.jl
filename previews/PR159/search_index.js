var documenterSearchIndex = {"docs":
[{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"dev_docs/bitindex/#BitIndex-1","page":"BitIndex","title":"BitIndex","text":"","category":"section"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"The BitIndex type is an important type in BioSequences internally. BioSequence types store their elements in a vector in a succinct and packed form, allowing multiple symbols (dna, rna, amino-acids, etc.) to be stored inside a single word. This has great performance benefits but makes some things more tricky. For example iterating though the encoded data of the sequence or keeping track of where in the binary array the elements begin and end.","category":"page"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"We simplify this by keeping the length of encoded binary bits in a sequence fixed. Hence a character at arbitrary position can be extracted in a constant time. We then use this BitIndex type which represents the position of an element in the encoded bits as an index, and an offset. I.e Which chunk an element is stored in, and its offset inside of that chunk.","category":"page"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"You can think of this visually:","category":"page"},{"location":"dev_docs/bitindex/#index(i)-1-index(i)-index(i)1-1","page":"BitIndex","title":"index(i)-1        index(i)        index(i)+1","text":"","category":"section"},{"location":"dev_docs/bitindex/#......................X.................................-1","page":"BitIndex","title":"....|................|..X.............|................|....","text":"","category":"section"},{"location":"dev_docs/bitindex/#offset(i)-1","page":"BitIndex","title":"|<-offset(i)-|","text":"","category":"section"},{"location":"dev_docs/bitindex/#–-64-bits-–-1","page":"BitIndex","title":"|<–- 64 bits –>|","text":"","category":"section"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"In the above diagram, the element pointed to is marked by X, i is the BitIndex and in this case the chunk size is 64 bits (although the BitIndex type supports other chunk sizes).","category":"page"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"The BitIndex type has two parameters: N which is the number of bits used for each element, and W, which is the word (or chunk) size.","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"symbols/#Biological-symbols-1","page":"Biological Symbols","title":"Biological symbols","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"The BioSequences module reexports the biological symbol (character) types that are provided by BioSymbols.jl:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Type Meaning\nDNA DNA nucleotide\nRNA RNA nucleotide\nAminoAcid Amino acid","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"These symbols are elements of biological sequences, just as characters are elements of strings. See sections beginning from Sequence Types section for details.","category":"page"},{"location":"symbols/#DNA-and-RNA-nucleotides-1","page":"Biological Symbols","title":"DNA and RNA nucleotides","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Set of nucleotide symbols in BioSequences covers IUPAC nucleotide base plus a gap symbol:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbol Constant Meaning\n'A' DNA_A / RNA_A A; Adenine\n'C' DNA_C / RNA_C C; Cytosine\n'G' DNA_G / RNA_G G; Guanine\n'T' DNA_T T; Thymine (DNA only)\n'U' RNA_U U; Uracil (RNA only)\n'M' DNA_M / RNA_M A or C\n'R' DNA_R / RNA_R A or G\n'W' DNA_W / RNA_W A or T/U\n'S' DNA_S / RNA_S C or G\n'Y' DNA_Y / RNA_Y C or T/U\n'K' DNA_K / RNA_K G or T/U\n'V' DNA_V / RNA_V A or C or G; not T/U\n'H' DNA_H / RNA_H A or C or T; not G\n'D' DNA_D / RNA_D A or G or T/U; not C\n'B' DNA_B / RNA_B C or G or T/U; not A\n'N' DNA_N / RNA_N A or C or G or T/U\n'-' DNA_Gap / RNA_Gap Gap (none of the above)","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"https://www.bioinformatics.org/sms/iupac.html","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols are accessible as constants with DNA_ or RNA_ prefix:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> DNA_A\nDNA_A\n\njulia> DNA_T\nDNA_T\n\njulia> RNA_U\nRNA_U\n\njulia> DNA_Gap\nDNA_Gap\n\njulia> typeof(DNA_A)\nDNA\n\njulia> typeof(RNA_A)\nRNA\n","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols can be constructed by converting regular characters:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> convert(DNA, 'C')\nDNA_C\n\njulia> convert(DNA, 'C') === DNA_C\ntrue\n","category":"page"},{"location":"symbols/#Amino-acids-1","page":"Biological Symbols","title":"Amino acids","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Set of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbol Constant Meaning\n'A' AA_A Alanine\n'R' AA_R Arginine\n'N' AA_N Asparagine\n'D' AA_D Aspartic acid (Aspartate)\n'C' AA_C Cysteine\n'Q' AA_Q Glutamine\n'E' AA_E Glutamic acid (Glutamate)\n'G' AA_G Glycine\n'H' AA_H Histidine\n'I' AA_I Isoleucine\n'L' AA_L Leucine\n'K' AA_K Lysine\n'M' AA_M Methionine\n'F' AA_F Phenylalanine\n'P' AA_P Proline\n'S' AA_S Serine\n'T' AA_T Threonine\n'W' AA_W Tryptophan\n'Y' AA_Y Tyrosine\n'V' AA_V Valine\n'O' AA_O Pyrrolysine\n'U' AA_U Selenocysteine\n'B' AA_B Aspartic acid or Asparagine\n'J' AA_J Leucine or Isoleucine\n'Z' AA_Z Glutamine or Glutamic acid\n'X' AA_X Any amino acid\n'*' AA_Term Termination codon\n'-' AA_Gap Gap (none of the above)","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"https://www.bioinformatics.org/sms/iupac.html","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols are accessible as constants with AA_ prefix:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> AA_A\nAA_A\n\njulia> AA_Q\nAA_Q\n\njulia> AA_Term\nAA_Term\n\njulia> typeof(AA_A)\nAminoAcid\n","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols can be constructed by converting regular characters:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> convert(AminoAcid, 'A')\nAA_A\n\njulia> convert(AminoAcid, 'P') === AA_P\ntrue\n","category":"page"},{"location":"symbols/#Other-functions-1","page":"Biological Symbols","title":"Other functions","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"alphabet\ngap\niscompatible\nisambiguous","category":"page"},{"location":"symbols/#BioSymbols.alphabet","page":"Biological Symbols","title":"BioSymbols.alphabet","text":"alphabet(DNA)\n\nGet all symbols of DNA in sorted order.\n\nExamples\n\njulia> alphabet(DNA)\n(DNA_Gap, DNA_A, DNA_C, DNA_M, DNA_G, DNA_R, DNA_S, DNA_V, DNA_T, DNA_W, DNA_Y, DNA_H, DNA_K, DNA_D, DNA_B, DNA_N)\n\njulia> issorted(alphabet(DNA))\ntrue\n\n\n\n\n\n\nalphabet(RNA)\n\nGet all symbols of RNA in sorted order.\n\nExamples\n\njulia> alphabet(RNA)\n(RNA_Gap, RNA_A, RNA_C, RNA_M, RNA_G, RNA_R, RNA_S, RNA_V, RNA_U, RNA_W, RNA_Y, RNA_H, RNA_K, RNA_D, RNA_B, RNA_N)\n\njulia> issorted(alphabet(RNA))\ntrue\n\n\n\n\n\n\nalphabet(AminoAcid)\n\nGet all symbols of AminoAcid in sorted order.\n\nExamples\n\njulia> alphabet(AminoAcid)\n(AA_A, AA_R, AA_N, AA_D, AA_C, AA_Q, AA_E, AA_G, AA_H, AA_I, AA_L, AA_K, AA_M, AA_F, AA_P, AA_S, AA_T, AA_W, AA_Y, AA_V, AA_O, AA_U, AA_B, AA_J, AA_Z, AA_X, AA_Term, AA_Gap)\n\njulia> issorted(alphabet(AminoAcid))\ntrue\n\n\n\n\n\n\nGets the alphabet encoding of a given BioSequence.\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.gap","page":"Biological Symbols","title":"BioSymbols.gap","text":"gap(DNA)\n\nReturn DNA_Gap.\n\n\n\n\n\ngap(RNA)\n\nReturn RNA_Gap.\n\n\n\n\n\ngap(AminoAcid)\n\nReturn AA_Gap.\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.iscompatible","page":"Biological Symbols","title":"BioSymbols.iscompatible","text":"iscompatible(x::S, y::S) where S <: BioSymbol\n\nTest if x and y are compatible with each other.\n\nExamples\n\njulia> iscompatible(AA_A, AA_R)\nfalse\n\njulia> iscompatible(AA_A, AA_X)\ntrue\n\njulia> iscompatible(DNA_A, DNA_A)\ntrue\n\njulia> iscompatible(DNA_C, DNA_N)  # DNA_N can be DNA_C\ntrue\n\njulia> iscompatible(DNA_C, DNA_R)  # DNA_R (A or G) cannot be DNA_C\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.isambiguous","page":"Biological Symbols","title":"BioSymbols.isambiguous","text":"isambiguous(nt::NucleicAcid)\n\nTest if nt is an ambiguous nucleotide.\n\n\n\n\n\nisambiguous(aa::AminoAcid)\n\nTest if aa is an ambiguous amino acid.\n\n\n\n\n\n","category":"function"},{"location":"io/#I/O-for-sequencing-file-formats-1","page":"I/O","title":"I/O for sequencing file formats","text":"","category":"section"},{"location":"io/#","page":"I/O","title":"I/O","text":"Versions of BioSequences prior to v2.0 provided a FASTA, FASTQ, and 2Bit submodule for working with formatted sequence files.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"After version v2.0, in order to neatly separate concerns, these submodules were removed.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"Instead there will now be dedicated BioJulia packages for each format. Each of these will be compatible with BioSequences.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"A list of all of the different formats and packages is provided below to help you find them quickly.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"Format Package\nFASTA FASTX.jl\nFASTQ FASTX.jl\n2Bit TwoBit.jl","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"counting/#Counting-1","page":"Counting","title":"Counting","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"BioSequences extends the Base.count method to provide some useful utilities for counting the number of sites in biological sequences.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"Most generically you can count the number of sites that satisfy some condition i.e. cause some function to return true:","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"julia> count(isambiguous, dna\"ATCGM\")\n1\n","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"You can also use two sequences, for example to compute the number of matching or mismatching symbols:","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"julia> count(!=, dna\"ATCGM\", dna\"GCCGM\")\n2\n\njulia> count(==, dna\"ATCGM\", dna\"GCCGM\")\n3\n","category":"page"},{"location":"counting/#Alias-functions-1","page":"Counting","title":"Alias functions","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"A number of functions which are aliases for various invocations of Base.count are provided.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"Alias function Base.count call(s)\nn_ambiguous count(isambiguous, seq), count(isambiguous, seqa, seqb)\nn_certain count(iscertain, seq), count(iscertain, seqa, seqb)\nn_gap count(isgap, seq), count(isgap, seqa, seqb)\nmatches count(==, seqa, seqb)\nmismatches count(!=, seqa, seqb)","category":"page"},{"location":"counting/#Bit-parallel-optimisations-1","page":"Counting","title":"Bit-parallel optimisations","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"For the vast majority of Base.count(f, seq) and Base.count(f, seqa, seqb) methods, a naive counting is done: the internal count_naive function is called, which simply loops over each position, applies f, and accumulates the result.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"However, for some functions, it is possible to implement highly efficient methods that use bit-parallelism to check many elements at one time. This is made possible by the succinct encoding of BioSequences. Usually f is one of the functions provided by BioSymbols.jl or by BioSequences.jl","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"For such sequence and function combinations, Base.count(f, seq) is overloaded to call an internal BioSequences.count_*_bitpar function, which is passed the sequence(s). If you want to force BioSequences to use naive counting for the purposes of testing or debugging for example, then you can call BioSequences.count_naive directly.","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"iteration/#Iteration-1","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"As you might expect, sequence types are iterators over their elements:","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"julia> n = 0\n0\n\njulia> for nt in dna\"ATNGNNT\"\n           if nt == DNA_N\n               global n += 1\n           end\n       end\n\njulia> n\n3\n","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"However, there are many other ways to iterate over a biological sequence, and they are described in the following sections.","category":"page"},{"location":"iteration/#Positions-1","page":"Iteration","title":"Positions","text":"","category":"section"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"You can iterate over the positions/residues of a sequence that satisfy some condition or query function:","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"each(::Function, ::BioSequence)","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"julia> dna_seq = dna\"NATTCGRATY\"\n10nt DNA Sequence:\nNATTCGRATY\n\njulia> # Iterate over each ambiguous residue\n\njulia> for (pos, nuc) in each(isambiguous, dna_seq)\n           println(\"Position $pos is $nuc\")\n       end\nPosition 1 is N\nPosition 7 is R\nPosition 10 is Y\n\njulia> # Iterate over each non-ambiguous residue\n\njulia> for (pos, nuc) in each(iscertain, dna_seq)\n           println(\"Position $pos is $nuc\")\n       end\nPosition 2 is A\nPosition 3 is T\nPosition 4 is T\nPosition 5 is C\nPosition 6 is G\nPosition 8 is A\nPosition 9 is T\n","category":"page"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"random/#Generating-random-sequences-1","page":"Random sequences","title":"Generating random sequences","text":"","category":"section"},{"location":"random/#Long-sequences-1","page":"Random sequences","title":"Long sequences","text":"","category":"section"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"You can generate random long sequences using the randdna function and the Sampler's implemented in BioSequences:","category":"page"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"randseq\nranddnaseq\nrandrnaseq\nrandaaseq\nSamplerUniform\nSamplerWeighted","category":"page"},{"location":"random/#BioSequences.randseq","page":"Random sequences","title":"BioSequences.randseq","text":"randseq([rng::AbstractRNG], A::Alphabet, sp::Sampler, len::Integer)\n\nGenerate a LongSequence{A} of length len with elements drawn from the given sampler.\n\nExample:\n\n# Generate 1000-length RNA with 4% chance of N, 24% for A, C, G, or U\njulia> sp = SamplerWeighted(rna\"ACGUN\", fill(0.24, 4))\njulia> seq = randseq(RNAAlphabet{4}(), sp, 50)\n50nt RNA Sequence:\nCUNGGGCCCGGGNAAACGUGGUACACCCUGUUAAUAUCAACNNGCGCUNU\n\n\n\n\n\nrandseq([rng::AbstractRNG], A::Alphabet, len::Integer)\n\nGenerate a LongSequence{A} of length len from the specified alphabet, drawn from the default distribution. User-defined alphabets should implement this method to implement random LongSequence generation.\n\nFor RNA and DNA alphabets, the default distribution is uniform across A, C, G, and T/U. For AminoAcidAlphabet, it is uniform across the 20 standard amino acids. For a user-defined alphabet A, default is uniform across all elements of symbols(A).\n\nExample:\n\njulia> seq = randseq(AminoAcidAlphabet(), 50)\n50aa Amino Acid Sequence:\nVFMHSIRMIRLMVHRSWKMHSARHVNFIRCQDKKWKSADGIYTDICKYSM\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randdnaseq","page":"Random sequences","title":"BioSequences.randdnaseq","text":"randdnaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{DNAAlphabet{4}} sequence of length len, with bases sampled uniformly from [A, C, G, T]\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randrnaseq","page":"Random sequences","title":"BioSequences.randrnaseq","text":"randrnaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{RNAAlphabet{4}} sequence of length len, with bases sampled uniformly from [A, C, G, U]\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randaaseq","page":"Random sequences","title":"BioSequences.randaaseq","text":"randaaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{AminoAcidAlphabet} sequence of length len, with amino acids sampled uniformly from the 20 standard amino acids.\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.SamplerUniform","page":"Random sequences","title":"BioSequences.SamplerUniform","text":"SamplerUniform{T}\n\nUniform sampler of type T. Instantiate with a collection of eltype T containing the elements to sample.\n\nExamples\n\njulia> sp = SamplerUniform(rna\"ACGU\");\n\n\n\n\n\n","category":"type"},{"location":"random/#BioSequences.SamplerWeighted","page":"Random sequences","title":"BioSequences.SamplerWeighted","text":"SamplerWeighted{T}\n\nWeighted sampler of type T. Instantiate with a collection of eltype T containing the elements to sample, and an orderen collection of probabilities to sample each element except the last. The last probability is the remaining probability up to 1.\n\nExamples\n\njulia> sp = SamplerWeighted(rna\"ACGUN\", fill(0.2475, 4));\n\n\n\n\n\n","category":"type"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"transforms/#Indexing-and-modifying-sequences-1","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"","category":"section"},{"location":"transforms/#Indexing-1","page":"Indexing & modifying sequences","title":"Indexing","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Most BioSequence concrete subtypes for the most part behave like other vector or string types. They can be indexed using integers or ranges:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"For example, with LongSequences:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTTTANAGTNNAGTACC\"\n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia> seq[5]\nDNA_T\n\njulia> seq[6:end]\n14nt DNA Sequence:\nTANAGTNNAGTACC\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"The biological symbol at a given locus in a biological sequence can be set using setindex:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTTTANAGTNNAGTACC\"\n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia> seq[5] = DNA_A\nDNA_A\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"note: Note\nSome types such as Kmer can be indexed using integers but not using ranges.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"For LongSequence types, indexing a sequence by range creates a copy of the original sequence, similar to Array in Julia's Base library. If you find yourself slowed down by the allocation of these subsequences, consider using a sequence view instead.","category":"page"},{"location":"transforms/#Modifying-sequences-1","page":"Indexing & modifying sequences","title":"Modifying sequences","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"In addition to setindex, many other modifying operations are possible for biological sequences such as push!, pop!, and insert!, which should be familiar to anyone used to editing arrays.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"push!\npop!\npushfirst!\npopfirst!\ninsert!\ndeleteat!(::BioSequences.BioSequence, ::Integer)\nappend!\nresize!\nempty!","category":"page"},{"location":"transforms/#Base.push!","page":"Indexing & modifying sequences","title":"Base.push!","text":"push!(collection, items...) -> collection\n\nInsert one or more items in collection. If collection is an ordered container, the items are inserted at the end (in the given order).\n\nExamples\n\njulia> push!([1, 2, 3], 4, 5, 6)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nIf collection is ordered, use append! to add all the elements of another collection to it. The result of the preceding example is equivalent to append!([1, 2, 3], [4, 5, 6]). For AbstractSet objects, union! can be used instead.\n\nSee sizehint! for notes about the performance model.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.pop!","page":"Indexing & modifying sequences","title":"Base.pop!","text":"pop!(collection) -> item\n\nRemove an item in collection and return it. If collection is an ordered container, the last item is returned; for unordered containers, an arbitrary element is returned.\n\nExamples\n\njulia> A=[1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> pop!(A)\n3\n\njulia> A\n2-element Vector{Int64}:\n 1\n 2\n\njulia> S = Set([1, 2])\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> pop!(S)\n2\n\njulia> S\nSet{Int64} with 1 element:\n  1\n\njulia> pop!(Dict(1=>2))\n1 => 2\n\n\n\n\n\npop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\npop!(seq::BioSequence)\n\nRemove the symbol from the end of a biological sequence seq and return it. Returns a variable of eltype(seq).\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.pushfirst!","page":"Indexing & modifying sequences","title":"Base.pushfirst!","text":"pushfirst!(collection, items...) -> collection\n\nInsert one or more items at the beginning of collection.\n\nExamples\n\njulia> pushfirst!([1, 2, 3, 4], 5, 6)\n6-element Vector{Int64}:\n 5\n 6\n 1\n 2\n 3\n 4\n\n\n\n\n\npushfirst!(seq, x)\n\nInsert a biological symbol x at the beginning of a biological sequence seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.popfirst!","page":"Indexing & modifying sequences","title":"Base.popfirst!","text":"popfirst!(collection) -> item\n\nRemove the first item from collection.\n\nExamples\n\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> popfirst!(A)\n1\n\njulia> A\n5-element Vector{Int64}:\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\npopfirst!(seq)\n\nRemove the symbol from the beginning of a biological sequence seq and return it. Returns a variable of eltype(seq).\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.insert!","page":"Indexing & modifying sequences","title":"Base.insert!","text":"insert!(a::Vector, index::Integer, item)\n\nInsert an item into a at the given index. index is the index of item in the resulting a.\n\nExamples\n\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\ninsert!(seq::BioSequence, i, x)\n\nInsert a biological symbol x into a biological sequence seq, at the given index i.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.deleteat!-Tuple{BioSequence, Integer}","page":"Indexing & modifying sequences","title":"Base.deleteat!","text":"deleteat!(seq::BioSequence, i::Integer)\n\nDelete a biological symbol at a single position i in a biological sequence seq.\n\nModifies the input sequence.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#Base.append!","page":"Indexing & modifying sequences","title":"Base.append!","text":"append!(collection, collections...) -> collection.\n\nFor an ordered container collection, add the elements of each collections to the end of it.\n\ncompat: Julia 1.6\nSpecifying multiple collections to be appended requires at least Julia 1.6.\n\nExamples\n\njulia> append!([1], [2, 3])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> append!([1, 2, 3], [4, 5], [6])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse push! to add individual items to collection which are not already themselves in another collection. The result of the preceding example is equivalent to push!([1, 2, 3], 4, 5, 6).\n\nSee sizehint! for notes about the performance model.\n\n\n\n\n\nappend!(seq, other)\n\nAdd a biological sequence other onto the end of biological sequence seq. Modifies and returns seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.resize!","page":"Indexing & modifying sequences","title":"Base.resize!","text":"resize!(a::Vector, n::Integer) -> Vector\n\nResize a to contain n elements. If n is smaller than the current collection length, the first n elements will be retained. If n is larger, the new elements are not guaranteed to be initialized.\n\nExamples\n\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Vector{Int64}:\n 6\n 5\n 4\n\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\n\njulia> length(a)\n8\n\njulia> a[1:6]\n6-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\nresize!(seq, size, [force::Bool])\n\nResize a biological sequence seq, to a given size. Does not resize the underlying data array unless the new size does not fit. If force, always resize underlying data array.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.empty!","page":"Indexing & modifying sequences","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String, Int64}()\n\n\n\n\n\nempty!(seq::BioSequence)\n\nCompletely empty a biological sequence seq of nucleotides.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Here are some examples:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACG\"\n3nt DNA Sequence:\nACG\n\njulia> push!(seq, DNA_T)\n4nt DNA Sequence:\nACGT\n\njulia> append!(seq, dna\"AT\")\n6nt DNA Sequence:\nACGTAT\n\njulia> deleteat!(seq, 2)\n5nt DNA Sequence:\nAGTAT\n\njulia> deleteat!(seq, 2:3)\n3nt DNA Sequence:\nAAT\n","category":"page"},{"location":"transforms/#Additional-transformations-1","page":"Indexing & modifying sequences","title":"Additional transformations","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"In addition to these basic modifying functions, other sequence transformations that are common in bioinformatics are also provided.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"reverse!(::BioSequences.LongSequence)\nreverse(::BioSequences.LongSequence{<:NucleicAcidAlphabet})\ncomplement!\ncomplement\nreverse_complement!\nreverse_complement\nungap!\nungap\ncanonical!\ncanonical","category":"page"},{"location":"transforms/#Base.reverse!-Tuple{LongSequence}","page":"Indexing & modifying sequences","title":"Base.reverse!","text":"reverse!(seq::LongSequence)\n\nReverse a biological sequence seq in place.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#Base.reverse-Tuple{LongSequence{var\"#s2\"} where var\"#s2\"<:NucleicAcidAlphabet}","page":"Indexing & modifying sequences","title":"Base.reverse","text":"reverse(seq::BioSequence)\n\nCreate reversed copy of a biological sequence.\n\n\n\n\n\nreverse(seq::LongSequence)\n\nCreate reversed copy of a biological sequence.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#BioSequences.complement!","page":"Indexing & modifying sequences","title":"BioSequences.complement!","text":"complement!(seq)\n\nMake a complement sequence of seq in place.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSymbols.complement","page":"Indexing & modifying sequences","title":"BioSymbols.complement","text":"complement(nt::NucleicAcid)\n\nReturn the complementary nucleotide of nt.\n\nThis function returns the union of all possible complementary nucleotides.\n\nExamples\n\njulia> complement(DNA_A)\nDNA_T\n\njulia> complement(DNA_N)\nDNA_N\n\njulia> complement(RNA_U)\nRNA_A\n\n\n\n\n\n\ncomplement(seq)\n\nMake a complement sequence of seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.reverse_complement!","page":"Indexing & modifying sequences","title":"BioSequences.reverse_complement!","text":"reverse_complement!(seq)\n\nMake a reversed complement sequence of seq in place.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.reverse_complement","page":"Indexing & modifying sequences","title":"BioSequences.reverse_complement","text":"reverse_complement(seq)\n\nMake a reversed complement sequence of seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ungap!","page":"Indexing & modifying sequences","title":"BioSequences.ungap!","text":"Remove gap characters from an input sequence.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ungap","page":"Indexing & modifying sequences","title":"BioSequences.ungap","text":"Create a copy of a sequence with gap characters removed.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.canonical!","page":"Indexing & modifying sequences","title":"BioSequences.canonical!","text":"canonical!(seq::NucleotideSeq)\n\nTransforms the seq into its canonical form, if it is not already canonical. Modifies the input sequence inplace.\n\nFor any sequence, there is a reverse complement, which is the same sequence, but on the complimentary strand of DNA:\n\n------->\nATCGATCG\nCGATCGAT\n<-------\n\nnote: Note\nUsing the reverse_complement of a DNA sequence will give give this reverse complement.\n\nOf the two sequences, the canonical of the two sequences is the lesser of the two i.e. canonical_seq < other_seq.\n\nUsing this function on a seq will ensure it is the canonical version.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.canonical","page":"Indexing & modifying sequences","title":"BioSequences.canonical","text":"canonical(seq::NucleotideSeq)\n\nCreate the canonical sequence of seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Some examples:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTAT\"\n6nt DNA Sequence:\nACGTAT\n\njulia> reverse!(seq)\n6nt DNA Sequence:\nTATGCA\n\njulia> complement!(seq)\n6nt DNA Sequence:\nATACGT\n\njulia> reverse_complement!(seq)\n6nt DNA Sequence:\nACGTAT\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Many of these methods also have a version which makes a copy of the input sequence, so you get a modified copy, and don't alter the original sequence. Such methods are named the same, but without the exclamation mark. E.g. reverse instead of reverse!, and ungap instead of ungap!.  ","category":"page"},{"location":"transforms/#Translation-1","page":"Indexing & modifying sequences","title":"Translation","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Translation is a slightly more complex transformation for RNA Sequences and so we describe it here in more detail.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"The translate function translates a sequence of codons in a RNA sequence to a amino acid sequence based on a genetic code. The BioSequences package provides all NCBI defined genetic codes and they are registered in ncbi_trans_table.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"translate\nncbi_trans_table","category":"page"},{"location":"transforms/#BioSequences.translate","page":"Indexing & modifying sequences","title":"BioSequences.translate","text":"translate(seq, code=standard_genetic_code, allow_ambiguous_codons=true, convert_start_codon=false)\n\nTranslate an LongRNASeq or a LongDNASeq to an LongAASeq.\n\nTranslation uses genetic code code to map codons to amino acids. See ncbi_trans_table for available genetic codes. If codons in the given sequence cannot determine a unique amino acid, they will be translated to AA_X if allow_ambiguous_codons is true and otherwise result in an error. For organisms that utilize alternative start codons, one can set alternative_start=true, in which case the first codon will always be converted to a methionine.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ncbi_trans_table","page":"Indexing & modifying sequences","title":"BioSequences.ncbi_trans_table","text":"Genetic code list of NCBI.\n\nThe standard genetic code is ncbi_trans_table[1] and others can be shown by show(ncbi_trans_table). For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.\n\n\n\n\n\n","category":"constant"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> ncbi_trans_table\nTranslation Tables:\n  1. The Standard Code (standard_genetic_code)\n  2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)\n  3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)\n  4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)\n  5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)\n  6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)\n  9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)\n 10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)\n 11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)\n 12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)\n 13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)\n 14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)\n 16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)\n 21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)\n 22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)\n 23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)\n 24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)\n 25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#Construction-and-conversion-1","page":"Constructing sequences","title":"Construction & conversion","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Here we will showcase the various ways you can construct the various sequence types in BioSequences.","category":"page"},{"location":"construction/#Constructing-sequences-1","page":"Constructing sequences","title":"Constructing sequences","text":"","category":"section"},{"location":"construction/#From-strings-1","page":"Constructing sequences","title":"From strings","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be constructed from strings using their constructors:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq(\"TTANC\")\n5nt DNA Sequence:\nTTANC\n\njulia> LongSequence{DNAAlphabet{2}}(\"TTAGC\")\n5nt DNA Sequence:\nTTAGC\n\njulia> LongRNASeq(\"UUANC\")\n5nt RNA Sequence:\nUUANC\n\njulia> LongSequence{RNAAlphabet{2}}(\"UUAGC\")\n5nt RNA Sequence:\nUUAGC\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"note: Note\nFrom version 2.0 onwards, the convert methods for converting a string or vector of symbols into a sequence type have been removed. These convert methods did nothing but pass their arguments to the appropriate constructor.These specific convert methods have been removed due to the semantics of convert: Even though convert(LongDNASeq, \"ATCG\") was previously the same as LongDNASeq(\"ATCG\"), unlike constructors, convert is sometimes implicitly called. So it's methods should be restricted to cases that are considered safe or unsurprising. convert should convert between types that represent the same basic kind of thing, like different representations of numbers. It is also usually lossless. Not all strings are valid sequences, and depending on the sequence type, not all vectors of BioSymbols are valid sequences either. A string only represents the \"same kind of thing\" as a biological sequence in some cases, so implicitly converting them to a sequence type was never safe or unsurprising. These convert methods have been renamed to Base.parse methods.","category":"page"},{"location":"construction/#Constructing-sequences-from-arrays-of-BioSymbols-1","page":"Constructing sequences","title":"Constructing sequences from arrays of BioSymbols","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be constructed using vectors or arrays of a BioSymbol type:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq([DNA_T, DNA_T, DNA_A, DNA_N, DNA_C])\n5nt DNA Sequence:\nTTANC\n\njulia> LongSequence{DNAAlphabet{2}}([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\n5nt DNA Sequence:\nTTAGC\n\njulia> DNAMer{5}([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\nDNA 5-mer:\nTTAGC\n\njulia> RNAMer{5}([RNA_U, RNA_U, RNA_A, RNA_G, RNA_C])\nRNA 5-mer:\nUUAGC\n\njulia> # Works, but is not type-stable\n\njulia> DNAMer([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\nDNA 5-mer:\nTTAGC\n\njulia> RNAMer([RNA_U, RNA_U, RNA_A, RNA_G, RNA_C])\nRNA 5-mer:\nUUAGC","category":"page"},{"location":"construction/#Constructing-sequences-from-other-sequences-1","page":"Constructing sequences","title":"Constructing sequences from other sequences","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You can create sequences, by concatenating other sequences together:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq(LongDNASeq(\"ACGT\"), LongDNASeq(\"NNNN\"), LongDNASeq(\"TGCA\"))\n12nt DNA Sequence:\nACGTNNNNTGCA\n\njulia> LongDNASeq(\"ACGT\") * LongDNASeq(\"TGCA\")\n8nt DNA Sequence:\nACGTTGCA\n\njulia> repeat(LongDNASeq(\"TA\"), 10)\n20nt DNA Sequence:\nTATATATATATATATATATA\n\njulia> LongDNASeq(\"TA\") ^ 10\n20nt DNA Sequence:\nTATATATATATATATATATA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You can also construct long sequences from kmer sequences, and vice versa:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> m = DNAMer{5}([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\nDNA 5-mer:\nTTAGC\n\njulia> LongSequence(m)\n5nt DNA Sequence:\nTTAGC\n\njulia> # round trip from mer to long sequence back to mer.\n\njulia> DNAMer(LongSequence(m))\nDNA 5-mer:\nTTAGC","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequence views (LongSubSeqs) are special, in that they do not own their own data, and must be constructed from a LongSequence or another LongSubSeq:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> seq = LongDNASeq(\"TACGGACATTA\")\n11nt DNA Sequence:\nTACGGACATTA\n\njulia> seqview = LongSubSeq(seq, 3:7)\n5nt DNA Sequence:\nCGGAC\n\njulia> seqview2 = @view seq[1:3]\n3nt DNA Sequence:\nTAC\n\njulia> typeof(seqview) == typeof(seqviev2) && typeof(seqview) <: LongSubSeq\ntrue\n","category":"page"},{"location":"construction/#Conversion-of-sequence-types-1","page":"Constructing sequences","title":"Conversion of sequence types","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sometimes you can convert between sequence types without construction / having to copy data. for example, despite being separate types, LongDNASeq and LongRNASeq can freely be converted between efficiently, without copying the underlying data:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna = dna\"TTANGTAGACCG\"\n12nt DNA Sequence:\nTTANGTAGACCG\n\njulia> rna = convert(LongRNASeq, dna)\n12nt RNA Sequence:\nUUANGUAGACCG\n\njulia> dna.data === rna.data  # underlying data are same\ntrue\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be converted explicitly and implicitly, into arrays and strings:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna = dna\"TTANGTAGACCG\"\n12nt DNA Sequence:\nTTANGTAGACCG\n\njulia> dnastr = convert(String, dna)\n\"TTANGTAGACCG\"\n\njulia> # Implicit conversion to string - putting dna sequence in String vector \n\njulia> arr = String[dna]\n1-element Array{String,1}:\n \"TTANGTAGACCG\"\n ","category":"page"},{"location":"construction/#String-literals-1","page":"Constructing sequences","title":"String literals","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"BioSequences provides several string literal macros for creating sequences.","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"note: Note\nWhen you use literals you may mix the case of characters.","category":"page"},{"location":"construction/#Long-sequence-literals-1","page":"Constructing sequences","title":"Long sequence literals","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna\"TACGTANNATC\"\n11nt DNA Sequence:\nTACGTANNATC\n\njulia> rna\"AUUUGNCCANU\"\n11nt RNA Sequence:\nAUUUGNCCANU\n\njulia> aa\"ARNDCQEGHILKMFPSTWYVX\"\n21aa Amino Acid Sequence:\nARNDCQEGHILKMFPSTWYVX","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"However, it should be noted that by default these sequence literals allocate the LongSequence object before the code containing the sequence literal is run. This means there may be occasions where your program does not behave as you first expect. For example consider the following code:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> function foo()\n           s = dna\"CTT\"\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"d\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You might expect that every time you call foo, that a DNA sequence CTTA would be returned. You might expect that this is because every time foo is called, a new DNA sequence variable CTT is created, and the A nucleotide is pushed to it, and the result, CTTA is returned. In other words you might expect the following output:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"However, this is not what happens, instead the following happens:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"s\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n5nt DNA Sequence:\nCTTAA\n\njulia> foo()\n6nt DNA Sequence:\nCTTAAA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"The reason for this is because the sequence literal is allocated only once before the first time the function foo is called and run. Therefore, s in foo is always a reference to that one sequence that was allocated. So one sequence is created before foo is called, and then it is pushed to every time foo is called. Thus, that one allocated sequence grows with every call of foo.","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"If you wanted foo to create a new sequence each time it is called, then you can add a flag to the end of the sequence literal to dictate behaviour: A flag of 's' means 'static': the sequence will be allocated before code is run, as is the default behaviour described above. However providing 'd' flag changes the behaviour: 'd' means 'dynamic': the sequence will be allocated whilst the code is running, and not before. So to change foo so as it creates a new sequence each time it is called, simply add the 'd' flag to the sequence literal:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> function foo()\n           s = dna\"CTT\"d     # 'd' flag appended to the string literal.\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Now every time foo is called, a new sequence CTT is created, and an A nucleotide is pushed to it:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"d\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"So the take home message of sequence literals is this:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Be careful when you are using sequence literals inside of functions, and inside the bodies of things like for loops. And if you use them and are unsure, use the  's' and 'd' flags to ensure the behaviour you get is the behaviour you intend.","category":"page"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"dev_docs/symbols/#Biological-symbols:-Developer-Information-1","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"","category":"section"},{"location":"dev_docs/symbols/#Bit-encoding-of-biological-symbols-1","page":"Biological symbols: Developer Information","title":"Bit encoding of biological symbols","text":"","category":"section"},{"location":"dev_docs/symbols/#Nucleic-acids-(DNA-and-RNA)-1","page":"Biological symbols: Developer Information","title":"Nucleic acids (DNA and RNA)","text":"","category":"section"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"Every nucleotide is encoded using the lower 4 bits of a byte. An unambiguous nucleotide has only one set bit and the other bits are unset. The table below summarises all unambiguous nucleotides and their corresponding bits. An ambiguous nucleotide is the bitwise OR of unambiguous nucleotides that the ambiguous nucleotide can take. For example, DNA_R (meaning the nucleotide is either DNA_A or DNA_G) is encoded as 0101 because 0101 is the bitwise OR of 0001 (DNA_A) and 0100 (DNA_G). The gap symbol is always 0000.","category":"page"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"NucleicAcid Bits\nDNA_A, RNA_A 0001\nDNA_C, RNA_C 0010\nDNA_G, RNA_G 0100\nDNA_T, RNA_U 1000","category":"page"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"The next few examples demonstrate some of the bit operations of DNA to illustrate:","category":"page"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"julia> bitstring(reinterpret(UInt8, DNA_A))\n\"00000001\"\n\njulia> bitstring(reinterpret(UInt8, DNA_G))\n\"00000100\"\n\njulia> bitstring(reinterpret(UInt8, DNA_R))\n\"00000101\"\n\njulia> bitstring(reinterpret(UInt8, DNA_B))\n\"00001110\"\n\njulia> ~DNA_A\nDNA_B\n\njulia> DNA_A | DNA_G\nDNA_R\n\njulia> DNA_R & DNA_B\nDNA_G\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"sequence_search/#Sequence-search-1","page":"Pattern matching and searching","title":"Sequence search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Three kinds of on-line search functions are provided:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Exact search\nApproximate search\nRegular expression search","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"These are all specialized for biological sequences and ambiguities of symbols are considered.","category":"page"},{"location":"sequence_search/#Exact-search-1","page":"Pattern matching and searching","title":"Exact search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Similar to other Julia sequences like Vector, a BioSequence can be searched using a function. This returns the index of the element matching where the function returns true, or nothing if no elements were found:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> findfirst(isequal(DNA_A), dna\"GCTTAG\")\n5\n\njulia> findfirst(isequal(DNA_M), dna\"GCTTAG\") === nothing\ntrue","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Sequences may also be effectively searched for the occurence of subsequences:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\";\n\njulia> query = dna\"AGC\";\n\njulia> findfirst(query, seq)\n3:5\n\njulia> findlast(query, seq)\n8:10\n\njulia> occursin(query, seq)\ntrue","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"These search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g. DNA_A and DNA_N), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> findfirst(dna\"CGT\", dna\"ACNT\")  # 'N' matches 'G'\n2:4\n\njulia> findfirst(dna\"CNT\", dna\"ACGT\")  # 'G' matches 'N'\n2:4\n\njulia> occursin(dna\"CNT\", dna\"ACNT\")\ntrue","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The exact sequence search needs a preprocessing phase of query sequence before the searching phase. This would be fast enough for most search applications. But when searching a query sequence to many target sequences, caching the result of preprocessing may save time. You can do this by creating an ExactSearchQuery object and re-use it for each search:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> query = ExactSearchQuery(dna\"ATT\");\n\njulia> findfirst(query, dna\"ATTTATT\")\n1:3\n\njulia> findlast(query, dna\"ATTTATT\")\n5:7\n\njulia> occursin(query, dna\"ATTTATT\")\ntrue","category":"page"},{"location":"sequence_search/#Approximate-search-1","page":"Pattern matching and searching","title":"Approximate search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific Levenshtein distance of the query sequence:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\";\n\njulia> approxsearch(seq, dna\"AGGG\", 0)  # nothing matches with no errors\n0:-1\n\njulia> approxsearch(seq, dna\"AGGG\", 1)  # seq[3:6] matches with one error\n3:6\n\njulia> approxsearch(seq, dna\"AGGG\", 2)  # seq[1:4] matches with two errors\n1:4\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Like the exact search functions, four kinds of functions (approxsearch, approxsearchindex, approxrsearch, and approxrsearchindex) are available:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\"; pat = dna\"AGGG\";\n\njulia> approxsearch(seq, pat, 2)        # return the range (forward)\n1:4\n\njulia> approxsearchindex(seq, pat, 2)   # return the starting index (forward)\n1\n\njulia> approxrsearch(seq, pat, 2)       # return the range (backward)\n8:11\n\njulia> approxrsearchindex(seq, pat, 2)  # return the starting index (backward)\n8\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Preprocessing can be cached in an ApproximateSearchQuery object:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> query = ApproximateSearchQuery(dna\"AGGG\");\n\njulia> approxsearch(dna\"AAGAGG\", query, 1)\n2:5\n\njulia> approxsearch(dna\"ACTACGT\", query, 2)\n4:6\n","category":"page"},{"location":"sequence_search/#Regular-expression-search-1","page":"Pattern matching and searching","title":"Regular expression search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Query patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The Perl-like syntax starts with biore (BIOlogical REgular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example, biore\"A+\"dna is a regular expression for DNA sequences and biore\"A+\"aa is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Here are examples of using the regular expression for BioSequences:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> match(biore\"A+C*\"dna, dna\"AAAACC\")\nRegexMatch(\"AAAACC\")\n\njulia> match(biore\"A+C*\"d, dna\"AAAACC\")\nRegexMatch(\"AAAACC\")\n\njulia> occursin(biore\"A+C*\"dna, dna\"AAC\")\ntrue\n\njulia> occursin(biore\"A+C*\"dna, dna\"C\")\nfalse\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"match will return a RegexMatch if a match is found, otherwise it will return nothing if no match is found.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The table below summarizes available syntax elements.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Syntax Description Example\n| alternation \"A|T\" matches \"A\" and \"T\"\n* zero or more times repeat \"TA*\" matches \"T\", \"TA\" and \"TAA\"\n+ one or more times repeat \"TA+\" matches \"TA\" and \"TAA\"\n? zero or one time \"TA?\" matches \"T\" and \"TA\"\n{n,} n or more times repeat \"A{3,}\" matches \"AAA\" and \"AAAA\"\n{n,m} n-m times repeat \"A{3,5}\" matches \"AAA\", \"AAAA\" and \"AAAAA\"\n^ the start of the sequence \"^TAN*\" matches \"TATGT\"\n$ the end of the sequence \"N*TA$\" matches \"GCTA\"\n(...) pattern grouping \"(TA)+\" matches \"TA\" and \"TATA\"\n[...] one of symbols \"[ACG]+\" matches \"AGGC\"","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"eachmatch and findfirst are also defined like usual strings:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> collect(matched(x) for x in eachmatch(biore\"TATA*?\"d, dna\"TATTATAATTA\")) # overlap\n4-element Array{LongSequence{DNAAlphabet{4}},1}:\n TAT  \n TAT\n TATA\n TATAA\n\njulia> collect(matched(x) for x in eachmatch(biore\"TATA*\"d, dna\"TATTATAATTA\", false)) # no overlap\n2-element Array{LongSequence{DNAAlphabet{4}},1}:\n TAT  \n TATAA\n\njulia> findfirst(biore\"TATA*\"d, dna\"TATTATAATTA\")\n1:3\n\njulia> findfirst(biore\"TATA*\"d, dna\"TATTATAATTA\", 2)\n4:8\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Noteworthy differences from strings are:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Ambiguous characters match any compatible characters (e.g. biore\"N\"d is equivalent to biore\"[ACGT]\"d).\nWhitespaces are ignored (e.g. biore\"A C G\"d is equivalent to biore\"ACG\"d).","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The PROSITE notation is described in ScanProsite - user manual. The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with prosite prefix and no symbol option is needed because it always describes patterns of amino acid sequences:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> match(prosite\"[AC]-x-V-x(4)-{ED}\", aa\"CPVPQARG\")\nRegexMatch(\"CPVPQARG\")\n\njulia> match(prosite\"[AC]xVx(4){ED}\", aa\"CPVPQARG\")\nRegexMatch(\"CPVPQARG\")\n","category":"page"},{"location":"sequence_search/#Position-weight-matrix-search-1","page":"Pattern matching and searching","title":"Position weight matrix search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"A motif can also be specified using position weight matrix (PWM) in a probabilistic way. search(seq, pwm, threshold) method searches for the first position in the sequence where a score calculated using the PWM is greater than or equal to the threshold. More formally, denoting the sequence as S and the PWM value of symbol s at position j as M_sj, the score starting from a position p is defined as","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"operatornamescore(S p) = sum_i=1^L M_Sp+i-1i","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"and search(S, M, t) returns the smallest p that satisfies operatornamescore(S p) ge t.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"There are two kinds of matrices in this package: PFM and PWM. The PFM type is a position frequency matrix and stores symbol frequencies for each position. The PWM is a position weight matrix and stores symbol scores for each position. You can create a PFM from a set of sequences with the same length and then create a PWM from the PFM object.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> kmers = DNAMer.([\"TTA\", \"CTA\", \"ACA\", \"TCA\", \"GTA\"])\n5-element Array{Mer{DNAAlphabet{2},3},1}:\n TTA\n CTA\n ACA\n TCA\n GTA\n\njulia> pfm = PFM(kmers)  # sequence set => PFM\n4×3 PFM{DNA,Int64}:\n A  1  0  5\n C  1  2  0\n G  1  0  0\n T  2  3  0\n\njulia> pwm = PWM(pfm)  # PFM => PWM\n4×3 PWM{DNA,Float64}:\n A -0.321928 -Inf       2.0\n C -0.321928  0.678072 -Inf\n G -0.321928 -Inf      -Inf\n T  0.678072  1.26303  -Inf\n\njulia> pwm = PWM(pfm .+ 0.01)  # add pseudo counts to avoid infinite values\n4×3 PWM{DNA,Float64}:\n A -0.319068 -6.97728   1.99139\n C -0.319068  0.673772 -6.97728\n G -0.319068 -6.97728  -6.97728\n T  0.673772  1.25634  -6.97728\n\njulia> pwm = PWM(pfm .+ 0.01, prior=[0.2, 0.3, 0.3, 0.2])  # GC-rich prior\n4×3 PWM{DNA,Float64}:\n A  0.00285965 -6.65535   2.31331\n C -0.582103    0.410737 -7.24031\n G -0.582103   -7.24031  -7.24031\n T  0.9957      1.57827  -6.65535\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The PWM_sj matrix is computed from PFM_sj and the prior probability p(s) as follows ([Wasserman2004]):","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"beginalign\n    PWM_sj = log_2 fracp(sj)p(s) \n    p(sj)  = fracPFM_sjsum_s PFM_sj\nendalign","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"[Wasserman2004]: https://doi.org/10.1038/nrg1315","category":"page"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"predicates/#Predicates-1","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"A number of predicate or query functions are supported for sequences, allowing you to check for certain properties of a sequence.","category":"page"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"isrepetitive\nispalindromic\nhasambiguity\niscanonical","category":"page"},{"location":"predicates/#BioSequences.isrepetitive","page":"Predicates","title":"BioSequences.isrepetitive","text":"isrepetitive(seq::BioSequence, n::Integer=length(seq))\n\nReturn true if and only if seq contains a repetitive subsequence of length ≥ n.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.ispalindromic","page":"Predicates","title":"BioSequences.ispalindromic","text":"ispalindromic(seq::BioSequence)\n\nReturn true if seq is a palindromic sequence; otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.hasambiguity","page":"Predicates","title":"BioSequences.hasambiguity","text":"hasambiguity(seq::BioSequence)\n\nReturns true if seq has an ambiguous symbol; otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.iscanonical","page":"Predicates","title":"BioSequences.iscanonical","text":"iscanonical(seq::NucleotideSeq)\n\nReturns true if seq is canonical.\n\nFor any sequence, there is a reverse complement, which is the same sequence, but on the complimentary strand of DNA:\n\n------->\nATCGATCG\nCGATCGAT\n<-------\n\nnote: Note\nUsing the reverse_complement of a DNA sequence will give give this reverse complement.\n\nOf the two sequences, the canonical of the two sequences is the lesser of the two i.e. canonical_seq < other_seq.\n\n\n\n\n\n","category":"function"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"dev_docs/sequences/biosequence/#On-concrete-biological-sequence-types...-1","page":"-","title":"On concrete biological sequence types...","text":"","category":"section"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"Sequences in BioSequences.jl are more strictly typed than in many other libraries; Elements in a sequence are typed as biological symbol instead of character or byte. They are special-purpose types rather than simply strings and hence offer additional functionality that naive string types don't have.","category":"page"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"Though this strictness sacrifices some convenience, it also means you can always rely on a DNA sequence type to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on.","category":"page"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using either four bits per base (which is the default), or two bits per base. This makes them memory efficient and allows us to speed up many common operations and transformations, like reverse complement, and k-mer enumeration.","category":"page"},{"location":"dev_docs/sequences/biosequence/#Defining-a-new-alphabet-1","page":"-","title":"Defining a new alphabet","text":"","category":"section"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"The alphabet type parameter A of BioSequence{A} enables a user to extend functionality of BioSequence with minimum effort. As an example, definition of a new alphabet type representing a sequence of boolean values is shown below:","category":"page"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"julia> immutable BoolAlphabet <: Alphabet end\n\njulia> BioSequences.bitsof(::Type{BoolAlphabet}) = 1\n\njulia> BioSequences.eltype(::Type{BoolAlphabet}) = Bool\n\njulia> BioSequences.alphabet(::Type{BoolAlphabet}) = false:true\n\njulia> function BioSequences.encode(::Type{BoolAlphabet}, x::Bool)\n           return UInt64(ifelse(x, 0x01, 0x00))\n       end\n\njulia> function BioSequences.decode(::Type{BoolAlphabet}, x::UInt64)\n           if x > 0x01\n               throw(BioSequences.DecodeError(BoolAlphabet, x))\n           end\n           return ifelse(x == 0x00, false, true)\n       end\n","category":"page"},{"location":"#BioSequences-1","page":"Home","title":"BioSequences","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Latest Release) (Image: MIT license) (Image: Documentation) (Image: Pkg Status) (Image: Chat)","category":"page"},{"location":"#Description-1","page":"Home","title":"Description","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BioSequences provides data types and methods for common operations with biological sequences, including DNA, RNA, and amino acid sequences.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can install BioSequences from the julia REPL. Press ] to enter pkg mode again, and enter the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add BioSequences","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.","category":"page"},{"location":"#Testing-1","page":"Home","title":"Testing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BioSequences is tested against Julia 1.X on Linux, OS X, and Windows.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Unit tests) (Image: Documentation) (Image: )","category":"page"},{"location":"#Contributing-1","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Take a look at the contributing files detailed contributor and maintainer guidelines, and code of conduct.","category":"page"},{"location":"#Financial-contributions-1","page":"Home","title":"Financial contributions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We also welcome financial contributions in full transparency on our open collective. Anyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.","category":"page"},{"location":"#Backers-and-Sponsors-1","page":"Home","title":"Backers & Sponsors","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Thank you to all our backers and sponsors!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Love our work and community? Become a backer.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: backers)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Does your company use BioJulia? Help keep BioJulia feature rich and healthy by sponsoring the project Your logo will show up here with a link to your website.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"#Questions?-1","page":"Home","title":"Questions?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you have a question about contributing or using BioJulia software, come on over and chat to us on Gitter, or you can try the Bio category of the Julia discourse site.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"types/#Sequence-Types-1","page":"BioSequences Types","title":"Sequence Types","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences exports an abstract BioSequence type, and several concrete sequence types which inherit from it.","category":"page"},{"location":"types/#The-abstract-BioSequence-1","page":"BioSequences Types","title":"The abstract BioSequence","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences provides an abstract type called a BioSequence{A<:Alphabet}. This abstract type, and the methods and traits is supports, allows for many algorithms in BioSequences to be written as generically as possible, thus reducing the amount of code to read and understand, whilst maintaining high performance when such code is compiled for a concrete BioSequence subtype. Additionally, it allows new types to be implemented that are fully compatible with the rest of BioSequences, providing that key methods or traits are defined).","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"This abstract type is parametric over concrete types of Alphabet, which define the range of symbols permitted in the sequence.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Some aliases are also provided for your convenience:","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Type alias Type\nNucleotideSeq BioSequence{<:NucleicAcidAlphabet}\nAminoAcidSeq BioSequence{AminoAcidAlphabet}","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Any concrete sequence type compatible with BioSequences must inherit from BioSequence{A}, where A is the alphabet of the concrete sequence type. It must also have the following methods defined for it:","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"encoded_data\nBase.length(::BioSequence)","category":"page"},{"location":"types/#BioSequences.encoded_data","page":"BioSequences Types","title":"BioSequences.encoded_data","text":"Return the data member of seq that stores the encoded sequence data.\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.length-Tuple{BioSequence}","page":"BioSequences Types","title":"Base.length","text":"Get the length of a biological sequence.\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"If these requirements are satisfied, the following key traits and methods backing the BioSequences interface, should be defined already for the sequence type.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"encoded_data_type\nencoded_data_eltype\nAlphabet(::BioSequence)\nBioSymbols.alphabet(::BioSequence)\nBitsPerSymbol\nbits_per_symbol","category":"page"},{"location":"types/#BioSequences.encoded_data_type","page":"BioSequences Types","title":"BioSequences.encoded_data_type","text":"Get the vector of bits storing a sequences packed encoded elements.\n\n\n\n\n\n","category":"function"},{"location":"types/#BioSequences.encoded_data_eltype","page":"BioSequences Types","title":"BioSequences.encoded_data_eltype","text":"Get the element type of the vector of bits storing a sequences packed encoded elements.\n\n\n\n\n\n","category":"function"},{"location":"types/#BioSequences.Alphabet-Tuple{BioSequence}","page":"BioSequences Types","title":"BioSequences.Alphabet","text":"Return the Alpahbet type that defines the biological symbols allowed for seq.\n\n\n\n\n\n","category":"method"},{"location":"types/#BioSymbols.alphabet-Tuple{BioSequence}","page":"BioSequences Types","title":"BioSymbols.alphabet","text":"Gets the alphabet encoding of a given BioSequence.\n\n\n\n\n\n","category":"method"},{"location":"types/#BioSequences.BitsPerSymbol","page":"BioSequences Types","title":"BioSequences.BitsPerSymbol","text":"The number of bits required to represent a packed symbol in a vector of bits.\n\n\n\n\n\n","category":"type"},{"location":"types/#BioSequences.bits_per_symbol","page":"BioSequences Types","title":"BioSequences.bits_per_symbol","text":"Get the number of bits each symbol packed into a BioSequence uses, as an integer value.\n\n\n\n\n\n","category":"function"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"As a result, the vast majority of methods described in the rest of this manual should work out of the box for the concrete sequence type. But they can always be overloaded if needed.","category":"page"},{"location":"types/#Long-Sequences-1","page":"BioSequences Types","title":"Long Sequences","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Many genomics scripts and tools benefit from an efficient general purpose sequence type that allows you to create and edit sequences. In BioSequences, the LongSequence type fills this requirement.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"LongSequence{A<:Alphabet} <: BioSequence{A} is parameterized by a concrete Alphabet type A that defines the domain (or set) of biological symbols permitted. For example, AminoAcidAlphabet is associated with AminoAcid and hence an object of the LongSequence{AminoAcidAlphabet} type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"The following table summarizes common LongSequence types that have been given aliases for convenience.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Type Symbol type Type alias\nLongSequence{DNAAlphabet{4}} DNA LongDNASeq\nLongSequence{RNAAlphabet{4}} RNA LongRNASeq\nLongSequence{AminoAcidAlphabet} AminoAcid LongAminoAcidSeq","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"The LongDNASeq and LongRNASeq aliases use a DNAAlphabet{4}, which means the sequence may store ambiguous nucleotides. If you are sure that nucleotide sequences store unambiguous nucleotides only, you can reduce the memory required by sequences by using a slightly different parameter: DNAAlphabet{2} is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). Replacing LongSequence{DNAAlphabet{4}} in your code with LongSequence{DNAAlphabet{2}} is all you need to do in order to benefit. Some computations that use bitwise operations will also be dramatically faster.","category":"page"},{"location":"types/#Sequence-views-1","page":"BioSequences Types","title":"Sequence views","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Similar to how Base Julia offers views of array objects, BioSequences offers view of LongSequences - the LongSubSeq{A<:Alphabet}.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Conceptually, a LongSubSeq{A} is similar to a LongSequence{A}, but instead of storing their own data, they refer to the data of a LongSequence. Modiying the LongSequence will be reflected in the view, and vice versa. If the underlying LongSequence is truncated, the behaviour of a view is undefined. For the same reason, some operations are not supported for views, such as resizing.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"The purpose of LongSubSeq is that, since they only contain a pointer to the underlying array, an offset and a length, they are much lighter than LongSequences, and will be stack allocated on Julia 1.5 and newer. Thus, the user may construct millions of views without major performace implications.","category":"page"},{"location":"types/#Alphabet-types-1","page":"BioSequences Types","title":"Alphabet types","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences.Alphabet","category":"page"},{"location":"types/#BioSequences.Alphabet","page":"BioSequences Types","title":"BioSequences.Alphabet","text":"Alphabets of biological symbols.\n\nAlphabet is perhaps the most important type trait for biological sequences in BioSequences.jl.\n\nAn Alphabet represents a domain of biological symbols.\n\nFor example, DNAAlphabet{2} has a domain of unambiguous nucleotides (i.e. A, C, G, and T).\n\nAlphabet types restrict and define the set of biological symbols, that can be encoded in a given biological sequence type. They ALSO define HOW that encoding is done.\n\nAn Alphabet type defines the encoding of biological symbols with a pair of associated encoder and decoder methods. These paired methods map between biological symbol values and a binary representation of the symbol.\n\nAny type A <: Alphabet, is expected to implement the Base.eltype method for itself. It is also expected to implement the BitsPerSymbol method.\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Alphabets control how biological symbols are encoded and decoded. They also confer many of the automatic traits and methods that any subtype of T<:BioSequence{A<:Alphabet} will get.","category":"page"}]
}
