var documenterSearchIndex = {"docs":
[{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"dev_docs/bitindex/#BitIndex-1","page":"BitIndex","title":"BitIndex","text":"","category":"section"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"The BitIndex type is an important type in BioSequences internally. BioSequence types store their elements in a vector in a succinct and packed form, allowing multiple symbols (dna, rna, amino-acids, etc.) to be stored inside a single word. This has great performance benefits but makes some things more tricky. For example iterating though the encoded data of the sequence or keeping track of where in the binary array the elements begin and end.","category":"page"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"We simplify this by keeping the length of encoded binary bits in a sequence fixed. Hence a character at arbitrary position can be extracted in a constant time. We then use this BitIndex type which represents the position of an element in the encoded bits as an index, and an offset. I.e Which chunk an element is stored in, and its offset inside of that chunk.","category":"page"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"You can think of this visually:","category":"page"},{"location":"dev_docs/bitindex/#index(i)-1-index(i)-index(i)1-1","page":"BitIndex","title":"index(i)-1        index(i)        index(i)+1","text":"","category":"section"},{"location":"dev_docs/bitindex/#......................X.................................-1","page":"BitIndex","title":"....|................|..X.............|................|....","text":"","category":"section"},{"location":"dev_docs/bitindex/#offset(i)-1","page":"BitIndex","title":"|<-offset(i)-|","text":"","category":"section"},{"location":"dev_docs/bitindex/#–-64-bits-–-1","page":"BitIndex","title":"|<–- 64 bits –>|","text":"","category":"section"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"In the above diagram, the element pointed to is marked by X, i is the BitIndex and in this case the chunk size is 64 bits (although the BitIndex type supports other chunk sizes).","category":"page"},{"location":"dev_docs/bitindex/#","page":"BitIndex","title":"BitIndex","text":"The BitIndex type has two parameters: N which is the number of bits used for each element, and W, which is the word (or chunk) size.","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"symbols/#Biological-symbols-1","page":"Biological Symbols","title":"Biological symbols","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"The BioSequences module reexports the biological symbol (character) types that are provided by BioSymbols.jl:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Type Meaning\nDNA DNA nucleotide\nRNA RNA nucleotide\nAminoAcid Amino acid","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"These symbols are elements of biological sequences, just as characters are elements of strings. See sections beginning from Sequence Types section for details.","category":"page"},{"location":"symbols/#DNA-and-RNA-nucleotides-1","page":"Biological Symbols","title":"DNA and RNA nucleotides","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Set of nucleotide symbols in BioSequences covers IUPAC nucleotide base plus a gap symbol:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbol Constant Meaning\n'A' DNA_A / RNA_A A; Adenine\n'C' DNA_C / RNA_C C; Cytosine\n'G' DNA_G / RNA_G G; Guanine\n'T' DNA_T T; Thymine (DNA only)\n'U' RNA_U U; Uracil (RNA only)\n'M' DNA_M / RNA_M A or C\n'R' DNA_R / RNA_R A or G\n'W' DNA_W / RNA_W A or T/U\n'S' DNA_S / RNA_S C or G\n'Y' DNA_Y / RNA_Y C or T/U\n'K' DNA_K / RNA_K G or T/U\n'V' DNA_V / RNA_V A or C or G; not T/U\n'H' DNA_H / RNA_H A or C or T; not G\n'D' DNA_D / RNA_D A or G or T/U; not C\n'B' DNA_B / RNA_B C or G or T/U; not A\n'N' DNA_N / RNA_N A or C or G or T/U\n'-' DNA_Gap / RNA_Gap Gap (none of the above)","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"https://www.bioinformatics.org/sms/iupac.html","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols are accessible as constants with DNA_ or RNA_ prefix:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> DNA_A\nDNA_A\n\njulia> DNA_T\nDNA_T\n\njulia> RNA_U\nRNA_U\n\njulia> DNA_Gap\nDNA_Gap\n\njulia> typeof(DNA_A)\nDNA\n\njulia> typeof(RNA_A)\nRNA\n","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols can be constructed by converting regular characters:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> convert(DNA, 'C')\nDNA_C\n\njulia> convert(DNA, 'C') === DNA_C\ntrue\n","category":"page"},{"location":"symbols/#Amino-acids-1","page":"Biological Symbols","title":"Amino acids","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Set of amino acid symbols also covers IUPAC amino acid symbols plus a gap symbol:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbol Constant Meaning\n'A' AA_A Alanine\n'R' AA_R Arginine\n'N' AA_N Asparagine\n'D' AA_D Aspartic acid (Aspartate)\n'C' AA_C Cysteine\n'Q' AA_Q Glutamine\n'E' AA_E Glutamic acid (Glutamate)\n'G' AA_G Glycine\n'H' AA_H Histidine\n'I' AA_I Isoleucine\n'L' AA_L Leucine\n'K' AA_K Lysine\n'M' AA_M Methionine\n'F' AA_F Phenylalanine\n'P' AA_P Proline\n'S' AA_S Serine\n'T' AA_T Threonine\n'W' AA_W Tryptophan\n'Y' AA_Y Tyrosine\n'V' AA_V Valine\n'O' AA_O Pyrrolysine\n'U' AA_U Selenocysteine\n'B' AA_B Aspartic acid or Asparagine\n'J' AA_J Leucine or Isoleucine\n'Z' AA_Z Glutamine or Glutamic acid\n'X' AA_X Any amino acid\n'*' AA_Term Termination codon\n'-' AA_Gap Gap (none of the above)","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"https://www.bioinformatics.org/sms/iupac.html","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols are accessible as constants with AA_ prefix:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> AA_A\nAA_A\n\njulia> AA_Q\nAA_Q\n\njulia> AA_Term\nAA_Term\n\njulia> typeof(AA_A)\nAminoAcid\n","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"Symbols can be constructed by converting regular characters:","category":"page"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"julia> convert(AminoAcid, 'A')\nAA_A\n\njulia> convert(AminoAcid, 'P') === AA_P\ntrue\n","category":"page"},{"location":"symbols/#Other-functions-1","page":"Biological Symbols","title":"Other functions","text":"","category":"section"},{"location":"symbols/#","page":"Biological Symbols","title":"Biological Symbols","text":"alphabet\ngap\niscompatible\nisambiguous","category":"page"},{"location":"symbols/#BioSymbols.alphabet","page":"Biological Symbols","title":"BioSymbols.alphabet","text":"alphabet(DNA)\n\nGet all symbols of DNA in sorted order.\n\nExamples\n\njulia> alphabet(DNA)\n(DNA_Gap, DNA_A, DNA_C, DNA_M, DNA_G, DNA_R, DNA_S, DNA_V, DNA_T, DNA_W, DNA_Y, DNA_H, DNA_K, DNA_D, DNA_B, DNA_N)\n\njulia> issorted(alphabet(DNA))\ntrue\n\n\n\n\n\n\nalphabet(RNA)\n\nGet all symbols of RNA in sorted order.\n\nExamples\n\njulia> alphabet(RNA)\n(RNA_Gap, RNA_A, RNA_C, RNA_M, RNA_G, RNA_R, RNA_S, RNA_V, RNA_U, RNA_W, RNA_Y, RNA_H, RNA_K, RNA_D, RNA_B, RNA_N)\n\njulia> issorted(alphabet(RNA))\ntrue\n\n\n\n\n\n\nalphabet(AminoAcid)\n\nGet all symbols of AminoAcid in sorted order.\n\nExamples\n\njulia> alphabet(AminoAcid)\n(AA_A, AA_R, AA_N, AA_D, AA_C, AA_Q, AA_E, AA_G, AA_H, AA_I, AA_L, AA_K, AA_M, AA_F, AA_P, AA_S, AA_T, AA_W, AA_Y, AA_V, AA_O, AA_U, AA_B, AA_J, AA_Z, AA_X, AA_Term, AA_Gap)\n\njulia> issorted(alphabet(AminoAcid))\ntrue\n\n\n\n\n\n\nGets the alphabet encoding of a given BioSequence.\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.gap","page":"Biological Symbols","title":"BioSymbols.gap","text":"gap(DNA)\n\nReturn DNA_Gap.\n\n\n\n\n\ngap(RNA)\n\nReturn RNA_Gap.\n\n\n\n\n\ngap(AminoAcid)\n\nReturn AA_Gap.\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.iscompatible","page":"Biological Symbols","title":"BioSymbols.iscompatible","text":"iscompatible(x::S, y::S) where S <: BioSymbol\n\nTest if x and y are compatible with each other.\n\nExamples\n\njulia> iscompatible(AA_A, AA_R)\nfalse\n\njulia> iscompatible(AA_A, AA_X)\ntrue\n\njulia> iscompatible(DNA_A, DNA_A)\ntrue\n\njulia> iscompatible(DNA_C, DNA_N)  # DNA_N can be DNA_C\ntrue\n\njulia> iscompatible(DNA_C, DNA_R)  # DNA_R (A or G) cannot be DNA_C\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"symbols/#BioSymbols.isambiguous","page":"Biological Symbols","title":"BioSymbols.isambiguous","text":"isambiguous(nt::NucleicAcid)\n\nTest if nt is an ambiguous nucleotide.\n\n\n\n\n\nisambiguous(aa::AminoAcid)\n\nTest if aa is an ambiguous amino acid.\n\n\n\n\n\n","category":"function"},{"location":"io/#I/O-for-sequencing-file-formats-1","page":"I/O","title":"I/O for sequencing file formats","text":"","category":"section"},{"location":"io/#","page":"I/O","title":"I/O","text":"Versions of BioSequences prior to v2.0 provided a FASTA, FASTQ, and 2Bit submodule for working with formatted sequence files.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"After version v2.0, in order to neatly separate concerns, these submodules were removed.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"Instead there will now be dedicated BioJulia packages for each format. Each of these will be compatible with BioSequences.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"A list of all of the different formats and packages is provided below to help you find them quickly.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"Format Package\nFASTA FASTX.jl\nFASTQ FASTX.jl\n2Bit TwoBit.jl","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"counting/#Counting-1","page":"Counting","title":"Counting","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"BioSequences extends the Base.count method to provide some useful utilities for counting the number of sites in biological sequences.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"Most generically you can count the number of sites that satisfy some condition i.e. cause some function to return true:","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"julia> count(isambiguous, dna\"ATCGM\")\n1\n","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"You can also use two sequences, for example to compute the number of matching or mismatching symbols:","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"julia> count(!=, dna\"ATCGM\", dna\"GCCGM\")\n2\n\njulia> count(==, dna\"ATCGM\", dna\"GCCGM\")\n3\n","category":"page"},{"location":"counting/#Alias-functions-1","page":"Counting","title":"Alias functions","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"A number of functions which are aliases for various invocations of Base.count are provided.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"Alias function Base.count call(s)\nn_ambiguous count(isambiguous, seq), count(isambiguous, seqa, seqb)\nn_certain count(iscertain, seq), count(iscertain, seqa, seqb)\nn_gap count(isgap, seq), count(isgap, seqa, seqb)\nmatches count(==, seqa, seqb)\nmismatches count(!=, seqa, seqb)","category":"page"},{"location":"counting/#Bit-parallel-optimisations-1","page":"Counting","title":"Bit-parallel optimisations","text":"","category":"section"},{"location":"counting/#","page":"Counting","title":"Counting","text":"For the vast majority of Base.count(f, seq) and Base.count(f, seqa, seqb) methods, a naive counting is done: the internal count_naive function is called, which simply loops over each position, applies f, and accumulates the result.","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"However, for some functions, it is possible to implement highly efficient methods that use bit-parallelism to check many elements at one time. This is made possible by the succinct encoding of BioSequences. Usually f is one of the functions provided by BioSymbols.jl or by BioSequences.jl","category":"page"},{"location":"counting/#","page":"Counting","title":"Counting","text":"For such sequence and function combinations, Base.count(f, seq) is overloaded to call an internal BioSequences.count_*_bitpar function, which is passed the sequence(s). If you want to force BioSequences to use naive counting for the purposes of testing or debugging for example, then you can call BioSequences.count_naive directly.","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"iteration/#Iteration-1","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"As you might expect, sequence types are iterators over their elements:","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"julia> n = 0\n0\n\njulia> for nt in dna\"ATNGNNT\"\n           if nt == DNA_N\n               global n += 1\n           end\n       end\n\njulia> n\n3\n","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"However, there are many other ways to iterate over a biological sequence, and they are described in the following sections.","category":"page"},{"location":"iteration/#Kmers-and-Skipmers-1","page":"Iteration","title":"Kmers and Skipmers","text":"","category":"section"},{"location":"iteration/#Kmers-1","page":"Iteration","title":"Kmers","text":"","category":"section"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"To iterate over every overlapping kmer in a longer DNA or RNA sequence, use the each method:","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"each(::Type{T}, seq::BioSequence) where {T<:AbstractMer}","category":"page"},{"location":"iteration/#BioSequences.each-Union{Tuple{T}, Tuple{Type{T},BioSequence}} where T<:AbstractMer","page":"Iteration","title":"BioSequences.each","text":"each(::Type{T}, seq::BioSequence) where {T<:AbstractMer}\n\nInitialize an iterator over all overlapping k-mers in a sequence seq skipping ambiguous nucleotides without changing the reading frame.\n\n\n\n\n\n","category":"method"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"Each iteration yields a MerIterResult struct that has the following fields:","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"position: the position in the sequence at which the mer began.\nfw: the mer in the same orientation as the sequence from which it was generated.\nbw: the reverse complement of the fw mer.","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"Iterating over mers in a sequence builds both a mer and it's reverse complement at the same time, as it is more efficient, and it is a common requirement; for example during mapping or constructing assemblies it is often useful to know if the mer your are processing is a canonical mer or not.","category":"page"},{"location":"iteration/#Kmers-with-jumps-1","page":"Iteration","title":"Kmers with jumps","text":"","category":"section"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"You can also iterate over non-overlapping kmers using a step parameter.","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"each(DNAMer{27}, seq, 10)","category":"page"},{"location":"iteration/#Skipmers-1","page":"Iteration","title":"Skipmers","text":"","category":"section"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"To iterate over Mers using the Skipmer method of selecting nucleotides, then you provide a bases_per_cycle and a cycle_len parameter. For example, where bases_per_cycle = 2 and cycle_len = 3.","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"each(DNAMer{27}, seq, 2, 3)","category":"page"},{"location":"iteration/#Positions-1","page":"Iteration","title":"Positions","text":"","category":"section"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"You can iterate over the positions/residues of a sequence that satisfy some condition or query function:","category":"page"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"each(::Function, ::BioSequence)","category":"page"},{"location":"iteration/#BioSequences.each-Tuple{Function,BioSequence}","page":"Iteration","title":"BioSequences.each","text":"each(f::Function, seq::BioSequence) = ConditionIterator(f, seq)\n\nReturn an iterator over each element in seq that satisfies some function f.\n\nThis is similar to the Iterators.filter iterator, except that every iteration yields a tuple of the position of the residue that satisfied f, and the residue itself.\n\n\n\n\n\n","category":"method"},{"location":"iteration/#","page":"Iteration","title":"Iteration","text":"julia> dna_seq = dna\"NATTCGRATY\"\n10nt DNA Sequence:\nNATTCGRATY\n\njulia> # Iterate over each ambiguous residue\n\njulia> for (pos, nuc) in each(isambiguous, dna_seq)\n           println(\"Position $pos is $nuc\")\n       end\nPosition 1 is N\nPosition 7 is R\nPosition 10 is Y\n\njulia> # Iterate over each non-ambiguous residue\n\njulia> for (pos, nuc) in each(iscertain, dna_seq)\n           println(\"Position $pos is $nuc\")\n       end\nPosition 2 is A\nPosition 3 is T\nPosition 4 is T\nPosition 5 is C\nPosition 6 is G\nPosition 8 is A\nPosition 9 is T\n","category":"page"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"random/#Generating-random-sequences-1","page":"Random sequences","title":"Generating random sequences","text":"","category":"section"},{"location":"random/#Long-sequences-1","page":"Random sequences","title":"Long sequences","text":"","category":"section"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"You can generate random long sequences using the randdna function and the Sampler's implemented in BioSequences:","category":"page"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"randseq\nranddnaseq\nrandrnaseq\nrandaaseq\nSamplerUniform\nSamplerWeighted","category":"page"},{"location":"random/#BioSequences.randseq","page":"Random sequences","title":"BioSequences.randseq","text":"randseq([rng::AbstractRNG], A::Alphabet, sp::Sampler, len::Integer)\n\nGenerate a LongSequence{A} of length len with elements drawn from the given sampler.\n\nExample:\n\n# Generate 1000-length RNA with 4% chance of N, 24% for A, C, G, or U\njulia> sp = SamplerWeighted(rna\"ACGUN\", fill(0.24, 4))\njulia> seq = randseq(RNAAlphabet{4}(), sp, 50)\n50nt RNA Sequence:\nCUNGGGCCCGGGNAAACGUGGUACACCCUGUUAAUAUCAACNNGCGCUNU\n\n\n\n\n\nrandseq([rng::AbstractRNG], A::Alphabet, len::Integer)\n\nGenerate a LongSequence{A} of length len from the specified alphabet, drawn from the default distribution. User-defined alphabets should implement this method to implement random LongSequence generation.\n\nFor RNA and DNA alphabets, the default distribution is uniform across A, C, G, and T/U. For AminoAcidAlphabet, it is uniform across the 20 standard amino acids. For a user-defined alphabet A, default is uniform across all elements of symbols(A).\n\nExample:\n\njulia> seq = randseq(AminoAcidAlphabet(), 50)\n50aa Amino Acid Sequence:\nVFMHSIRMIRLMVHRSWKMHSARHVNFIRCQDKKWKSADGIYTDICKYSM\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randdnaseq","page":"Random sequences","title":"BioSequences.randdnaseq","text":"randdnaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{DNAAlphabet{4}} sequence of length len, with bases sampled uniformly from [A, C, G, T]\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randrnaseq","page":"Random sequences","title":"BioSequences.randrnaseq","text":"randrnaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{RNAAlphabet{4}} sequence of length len, with bases sampled uniformly from [A, C, G, U]\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.randaaseq","page":"Random sequences","title":"BioSequences.randaaseq","text":"randaaseq([rng::AbstractRNG], len::Integer)\n\nGenerate a random LongSequence{AminoAcidAlphabet} sequence of length len, with amino acids sampled uniformly from the 20 standard amino acids.\n\n\n\n\n\n","category":"function"},{"location":"random/#BioSequences.SamplerUniform","page":"Random sequences","title":"BioSequences.SamplerUniform","text":"SamplerUniform{T}\n\nUniform sampler of type T. Instantiate with a collection of eltype T containing the elements to sample.\n\nExamples\n\njulia> sp = SamplerUniform(rna\"ACGU\");\n\n\n\n\n\n","category":"type"},{"location":"random/#BioSequences.SamplerWeighted","page":"Random sequences","title":"BioSequences.SamplerWeighted","text":"SamplerWeighted{T}\n\nWeighted sampler of type T. Instantiate with a collection of eltype T containing the elements to sample, and an orderen collection of probabilities to sample each element except the last. The last probability is the remaining probability up to 1.\n\nExamples\n\njulia> sp = SamplerWeighted(rna\"ACGUN\", fill(0.2475, 4));\n\n\n\n\n\n","category":"type"},{"location":"random/#Kmer-sequences-1","page":"Random sequences","title":"Kmer sequences","text":"","category":"section"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"You can make random Mer quite simply using Base.rand:","category":"page"},{"location":"random/#","page":"Random sequences","title":"Random sequences","text":"rand(DNAMer{7})\nrand(RNAMer{8})\nrand(BigDNAMer{63})","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"composition/#Sequence-composition-1","page":"Sequence composition","title":"Sequence composition","text":"","category":"section"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"There are many instances in analyzing sequence data where you will want to know about the composition of your sequences.","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"For example, for a given sequence, you may want to count how many of each possible Kmer, is present in the sequence. This would be important if - for instance - you wanted to analyze the Kmer spectra of your data. Alternatively you might have a collection of sequences, and may want to count how many of each unique sequence you have in your collection. This would be important if - for instance - your collection of sequences were from a population sample, and you wanted to compute the allele or genotype frequencies for the population.","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"Whatever the application, BioSequences provides a method called composition, and a parametric struct called Composition to both compute, and handle the results of such sequence composition calculations.","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"Composition{T}\ncomposition","category":"page"},{"location":"composition/#BioSequences.Composition","page":"Sequence composition","title":"BioSequences.Composition","text":"Sequence composition.\n\nThis is a subtype of Associative{T,Int}, and the getindex method returns the number of occurrences of a symbol or a k-mer.\n\n\n\n\n\n","category":"type"},{"location":"composition/#BioSequences.composition","page":"Sequence composition","title":"BioSequences.composition","text":"composition(seq | kmer_iter)\n\nCalculate composition of biological symbols in seq or k-mers in kmer_iter.\n\n\n\n\n\ncomposition(iter)\n\nA generalised composition algorithm, which computes the number of unique items produced by an iterable.\n\nExample\n\n\n# Example, counting unique sequences.\n\njulia> a = dna\"AAAAAAAATTTTTT\"\n14nt DNA Sequence:\nAAAAAAAATTTTTT\n\njulia> b = dna\"AAAAAAAATTTTTT\"\n14nt DNA Sequence:\nAAAAAAAATTTTTT\n\njulia> c = a[5:10]\n6nt DNA Sequence:\nAAAATT\n\njulia> composition([a, b, c])\nVector{BioSequences.BioSequence{BioSequences.DNAAlphabet{4}}} Composition:\n  AAAATT         => 1\n  AAAAAAAATTTTTT => 2\n\n\n\n\n\n","category":"function"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"For example to get the nucleotide composition of a sequence:","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"julia> comp = composition(dna\"ACGAG\");\n\njulia> comp[DNA_A]\n2\n\njulia> comp[DNA_T]\n0\n","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"Composition structs behave like an associative collection, such as a Dict. But there are a few differences:","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"The getindex method for Composition structs is overloaded to return a default value of 0, if a key is used that is not present in the Composition.\nThe merge! method for two Composition structs adds counts together, unlike the merge! method for other associative containers, which would overwrite the counts.","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"merge! is used to accumulate composition statistics of multiple sequences:","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"# initiaize an empty composition counter\ncomp = composition(dna\"\");\n\n# iterate over sequences and accumulate composition statistics into `comp`\nfor seq in seqs\n    merge!(comp, composition(seq))\nend\n\n# or functional programming style in one line\nfoldl((x, y) -> merge(x, composition(y)), composition(dna\"\"), seqs)","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"composition is also applicable to a k-mer iterator:","category":"page"},{"location":"composition/#","page":"Sequence composition","title":"Sequence composition","text":"julia> comp = composition(each(DNAMer{4}, dna\"ACGT\"^100));\n\njulia> comp[DNAMer(\"ACGT\")]\n100\n\njulia> comp[DNAMer(\"CGTA\")]\n99\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"transforms/#Indexing-and-modifying-sequences-1","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"","category":"section"},{"location":"transforms/#Indexing-1","page":"Indexing & modifying sequences","title":"Indexing","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Most BioSequence concrete subtypes for the most part behave like other vector or string types. They can be indexed using integers or ranges:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"For example, with LongSequences:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTTTANAGTNNAGTACC\"\n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia> seq[5]\nDNA_T\n\njulia> seq[6:end]\n14nt DNA Sequence:\nTANAGTNNAGTACC\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"The biological symbol at a given locus in a biological sequence can be set using setindex:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTTTANAGTNNAGTACC\"\n19nt DNA Sequence:\nACGTTTANAGTNNAGTACC\n\njulia> seq[5] = DNA_A\nDNA_A\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"note: Note\nSome types such as Kmer can be indexed using integers but not using ranges.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"For LongSequence types, indexing a sequence by range creates a subsequence of the original sequence. Unlike Arrays in the standard library, creating this subsequence is copy-free: the subsequence simply points to the original LongSequence data with its range. You may think that this is unsafe because modifying subsequences propagates to the original sequence, but this doesn't happen actually:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"AAAA\"    # create a sequence\n4nt DNA Sequence:\nAAAA\n\njulia> subseq = seq[1:2]  # create a subsequence from `seq`\n2nt DNA Sequence:\nAA\n\njulia> subseq[2] = DNA_T  # modify the second element of it\nDNA_T\n\njulia> subseq             # the subsequence is modified\n2nt DNA Sequence:\nAT\n\njulia> seq                # but the original sequence is not\n4nt DNA Sequence:\nAAAA\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"This is because modifying a sequence checks whether its underlying data are shared with other sequences under the hood. If and only if the data are shared, the subsequence creates a copy of itself. Any modifying operation does this check. This is called copy-on-write strategy and users don't need to care about it because it is transparent: If the user modifies a sequence with or subsequence, the job of managing and protecting the underlying data of sequences is handled for them.","category":"page"},{"location":"transforms/#Modifying-sequences-1","page":"Indexing & modifying sequences","title":"Modifying sequences","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"In addition to setindex, many other modifying operations are possible for biological sequences such as push!, pop!, and insert!, which should be familiar to anyone used to editing arrays.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"push!\npop!\npushfirst!\npopfirst!\ninsert!\ndeleteat!(::BioSequences.BioSequence, ::Integer)\nappend!\nresize!\nempty!","category":"page"},{"location":"transforms/#Base.push!","page":"Indexing & modifying sequences","title":"Base.push!","text":"push!(collection, items...) -> collection\n\nInsert one or more items at the end of collection.\n\nExamples\n\njulia> push!([1, 2, 3], 4, 5, 6)\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse append! to add all the elements of another collection to collection. The result of the preceding example is equivalent to append!([1, 2, 3], [4, 5, 6]).\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.pop!","page":"Indexing & modifying sequences","title":"Base.pop!","text":"pop!(collection) -> item\n\nRemove an item in collection and return it. If collection is an ordered container, the last item is returned.\n\nExamples\n\njulia> A=[1, 2, 3]\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> pop!(A)\n3\n\njulia> A\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> S = Set([1, 2])\nSet([2, 1])\n\njulia> pop!(S)\n2\n\njulia> S\nSet([1])\n\njulia> pop!(Dict(1=>2))\n1 => 2\n\n\n\n\n\npop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\npop!(q::Deque{T})\n\nRemove the element at the back\n\n\n\n\n\npop!(h::BinaryMinMaxHeap) = popmin!(h)\n\n\n\n\n\npop!(sc, k)\n\nDeletes the item with key k in SortedDict or SortedSet sc and returns the value that was associated with k in the case of SortedDict or k itself in the case of SortedSet. A KeyError results if k is not in sc. Time: O(c log n)\n\n\n\n\n\npop!(sc, k)\n\nDeletes the item with key k in SortedDict or SortedSet sc and returns the value that was associated with k in the case of SortedDict or k itself in the case of SortedSet. A KeyError results if k is not in sc. Time: O(c log n)\n\n\n\n\n\npop!(ss)\n\nDeletes the item with first key in SortedSet ss and returns the key. A BoundsError results if ss is empty. Time: O(c log n)\n\n\n\n\n\npop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\n\nExamples\n\njulia> d = RobinDict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\npop!(cb::CircularBuffer)\n\nRemove the element at the back.\n\n\n\n\n\npop!(seq::BioSequence)\n\nRemove the symbol from the end of a biological sequence seq and return it. Returns a variable of eltype(seq).\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.pushfirst!","page":"Indexing & modifying sequences","title":"Base.pushfirst!","text":"pushfirst!(collection, items...) -> collection\n\nInsert one or more items at the beginning of collection.\n\nExamples\n\njulia> pushfirst!([1, 2, 3, 4], 5, 6)\n6-element Array{Int64,1}:\n 5\n 6\n 1\n 2\n 3\n 4\n\n\n\n\n\npushfirst!(q::Deque{T}, x)\n\nAdd an element to the front\n\n\n\n\n\npushfirst!(D::CircularDeque, v)\n\nAdd an element to the front.\n\n\n\n\n\npushfirst!(cb::CircularBuffer, data)\n\nInsert one or more items at the beginning of CircularBuffer and overwrite back if full.\n\n\n\n\n\npushfirst!(seq, x)\n\nInsert a biological symbol x at the beginning of a biological sequence seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.popfirst!","page":"Indexing & modifying sequences","title":"Base.popfirst!","text":"popfirst!(collection) -> item\n\nRemove the first item from collection.\n\nExamples\n\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> popfirst!(A)\n1\n\njulia> A\n5-element Array{Int64,1}:\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\npopfirst!(q::Deque{T})\n\nRemove the element at the front\n\n\n\n\n\npopfirst!(D::CircularDeque)\n\nRemove the element at the front.\n\n\n\n\n\npopfirst!(cb::CircularBuffer)\n\nRemove the element from the front of the CircularBuffer.\n\n\n\n\n\npopfirst!(seq)\n\nRemove the symbol from the beginning of a biological sequence seq and return it. Returns a variable of eltype(seq).\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.insert!","page":"Indexing & modifying sequences","title":"Base.insert!","text":"insert!(a::Vector, index::Integer, item)\n\nInsert an item into a at the given index. index is the index of item in the resulting a.\n\nExamples\n\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\ninsert!(sc, k)\n\nArgument sc is a SortedDict or SortedMultiDict, k is a key and v is the corresponding value. This inserts the (k,v) pair into the container. If the key is already present in a SortedDict, this overwrites the old value. In the case of SortedMultiDict, no overwriting takes place (since SortedMultiDict allows the same key to associate with multiple values). In the case of SortedDict, the return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. In the case of SortedMultiDict, a semitoken is returned (but no boolean). Time: O(c log n)\n\n\n\n\n\ninsert!(sc, k)\n\nArgument sc is a SortedDict or SortedMultiDict, k is a key and v is the corresponding value. This inserts the (k,v) pair into the container. If the key is already present in a SortedDict, this overwrites the old value. In the case of SortedMultiDict, no overwriting takes place (since SortedMultiDict allows the same key to associate with multiple values). In the case of SortedDict, the return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. In the case of SortedMultiDict, a semitoken is returned (but no boolean). Time: O(c log n)\n\n\n\n\n\ninsert!(sc, k)\n\nArgument sc is a SortedSet and k is a key. This inserts the key into the container. If the key is already present, this overwrites the old value. (This is not necessarily a no-op; see below for remarks about the customizing the sort order.) The return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. Time: O(c log n)\n\n\n\n\n\ninsert!(seq::BioSequence, i, x)\n\nInsert a biological symbol x into a biological sequence seq, at the given index i.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.deleteat!-Tuple{BioSequence,Integer}","page":"Indexing & modifying sequences","title":"Base.deleteat!","text":"deleteat!(seq::BioSequence, i::Integer)\n\nDelete a biological symbol at a single position i in a biological sequence seq.\n\nModifies the input sequence.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#Base.append!","page":"Indexing & modifying sequences","title":"Base.append!","text":"append!(collection, collection2) -> collection.\n\nAdd the elements of collection2 to the end of collection.\n\nExamples\n\njulia> append!([1],[2,3])\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> append!([1, 2, 3], [4, 5, 6])\n6-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse push! to add individual items to collection which are not already themselves in another collection. The result of the preceding example is equivalent to push!([1, 2, 3], 4, 5, 6).\n\n\n\n\n\nappend!(cb::CircularBuffer, datavec::AbstractVector)\n\nPush at most last capacity items.\n\n\n\n\n\nappend!(seq, other)\n\nAdd a biological sequence other onto the end of biological sequence seq. Modifies and returns seq.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.resize!","page":"Indexing & modifying sequences","title":"Base.resize!","text":"resize!(a::Vector, n::Integer) -> Vector\n\nResize a to contain n elements. If n is smaller than the current collection length, the first n elements will be retained. If n is larger, the new elements are not guaranteed to be initialized.\n\nExamples\n\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Array{Int64,1}:\n 6\n 5\n 4\n\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\n\njulia> length(a)\n8\n\njulia> a[1:6]\n6-element Array{Int64,1}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\nresize!(seq, size)\n\nResize a biological sequence seq, to a given size.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Base.empty!","page":"Indexing & modifying sequences","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String,Int64} with 0 entries\n\n\n\n\n\nempty!(q::Deque{T})\n\nReset the deque.\n\n\n\n\n\nempty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = RobinDict(\"a\" => 1, \"b\" => 2)\nRobinDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nRobinDict{String,Int64} with 0 entries\n\n\n\n\n\nempty!(cb::CircularBuffer)\n\nReset the buffer.\n\n\n\n\n\nempty!(seq::BioSequence)\n\nCompletely empty a biological sequence seq of nucleotides.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Here are some examples:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACG\"\n3nt DNA Sequence:\nACG\n\njulia> push!(seq, DNA_T)\n4nt DNA Sequence:\nACGT\n\njulia> append!(seq, dna\"AT\")\n6nt DNA Sequence:\nACGTAT\n\njulia> deleteat!(seq, 2)\n5nt DNA Sequence:\nAGTAT\n\njulia> deleteat!(seq, 2:3)\n3nt DNA Sequence:\nAAT\n","category":"page"},{"location":"transforms/#Additional-transformations-1","page":"Indexing & modifying sequences","title":"Additional transformations","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"In addition to these basic modifying functions, other sequence transformations that are common in bioinformatics are also provided.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"reverse!(::BioSequences.LongSequence)\nreverse(::BioSequences.LongSequence{<:NucleicAcidAlphabet})\ncomplement!\ncomplement\nreverse_complement!\nreverse_complement\nungap!\nungap\ncanonical!\ncanonical","category":"page"},{"location":"transforms/#Base.reverse!-Tuple{LongSequence}","page":"Indexing & modifying sequences","title":"Base.reverse!","text":"reverse!(seq::LongSequence)\n\nReverse a biological sequence seq in place.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#Base.reverse-Tuple{LongSequence{#s4} where #s4<:NucleicAcidAlphabet}","page":"Indexing & modifying sequences","title":"Base.reverse","text":"Base.reverse(seq::LongSequence{A}) where {A<:NucleicAcidAlphabet}\n\nCreate a reversed copy of a LongSequence representing a DNA or RNA sequence.\n\nThis version of the reverse method is optimized for speed, taking advantage of bit-parallel operations.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#BioSequences.complement!","page":"Indexing & modifying sequences","title":"BioSequences.complement!","text":"complement!(seq)\n\nMake a complement sequence of seq in place.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSymbols.complement","page":"Indexing & modifying sequences","title":"BioSymbols.complement","text":"complement(nt::NucleicAcid)\n\nReturn the complementary nucleotide of nt.\n\nThis function returns the union of all possible complementary nucleotides.\n\nExamples\n\njulia> complement(DNA_A)\nDNA_T\n\njulia> complement(DNA_N)\nDNA_N\n\njulia> complement(RNA_U)\nRNA_A\n\n\n\n\n\n\ncomplement(seq)\n\nMake a complement sequence of seq.\n\n\n\n\n\ncomplement(x::T) where {T <: Skipmer}\n\nReturn the complement of a short sequence type x.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.reverse_complement!","page":"Indexing & modifying sequences","title":"BioSequences.reverse_complement!","text":"reverse_complement!(seq)\n\nMake a reversed complement sequence of seq in place.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.reverse_complement","page":"Indexing & modifying sequences","title":"BioSequences.reverse_complement","text":"reverse_complement(seq)\n\nMake a reversed complement sequence of seq.\n\n\n\n\n\nreverse_complement(x::Skipmer)\n\nReturn the reverse complement of x.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ungap!","page":"Indexing & modifying sequences","title":"BioSequences.ungap!","text":"Remove gap characters from an input sequence.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ungap","page":"Indexing & modifying sequences","title":"BioSequences.ungap","text":"Create a copy of a sequence with gap characters removed.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.canonical!","page":"Indexing & modifying sequences","title":"BioSequences.canonical!","text":"canonical!(seq::NucleotideSeq)\n\nTransforms the seq into its canonical form, if it is not already canonical. Modifies the input sequence inplace.\n\nFor any sequence, there is a reverse complement, which is the same sequence, but on the complimentary strand of DNA:\n\n------->\nATCGATCG\nCGATCGAT\n<-------\n\nnote: Note\nUsing the reverse_complement of a DNA sequence will give give this reverse complement.\n\nOf the two sequences, the canonical of the two sequences is the lesser of the two i.e. canonical_seq < other_seq.\n\nUsing this function on a seq will ensure it is the canonical version.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.canonical","page":"Indexing & modifying sequences","title":"BioSequences.canonical","text":"canonical(seq::NucleotideSeq)\n\nCreate the canonical sequence of seq.\n\n\n\n\n\ncanonical(kmer::Skipmer)\n\nReturn the canonical sequence of x.\n\nA canonical sequence is the numerical lesser of a k-mer and its reverse complement. This is useful in hashing/counting sequences in data that is not strand specific, and thus observing the short sequence is equivalent to observing its reverse complement.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Some examples:","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> seq = dna\"ACGTAT\"\n6nt DNA Sequence:\nACGTAT\n\njulia> reverse!(seq)\n6nt DNA Sequence:\nTATGCA\n\njulia> complement!(seq)\n6nt DNA Sequence:\nATACGT\n\njulia> reverse_complement!(seq)\n6nt DNA Sequence:\nACGTAT\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Many of these methods also have a version which makes a copy of the input sequence, so you get a modified copy, and don't alter the original sequence. Such methods are named the same, but without the exclamation mark. E.g. reverse instead of reverse!, and ungap instead of ungap!.  ","category":"page"},{"location":"transforms/#Translation-1","page":"Indexing & modifying sequences","title":"Translation","text":"","category":"section"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"Translation is a slightly more complex transformation for RNA Sequences and so we describe it here in more detail.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"The translate function translates a sequence of codons in a RNA sequence to a amino acid sequence based on a genetic code. The BioSequences package provides all NCBI defined genetic codes and they are registered in ncbi_trans_table.","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"translate\nncbi_trans_table","category":"page"},{"location":"transforms/#BioSequences.translate","page":"Indexing & modifying sequences","title":"BioSequences.translate","text":"translate(seq, code=standard_genetic_code, allow_ambiguous_codons=true, convert_start_codon=false)\n\nTranslate an LongRNASeq or a LongDNASeq to an LongAminoAcidSeq.\n\nTranslation uses genetic code code to map codons to amino acids. See ncbi_trans_table for available genetic codes. If codons in the given sequence cannot determine a unique amino acid, they will be translated to AA_X if allow_ambiguous_codons is true and otherwise result in an error. For organisms that utilize alternative start codons, one can set alternative_start=true, in which case the first codon will always be converted to a methionine.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#BioSequences.ncbi_trans_table","page":"Indexing & modifying sequences","title":"BioSequences.ncbi_trans_table","text":"Genetic code list of NCBI.\n\nThe standard genetic code is ncbi_trans_table[1] and others can be shown by show(ncbi_trans_table). For more details, consult the next link: http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes.\n\n\n\n\n\n","category":"constant"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"julia> ncbi_trans_table\nTranslation Tables:\n  1. The Standard Code (standard_genetic_code)\n  2. The Vertebrate Mitochondrial Code (vertebrate_mitochondrial_genetic_code)\n  3. The Yeast Mitochondrial Code (yeast_mitochondrial_genetic_code)\n  4. The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code (mold_mitochondrial_genetic_code)\n  5. The Invertebrate Mitochondrial Code (invertebrate_mitochondrial_genetic_code)\n  6. The Ciliate, Dasycladacean and Hexamita Nuclear Code (ciliate_nuclear_genetic_code)\n  9. The Echinoderm and Flatworm Mitochondrial Code (echinoderm_mitochondrial_genetic_code)\n 10. The Euplotid Nuclear Code (euplotid_nuclear_genetic_code)\n 11. The Bacterial, Archaeal and Plant Plastid Code (bacterial_plastid_genetic_code)\n 12. The Alternative Yeast Nuclear Code (alternative_yeast_nuclear_genetic_code)\n 13. The Ascidian Mitochondrial Code (ascidian_mitochondrial_genetic_code)\n 14. The Alternative Flatworm Mitochondrial Code (alternative_flatworm_mitochondrial_genetic_code)\n 16. Chlorophycean Mitochondrial Code (chlorophycean_mitochondrial_genetic_code)\n 21. Trematode Mitochondrial Code (trematode_mitochondrial_genetic_code)\n 22. Scenedesmus obliquus Mitochondrial Code (scenedesmus_obliquus_mitochondrial_genetic_code)\n 23. Thraustochytrium Mitochondrial Code (thraustochytrium_mitochondrial_genetic_code)\n 24. Pterobranchia Mitochondrial Code (pterobrachia_mitochondrial_genetic_code)\n 25. Candidate Division SR1 and Gracilibacteria Code (candidate_division_sr1_genetic_code)\n","category":"page"},{"location":"transforms/#","page":"Indexing & modifying sequences","title":"Indexing & modifying sequences","text":"https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#Construction-and-conversion-1","page":"Constructing sequences","title":"Construction & conversion","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Here we will showcase the various ways you can construct the various sequence types in BioSequences.","category":"page"},{"location":"construction/#Constructing-sequences-1","page":"Constructing sequences","title":"Constructing sequences","text":"","category":"section"},{"location":"construction/#From-strings-1","page":"Constructing sequences","title":"From strings","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be constructed from strings using their constructors:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq(\"TTANC\")\n5nt DNA Sequence:\nTTANC\n\njulia> LongSequence{DNAAlphabet{2}}(\"TTAGC\")\n5nt DNA Sequence:\nTTAGC\n\njulia> LongRNASeq(\"UUANC\")\n5nt RNA Sequence:\nUUANC\n\njulia> LongSequence{RNAAlphabet{2}}(\"UUAGC\")\n5nt RNA Sequence:\nUUAGC\n\njulia> DNAMer{8}(\"ATCGATCG\")\nDNA 8-mer:\nATCGATCG\n\njulia> # The following works, but is not type-stable...\n\njulia> DNAMer(\"ATCGATCG\")\nDNA 8-mer:\nATCGATCG\n\njulia> RNAMer{8}(\"AUCGAUCG\")\nRNA 8-mer:\nAUCGAUCG\n\njulia> # The following works, but is not type-stable...\n\njulia> RNAMer(LongRNASeq(\"AUCGAUCG\"))\nRNA 8-mer:\nAUCGAUCG\n\njulia> seq = ReferenceSequence(\"NNCGTATTTTCN\")\n12nt Reference Sequence:\nNNCGTATTTTCN\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"note: Note\nFrom version 2.0 onwards, the convert methods for converting a string or vector of symbols into a sequence type have been removed. These convert methods did nothing but pass their arguments to the appropriate constructor.These specific convert methods have been removed due to the semantics of convert: Even though convert(LongDNASeq, \"ATCG\") was previously the same as LongDNASeq(\"ATCG\"), unlike constructors, convert is sometimes implicitly called. So it's methods should be restricted to cases that are considered safe or unsurprising. convert should convert between types that represent the same basic kind of thing, like different representations of numbers. It is also usually lossless. Not all strings are valid sequences, and depending on the sequence type, not all vectors of BioSymbols are valid sequences either. A string only represents the \"same kind of thing\" as a biological sequence in some cases, so implicitly converting them to a sequence type was never safe or unsurprising. These convert methods have been renamed to Base.parse methods.","category":"page"},{"location":"construction/#Constructing-sequences-from-arrays-of-BioSymbols-1","page":"Constructing sequences","title":"Constructing sequences from arrays of BioSymbols","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be constructed using vectors or arrays of a BioSymbol type:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq([DNA_T, DNA_T, DNA_A, DNA_N, DNA_C])\n5nt DNA Sequence:\nTTANC\n\njulia> LongSequence{DNAAlphabet{2}}([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\n5nt DNA Sequence:\nTTAGC\n\njulia> DNAMer{5}([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\nDNA 5-mer:\nTTAGC\n\njulia> RNAMer{5}([RNA_U, RNA_U, RNA_A, RNA_G, RNA_C])\nRNA 5-mer:\nUUAGC\n\njulia> # Works, but is not type-stable\n\njulia> DNAMer([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\nDNA 5-mer:\nTTAGC\n\njulia> RNAMer([RNA_U, RNA_U, RNA_A, RNA_G, RNA_C])\nRNA 5-mer:\nUUAGC","category":"page"},{"location":"construction/#Constructing-sequences-from-other-sequences-1","page":"Constructing sequences","title":"Constructing sequences from other sequences","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You can create sequences, by concatenating other sequences together:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> LongDNASeq(LongDNASeq(\"ACGT\"), LongDNASeq(\"NNNN\"), LongDNASeq(\"TGCA\"))\n12nt DNA Sequence:\nACGTNNNNTGCA\n\njulia> LongDNASeq(\"ACGT\") * LongDNASeq(\"TGCA\")\n8nt DNA Sequence:\nACGTTGCA\n\njulia> repeat(LongDNASeq(\"TA\"), 10)\n20nt DNA Sequence:\nTATATATATATATATATATA\n\njulia> LongDNASeq(\"TA\") ^ 10\n20nt DNA Sequence:\nTATATATATATATATATATA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You can also construct long sequences from kmer sequences, and vice versa:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> m = DNAMer{5}([DNA_T, DNA_T, DNA_A, DNA_G, DNA_C])\nDNA 5-mer:\nTTAGC\n\njulia> LongSequence(m)\n5nt DNA Sequence:\nTTAGC\n\njulia> # round trip from mer to long sequence back to mer.\n\njulia> DNAMer(LongSequence(m))\nDNA 5-mer:\nTTAGC","category":"page"},{"location":"construction/#Conversion-of-sequence-types-1","page":"Constructing sequences","title":"Conversion of sequence types","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sometimes you can convert between sequence types without construction / having to copy data. for example, despite being separate types, LongDNASeq and LongRNASeq can freely be converted between efficiently, without copying the underlying data:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna = dna\"TTANGTAGACCG\"\n12nt DNA Sequence:\nTTANGTAGACCG\n\njulia> rna = convert(LongRNASeq, dna)\n12nt RNA Sequence:\nUUANGUAGACCG\n\njulia> dna.data === rna.data  # underlying data are same\ntrue\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Sequences can be converted explicitly and implicitly, into arrays and strings:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna = dna\"TTANGTAGACCG\"\n12nt DNA Sequence:\nTTANGTAGACCG\n\njulia> dnastr = convert(String, dna)\n\"TTANGTAGACCG\"\n\njulia> # Implicit conversion to string - putting dna sequence in String vector \n\njulia> arr = String[dna]\n1-element Array{String,1}:\n \"TTANGTAGACCG\"\n ","category":"page"},{"location":"construction/#String-literals-1","page":"Constructing sequences","title":"String literals","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"BioSequences provides several string literal macros for creating sequences.","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"note: Note\nWhen you use literals you may mix the case of characters.","category":"page"},{"location":"construction/#Long-sequence-literals-1","page":"Constructing sequences","title":"Long sequence literals","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> dna\"TACGTANNATC\"\n11nt DNA Sequence:\nTACGTANNATC\n\njulia> rna\"AUUUGNCCANU\"\n11nt RNA Sequence:\nAUUUGNCCANU\n\njulia> aa\"ARNDCQEGHILKMFPSTWYVX\"\n21aa Amino Acid Sequence:\nARNDCQEGHILKMFPSTWYVX\n\njulia> char\"αβγδϵ\"\n5char Char Sequence:\nαβγδϵ\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"However, it should be noted that by default these sequence literals allocate the LongSequence object before the code containing the sequence literal is run. This means there may be occasions where your program does not behave as you first expect. For example consider the following code:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> function foo()\n           s = dna\"CTT\"\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"d\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You might expect that every time you call foo, that a DNA sequence CTTA would be returned. You might expect that this is because every time foo is called, a new DNA sequence variable CTT is created, and the A nucleotide is pushed to it, and the result, CTTA is returned. In other words you might expect the following output:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"However, this is not what happens, instead the following happens:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"s\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n5nt DNA Sequence:\nCTTAA\n\njulia> foo()\n6nt DNA Sequence:\nCTTAAA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"The reason for this is because the sequence literal is allocated only once before the first time the function foo is called and run. Therefore, s in foo is always a reference to that one sequence that was allocated. So one sequence is created before foo is called, and then it is pushed to every time foo is called. Thus, that one allocated sequence grows with every call of foo.","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"If you wanted foo to create a new sequence each time it is called, then you can add a flag to the end of the sequence literal to dictate behaviour: A flag of 's' means 'static': the sequence will be allocated before code is run, as is the default behaviour described above. However providing 'd' flag changes the behaviour: 'd' means 'dynamic': the sequence will be allocated whilst the code is running, and not before. So to change foo so as it creates a new sequence each time it is called, simply add the 'd' flag to the sequence literal:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> function foo()\n           s = dna\"CTT\"d     # 'd' flag appended to the string literal.\n           push!(s, DNA_A)\n       end\nfoo (generic function with 1 method)\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Now every time foo is called, a new sequence CTT is created, and an A nucleotide is pushed to it:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\n    function foo()\n        s = dna\"CTT\"d\n        push!(s, DNA_A)\n    end\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n\njulia> foo()\n4nt DNA Sequence:\nCTTA\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"DocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"So the take home message of sequence literals is this:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Be careful when you are using sequence literals inside of functions, and inside the bodies of things like for loops. And if you use them and are unsure, use the  's' and 'd' flags to ensure the behaviour you get is the behaviour you intend.","category":"page"},{"location":"construction/#Kmer-literals-1","page":"Constructing sequences","title":"Kmer literals","text":"","category":"section"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"You can create literals for Mers and BigMers as well:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> mer\"ATCG\"\nDNA 4-mer:\nATCG\n\njulia> mer\"ATCG\"dna\nDNA 4-mer:\nATCG\n\njulia> mer\"AUCG\"rna\nRNA 4-mer:\nAUCG\n","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"By using a flag at the end of the literal, you can set whether the kmer should be a DNA kmer or an RNA kmer. If you don't set the flag, then by default it will try to make a dna kmer from the string.","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"Literals for BigMers are also available:","category":"page"},{"location":"construction/#","page":"Constructing sequences","title":"Constructing sequences","text":"julia> bigmer\"ATCG\"\nDNA 4-mer:\nATCG\n\njulia> bigmer\"ATCG\"dna\nDNA 4-mer:\nATCG\n\njulia> bigmer\"AUCG\"rna\nRNA 4-mer:\nAUCG\n","category":"page"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"dev_docs/symbols/#Biological-symbols:-Developer-Information-1","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"","category":"section"},{"location":"dev_docs/symbols/#Bit-encoding-of-biological-symbols-1","page":"Biological symbols: Developer Information","title":"Bit encoding of biological symbols","text":"","category":"section"},{"location":"dev_docs/symbols/#Nucleic-acids-(DNA-and-RNA)-1","page":"Biological symbols: Developer Information","title":"Nucleic acids (DNA and RNA)","text":"","category":"section"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"Every nucleotide is encoded using the lower 4 bits of a byte. An unambiguous nucleotide has only one set bit and the other bits are unset. The table below summarises all unambiguous nucleotides and their corresponding bits. An ambiguous nucleotide is the bitwise OR of unambiguous nucleotides that the ambiguous nucleotide can take. For example, DNA_R (meaning the nucleotide is either DNA_A or DNA_G) is encoded as 0101 because 0101 is the bitwise OR of 0001 (DNA_A) and 0100 (DNA_G). The gap symbol is always 0000.","category":"page"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"NucleicAcid Bits\nDNA_A, RNA_A 0001\nDNA_C, RNA_C 0010\nDNA_G, RNA_G 0100\nDNA_T, RNA_U 1000","category":"page"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"The next few examples demonstrate some of the bit operations of DNA to illustrate:","category":"page"},{"location":"dev_docs/symbols/#","page":"Biological symbols: Developer Information","title":"Biological symbols: Developer Information","text":"julia> bitstring(reinterpret(UInt8, DNA_A))\n\"00000001\"\n\njulia> bitstring(reinterpret(UInt8, DNA_G))\n\"00000100\"\n\njulia> bitstring(reinterpret(UInt8, DNA_R))\n\"00000101\"\n\njulia> bitstring(reinterpret(UInt8, DNA_B))\n\"00001110\"\n\njulia> ~DNA_A\nDNA_B\n\njulia> DNA_A | DNA_G\nDNA_R\n\njulia> DNA_R & DNA_B\nDNA_G\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"sequence_search/#Sequence-search-1","page":"Pattern matching and searching","title":"Sequence search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Three kinds of on-line search functions are provided:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Exact search\nApproximate search\nRegular expression search","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"These are all specialized for biological sequences and ambiguities of symbols are considered.","category":"page"},{"location":"sequence_search/#Exact-search-1","page":"Pattern matching and searching","title":"Exact search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Exact search functions search for an occurrence of the query symbol or sequence.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\";\n\njulia> findfirst(DNA_G, seq)\n4\n\njulia> query = dna\"AGC\";\n\njulia> findfirst(query, seq)\n3:5\n\njulia> findlast(query, seq)\n8:10\n\njulia> occursin(query, seq)\ntrue","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"These search functions take ambiguous symbols into account. That is, if two symbols are compatible (e.g. DNA_A and DNA_N), they match when searching an occurrence. In the following example, 'N' is a wild card that matches any symbols.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> findfirst(dna\"CGT\", dna\"ACNT\")  # 'N' matches 'G'\n2:4\n\njulia> findfirst(dna\"CNT\", dna\"ACGT\")  # 'G' matches 'N'\n2:4\n\njulia> occursin(dna\"CNT\", dna\"ACNT\")\ntrue","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The exception to this behaviour is if you are finding a single 'character', in which case an ambiguous symbol is matched exactly:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> findfirst(DNA_N, dna\"ACNT\")\n3\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The exact sequence search needs a preprocessing phase of query sequence before the searching phase. This would be fast enough for most search applications. But when searching a query sequence to many target sequences, caching the result of preprocessing may save time. You can do this by creating an ExactSearchQuery object and re-use it for each search:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> query = ExactSearchQuery(dna\"ATT\");\n\njulia> findfirst(query, dna\"ATTTATT\")\n1:3\n\njulia> findlast(query, dna\"ATTTATT\")\n5:7\n\njulia> occursin(query, dna\"ATTTATT\")\ntrue","category":"page"},{"location":"sequence_search/#Approximate-search-1","page":"Pattern matching and searching","title":"Approximate search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The approximate search is similar to the exact search but allows a specific number of errors. That is, it tries to find a subsequence of the target sequence within a specific Levenshtein distance of the query sequence:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\";\n\njulia> approxsearch(seq, dna\"AGGG\", 0)  # nothing matches with no errors\n0:-1\n\njulia> approxsearch(seq, dna\"AGGG\", 1)  # seq[3:6] matches with one error\n3:6\n\njulia> approxsearch(seq, dna\"AGGG\", 2)  # seq[1:4] matches with two errors\n1:4\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Like the exact search functions, four kinds of functions (approxsearch, approxsearchindex, approxrsearch, and approxrsearchindex) are available:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> seq = dna\"ACAGCGTAGCT\"; pat = dna\"AGGG\";\n\njulia> approxsearch(seq, pat, 2)        # return the range (forward)\n1:4\n\njulia> approxsearchindex(seq, pat, 2)   # return the starting index (forward)\n1\n\njulia> approxrsearch(seq, pat, 2)       # return the range (backward)\n8:11\n\njulia> approxrsearchindex(seq, pat, 2)  # return the starting index (backward)\n8\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Preprocessing can be cached in an ApproximateSearchQuery object:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> query = ApproximateSearchQuery(dna\"AGGG\");\n\njulia> approxsearch(dna\"AAGAGG\", query, 1)\n2:5\n\njulia> approxsearch(dna\"ACTACGT\", query, 2)\n4:6\n","category":"page"},{"location":"sequence_search/#Regular-expression-search-1","page":"Pattern matching and searching","title":"Regular expression search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Query patterns can be described in regular expressions. The syntax supports a subset of Perl and PROSITE's notation.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The Perl-like syntax starts with biore (BIOlogical REgular expression) and ends with a symbol option: \"dna\", \"rna\" or \"aa\". For example, biore\"A+\"dna is a regular expression for DNA sequences and biore\"A+\"aa is for amino acid sequences. The symbol options can be abbreviated to its first character: \"d\", \"r\" or \"a\", respectively.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Here are examples of using the regular expression for BioSequences:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> match(biore\"A+C*\"dna, dna\"AAAACC\")\nRegexMatch(\"AAAACC\")\n\njulia> match(biore\"A+C*\"d, dna\"AAAACC\")\nRegexMatch(\"AAAACC\")\n\njulia> occursin(biore\"A+C*\"dna, dna\"AAC\")\ntrue\n\njulia> occursin(biore\"A+C*\"dna, dna\"C\")\nfalse\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"match will return a RegexMatch if a match is found, otherwise it will return nothing if no match is found.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The table below summarizes available syntax elements.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Syntax Description Example\n| alternation \"A|T\" matches \"A\" and \"T\"\n* zero or more times repeat \"TA*\" matches \"T\", \"TA\" and \"TAA\"\n+ one or more times repeat \"TA+\" matches \"TA\" and \"TAA\"\n? zero or one time \"TA?\" matches \"T\" and \"TA\"\n{n,} n or more times repeat \"A{3,}\" matches \"AAA\" and \"AAAA\"\n{n,m} n-m times repeat \"A{3,5}\" matches \"AAA\", \"AAAA\" and \"AAAAA\"\n^ the start of the sequence \"^TAN*\" matches \"TATGT\"\n$ the end of the sequence \"N*TA$\" matches \"GCTA\"\n(...) pattern grouping \"(TA)+\" matches \"TA\" and \"TATA\"\n[...] one of symbols \"[ACG]+\" matches \"AGGC\"","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"eachmatch and findfirst are also defined like usual strings:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> collect(matched(x) for x in eachmatch(biore\"TATA*?\"d, dna\"TATTATAATTA\")) # overlap\n4-element Array{LongSequence{DNAAlphabet{4}},1}:\n TAT  \n TAT\n TATA\n TATAA\n\njulia> collect(matched(x) for x in eachmatch(biore\"TATA*\"d, dna\"TATTATAATTA\", false)) # no overlap\n2-element Array{LongSequence{DNAAlphabet{4}},1}:\n TAT  \n TATAA\n\njulia> findfirst(biore\"TATA*\"d, dna\"TATTATAATTA\")\n1:3\n\njulia> findfirst(biore\"TATA*\"d, dna\"TATTATAATTA\", 2)\n4:8\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Noteworthy differences from strings are:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"Ambiguous characters match any compatible characters (e.g. biore\"N\"d is equivalent to biore\"[ACGT]\"d).\nWhitespaces are ignored (e.g. biore\"A C G\"d is equivalent to biore\"ACG\"d).","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The PROSITE notation is described in ScanProsite - user manual. The syntax supports almost all notations including the extended syntax. The PROSITE notation starts with prosite prefix and no symbol option is needed because it always describes patterns of amino acid sequences:","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> match(prosite\"[AC]-x-V-x(4)-{ED}\", aa\"CPVPQARG\")\nRegexMatch(\"CPVPQARG\")\n\njulia> match(prosite\"[AC]xVx(4){ED}\", aa\"CPVPQARG\")\nRegexMatch(\"CPVPQARG\")\n","category":"page"},{"location":"sequence_search/#Position-weight-matrix-search-1","page":"Pattern matching and searching","title":"Position weight matrix search","text":"","category":"section"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"A motif can also be specified using position weight matrix (PWM) in a probabilistic way. search(seq, pwm, threshold) method searches for the first position in the sequence where a score calculated using the PWM is greater than or equal to the threshold. More formally, denoting the sequence as S and the PWM value of symbol s at position j as M_sj, the score starting from a position p is defined as","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"operatornamescore(S p) = sum_i=1^L M_Sp+i-1i","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"and search(S, M, t) returns the smallest p that satisfies operatornamescore(S p) ge t.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"There are two kinds of matrices in this package: PFM and PWM. The PFM type is a position frequency matrix and stores symbol frequencies for each position. The PWM is a position weight matrix and stores symbol scores for each position. You can create a PFM from a set of sequences with the same length and then create a PWM from the PFM object.","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"julia> kmers = DNAMer.([\"TTA\", \"CTA\", \"ACA\", \"TCA\", \"GTA\"])\n5-element Array{Mer{DNAAlphabet{2},3},1}:\n TTA\n CTA\n ACA\n TCA\n GTA\n\njulia> pfm = PFM(kmers)  # sequence set => PFM\n4×3 PFM{DNA,Int64}:\n A  1  0  5\n C  1  2  0\n G  1  0  0\n T  2  3  0\n\njulia> pwm = PWM(pfm)  # PFM => PWM\n4×3 PWM{DNA,Float64}:\n A -0.321928 -Inf       2.0\n C -0.321928  0.678072 -Inf\n G -0.321928 -Inf      -Inf\n T  0.678072  1.26303  -Inf\n\njulia> pwm = PWM(pfm .+ 0.01)  # add pseudo counts to avoid infinite values\n4×3 PWM{DNA,Float64}:\n A -0.319068 -6.97728   1.99139\n C -0.319068  0.673772 -6.97728\n G -0.319068 -6.97728  -6.97728\n T  0.673772  1.25634  -6.97728\n\njulia> pwm = PWM(pfm .+ 0.01, prior=[0.2, 0.3, 0.3, 0.2])  # GC-rich prior\n4×3 PWM{DNA,Float64}:\n A  0.00285965 -6.65535   2.31331\n C -0.582103    0.410737 -7.24031\n G -0.582103   -7.24031  -7.24031\n T  0.9957      1.57827  -6.65535\n","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"The PWM_sj matrix is computed from PFM_sj and the prior probability p(s) as follows ([Wasserman2004]):","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"beginalign\n    PWM_sj = log_2 fracp(sj)p(s) \n    p(sj)  = fracPFM_sjsum_s PFM_sj\nendalign","category":"page"},{"location":"sequence_search/#","page":"Pattern matching and searching","title":"Pattern matching and searching","text":"[Wasserman2004]: https://doi.org/10.1038/nrg1315","category":"page"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"predicates/#Predicates-1","page":"Predicates","title":"Predicates","text":"","category":"section"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"A number of predicate or query functions are supported for sequences, allowing you to check for certain properties of a sequence.","category":"page"},{"location":"predicates/#","page":"Predicates","title":"Predicates","text":"isrepetitive\nispalindromic\nhasambiguity\niscanonical","category":"page"},{"location":"predicates/#BioSequences.isrepetitive","page":"Predicates","title":"BioSequences.isrepetitive","text":"isrepetitive(seq::BioSequence, n::Integer=length(seq))\n\nReturn true if and only if seq contains a repetitive subsequence of length ≥ n.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.ispalindromic","page":"Predicates","title":"BioSequences.ispalindromic","text":"ispalindromic(seq::BioSequence)\n\nReturn true if seq is a palindromic sequence; otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.hasambiguity","page":"Predicates","title":"BioSequences.hasambiguity","text":"hasambiguity(seq::BioSequence)\n\nReturns true if seq has an ambiguous symbol; otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"predicates/#BioSequences.iscanonical","page":"Predicates","title":"BioSequences.iscanonical","text":"iscanonical(seq::NucleotideSeq)\n\nReturns true if seq is canonical.\n\nFor any sequence, there is a reverse complement, which is the same sequence, but on the complimentary strand of DNA:\n\n------->\nATCGATCG\nCGATCGAT\n<-------\n\nnote: Note\nUsing the reverse_complement of a DNA sequence will give give this reverse complement.\n\nOf the two sequences, the canonical of the two sequences is the lesser of the two i.e. canonical_seq < other_seq.\n\n\n\n\n\n","category":"function"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"dev_docs/sequences/biosequence/#On-concrete-biological-sequence-types...-1","page":"-","title":"On concrete biological sequence types...","text":"","category":"section"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"Sequences in BioSequences.jl are more strictly typed than in many other libraries; Elements in a sequence are typed as biological symbol instead of character or byte. They are special-purpose types rather than simply strings and hence offer additional functionality that naive string types don't have.","category":"page"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"Though this strictness sacrifices some convenience, it also means you can always rely on a DNA sequence type to store DNA and nothing but DNA, without having to check, or deal with lowercase versus uppercase and so on.","category":"page"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"Strict separation of sequence types also means we are free to choose the most efficient representation. DNA and RNA sequences are encoded using either four bits per base (which is the default), or two bits per base. This makes them memory efficient and allows us to speed up many common operations and transformations, like nucleotide composition, reverse complement, and k-mer enumeration.","category":"page"},{"location":"dev_docs/sequences/biosequence/#Defining-a-new-alphabet-1","page":"-","title":"Defining a new alphabet","text":"","category":"section"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"The alphabet type parameter A of BioSequence{A} enables a user to extend functionality of BioSequence with minimum effort. As an example, definition of a new alphabet type representing a sequence of boolean values is shown below:","category":"page"},{"location":"dev_docs/sequences/biosequence/#","page":"-","title":"-","text":"julia> immutable BoolAlphabet <: Alphabet end\n\njulia> BioSequences.bitsof(::Type{BoolAlphabet}) = 1\n\njulia> BioSequences.eltype(::Type{BoolAlphabet}) = Bool\n\njulia> BioSequences.alphabet(::Type{BoolAlphabet}) = false:true\n\njulia> function BioSequences.encode(::Type{BoolAlphabet}, x::Bool)\n           return UInt64(ifelse(x, 0x01, 0x00))\n       end\n\njulia> function BioSequences.decode(::Type{BoolAlphabet}, x::UInt64)\n           if x > 0x01\n               throw(BioSequences.DecodeError(BoolAlphabet, x))\n           end\n           return ifelse(x == 0x00, false, true)\n       end\n","category":"page"},{"location":"#BioSequences-1","page":"Home","title":"BioSequences","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Latest Release) (Image: MIT license)  (Image: Stable documentation) (Image: Latest documentation) (Image: Lifecycle) (Image: Chat)","category":"page"},{"location":"#Description-1","page":"Home","title":"Description","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BioSequences provides data types and methods for common operations with  biological sequences, including DNA, RNA, and amino acid sequences.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Releases of BioSequences version 2.0 and above are registered and made available to install through BioJulia's package registry. Julia's package manager only monitors the \"General\" package repository by default. So before you start, you should tell julia about the existence of the BioJulia package registry.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Start a julia terminal, hit the ] key to enter pkg mode (you should see the prompt change from julia> to pkg> ), then enter the following command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"registry add https://github.com/BioJulia/BioJuliaRegistry.git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After you've added the registry, you can install BioSequences from the julia REPL. Press ] to enter pkg mode again, and enter the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add BioSequences","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.","category":"page"},{"location":"#Testing-1","page":"Home","title":"Testing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BioSequences is tested against Julia 1.X on Linux, OS X, and Windows.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"#Contributing-1","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Take a look at the contributing files detailed contributor and maintainer guidelines, and code of conduct.","category":"page"},{"location":"#Financial-contributions-1","page":"Home","title":"Financial contributions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We also welcome financial contributions in full transparency on our open collective. Anyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.","category":"page"},{"location":"#Backers-and-Sponsors-1","page":"Home","title":"Backers & Sponsors","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Thank you to all our backers and sponsors!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Love our work and community? Become a backer.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: backers)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Does your company use BioJulia? Help keep BioJulia feature rich and healthy by sponsoring the project Your logo will show up here with a link to your website.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"#Questions?-1","page":"Home","title":"Questions?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you have a question about contributing or using BioJulia software, come on over and chat to us on Gitter, or you can try the Bio category of the Julia discourse site.","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"demultiplexer/#Sequence-demultiplexing-1","page":"Sequence Demultipllexing","title":"Sequence demultiplexing","text":"","category":"section"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"Multiplex sequencing is a technology to sequence multiple samples at the same time on a high-throughput DNA sequencer. Samples are distinguished by the short prefix of a DNA sequence called DNA barcode. BioSequences offers the Demultiplexer type and the demultiplex function to identify the DNA barcode of a longer DNA sequence, whilst allowing small errors.","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"In the following example, four kinds of DNA sequences of length 4 are used as DNA barcodes. Demultiplexer takes these barcodes as its first argument with a few options:","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"julia> barcodes = LongDNASeq.([\"ATGG\", \"CAGA\", \"GGAA\", \"TACG\"]);\n\njulia> dplxr = Demultiplexer(barcodes, n_max_errors=1, distance=:hamming)\nDemultiplexer{LongSequence{DNAAlphabet{4}}}:\n  distance: hamming\n  number of barcodes: 4\n  number of correctable errors: 1","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"DocTestSetup = quote\n    using BioSequences\n    barcodes = LongDNASeq.([\"ATGG\", \"CAGA\", \"GGAA\", \"TACG\"]);\n    dplxr = Demultiplexer(barcodes, n_max_errors=1, distance=:hamming);\nend","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"n_max_errors specifies the number of maximum correctable errors in a barcode. The type of correctable errors depends on the distance parameter. When distance = :hamming as shown above only substitutions are correctable. When distance = :levenshtein substitutions, deletions, and insertions are correctable. The user is responsible for keeping enough distances among barcodes; Demultiplexer will throw an exception if two barcodes are within n_max_errors * 2.","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"The demultiplex function takes a demultiplexer object and a DNA sequence, and returns a tuple of a barcode index and a distance between the original barcode sequence and the prefix sequence:","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"julia> demultiplex(dplxr, dna\"ATGGCGNT\")  # 1st barcode with no errors\n(1, 0)\n\njulia> demultiplex(dplxr, dna\"CAGGCGNT\")  # 2nd barcode with one error\n(2, 1)\n\njulia> demultiplex(dplxr, dna\"GGAACGNT\")  # 3rd barcode with no errors\n(3, 0)\n\njulia> demultiplex(dplxr, dna\"TGACCGNT\")  # no matching barcode\n(0, -1)\n","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"The optional third argument controls the search strategy. demultiplex uses an index to search the closest barcode within n_max_errors in the barcode set and returns it if any by default. If the third argument is true it falls back to a linear search after the index search and returns one of the closest barcodes at random. The next example shows the difference of these two strategies:","category":"page"},{"location":"demultiplexer/#","page":"Sequence Demultipllexing","title":"Sequence Demultipllexing","text":"julia> demultiplex(dplxr, dna\"TGACCGNT\", false)  # linear search off (default)\n(0, -1)\n\njulia> demultiplex(dplxr, dna\"TGACCGNT\", true)   # linear search on\n(3, 2)\n","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"CurrentModule = BioSequences\nDocTestSetup = quote\n    using BioSequences\nend","category":"page"},{"location":"types/#Sequence-Types-1","page":"BioSequences Types","title":"Sequence Types","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences exports an abstract BioSequence type, and several concrete sequence types which inherit from it.","category":"page"},{"location":"types/#The-abstract-BioSequence-1","page":"BioSequences Types","title":"The abstract BioSequence","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences provides an abstract type called a BioSequence{A<:Alphabet}. This abstract type, and the methods and traits is supports, allows for many algorithms in BioSequences to be written as generically as possible, thus reducing the amount of code to read and understand, whilst maintaining high performance when such code is compiled for a concrete BioSequence subtype. Additionally, it allows new types to be implemented that are fully compatible with the rest of BioSequences, providing that key methods or traits are defined).","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"This abstract type is parametric over concrete types of Alphabet, which define the range of symbols permitted in the sequence.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Some aliases are also provided for your convenience:","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Type alias Type\nNucleotideSeq BioSequence{<:NucleicAcidAlphabet}\nAminoAcidSeq BioSequence{AminoAcidAlphabet}","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Any concrete sequence type compatible with BioSequences must inherit from BioSequence{A}, where A is the alphabet of the concrete sequence type. It must also have the following methods defined for it:","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"encoded_data\nBase.length(::BioSequence)","category":"page"},{"location":"types/#BioSequences.encoded_data","page":"BioSequences Types","title":"BioSequences.encoded_data","text":"Return the data member of seq that stores the encoded sequence data.\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.length-Tuple{BioSequence}","page":"BioSequences Types","title":"Base.length","text":"Get the length of a biological sequence.\n\n\n\n\n\n","category":"method"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"If these requirements are satisfied, the following key traits and methods backing the BioSequences interface, should be defined already for the sequence type.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"encoded_data_type\nencoded_data_eltype\nAlphabet(::BioSequence)\nBioSymbols.alphabet(::BioSequence)\nBitsPerSymbol\nbits_per_symbol","category":"page"},{"location":"types/#BioSequences.encoded_data_type","page":"BioSequences Types","title":"BioSequences.encoded_data_type","text":"Get the vector of bits storing a sequences packed encoded elements.\n\n\n\n\n\n","category":"function"},{"location":"types/#BioSequences.encoded_data_eltype","page":"BioSequences Types","title":"BioSequences.encoded_data_eltype","text":"Get the element type of the vector of bits storing a sequences packed encoded elements.\n\n\n\n\n\n","category":"function"},{"location":"types/#BioSequences.Alphabet-Tuple{BioSequence}","page":"BioSequences Types","title":"BioSequences.Alphabet","text":"Return the Alpahbet type that defines the biological symbols allowed for seq.\n\n\n\n\n\n","category":"method"},{"location":"types/#BioSymbols.alphabet-Tuple{BioSequence}","page":"BioSequences Types","title":"BioSymbols.alphabet","text":"Gets the alphabet encoding of a given BioSequence.\n\n\n\n\n\n","category":"method"},{"location":"types/#BioSequences.BitsPerSymbol","page":"BioSequences Types","title":"BioSequences.BitsPerSymbol","text":"The number of bits required to represent a packed symbol in a vector of bits.\n\n\n\n\n\n","category":"type"},{"location":"types/#BioSequences.bits_per_symbol","page":"BioSequences Types","title":"BioSequences.bits_per_symbol","text":"Get the number of bits each symbol packed into a BioSequence uses, as an integer value.\n\n\n\n\n\n","category":"function"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"As a result, the vast majority of methods described in the rest of this manual should work out of the box for the concrete sequence type. But they can always be overloaded if needed.","category":"page"},{"location":"types/#Long-Sequences-1","page":"BioSequences Types","title":"Long Sequences","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Many genomics scripts and tools benefit from an efficient general purpose sequence type that allows you to create and edit sequences. In BioSequences, the LongSequence type fills this requirement.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"LongSequence{A<:Alphabet} <: BioSequence{A} is parameterized by a concrete Alphabet type A that defines the domain (or set) of biological symbols permitted. For example, AminoAcidAlphabet is associated with AminoAcid and hence an object of the LongSequence{AminoAcidAlphabet} type represents a sequence of amino acids.  Symbols from multiple alphabets can't be intermixed in one sequence type.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"The following table summarizes common LongSequence types that have been given aliases for convenience.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Type Symbol type Type alias\nLongSequence{DNAAlphabet{4}} DNA LongDNASeq\nLongSequence{RNAAlphabet{4}} RNA LongRNASeq\nLongSequence{AminoAcidAlphabet} AminoAcid LongAminoAcidSeq\nLongSequence{CharAlphabet} Char LongCharSeq","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"The LongDNASeq and LongRNASeq aliases use a DNAAlphabet{4}, which means the sequence may store ambiguous nucleotides. If you are sure that nucleotide sequences store unambiguous nucleotides only, you can reduce the memory required by sequences by using a slightly different parameter: DNAAlphabet{2} is an alphabet that uses two bits per base and limits to only unambiguous nucleotide symbols (ACGT in DNA and ACGU in RNA). Replacing LongSequence{DNAAlphabet{4}} in your code with LongSequence{DNAAlphabet{2}} is all you need to do in order to benefit. Some computations that use bitwise operations will also be dramatically faster.","category":"page"},{"location":"types/#Kmers-and-Skipmers-1","page":"BioSequences Types","title":"Kmers & Skipmers","text":"","category":"section"},{"location":"types/#Kmers-1","page":"BioSequences Types","title":"Kmers","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Bioinformatic analyses make extensive use of kmers. Kmers are contiguous sub-strings of k nucleotides of some ref sequence. ","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"They are used extensively in bioinformatic analyses as an informational unit. This concept popularised by short read assemblers.  Analyses within the kmer space benefit from a simple formulation of the sampling problem and direct in-hash comparisons.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences provides the following types to represent Kmers, unlike some sequence types, they are immutable.","category":"page"},{"location":"types/#Mer{A:NucleicAcidAlphabet{2},K}-1","page":"BioSequences Types","title":"Mer{A<:NucleicAcidAlphabet{2},K}","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Represents a substring of K DNA or RNA nucleotides (depending on the alphabet A). This type represents the sequence using a single UInt64, and so the maximum possible sequence possible - the largest K possible, is 32. We recommend using 31 rather than 32 however, as odd K values avoid palindromic mers which can be problematic for some algorithms.","category":"page"},{"location":"types/#BigMer{A:NucleicAcidAlphabet{2},K}-1","page":"BioSequences Types","title":"BigMer{A<:NucleicAcidAlphabet{2},K}","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Represents a substring of K DNA or RNA nucleotides (depending on the alphabet A). This type represents the sequence using a single UInt128, and so the maximum possible sequence possible - the largest K possible, is 64. We recommend using 63 rather than 64 however, as odd K values avoid palindromic mers which can be problematic for some algorithms.","category":"page"},{"location":"types/#AbstractMer{A:NucleicAcidAlphabet{2},K}-1","page":"BioSequences Types","title":"AbstractMer{A<:NucleicAcidAlphabet{2},K}","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"This abstract type is just a type that unifies the Mer and BigMer types for the purposes of writing generalised methods of functions.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Several aliases are provided for convenience:","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Type alias Type\nDNAMer{K} Mer{DNAAlphabet{2},K}\nRNAMer{K} Mer{RNAAlphabet{2},K}\nDNAKmer DNAMer{31}\nRNAKmer RNAMer{31}\nBigDNAMer{K} BigMer{DNAAlphabet{2},K}\nBigRNAMer{K} BigMer{RNAAlphabet{2},K}\nBigDNAKmer BigMer{DNAAlphabet{2},63}\nBigRNAKmer BigMer{RNAAlphabet{2},63}\nDNACodon DNAMer{3}\nRNACodon RNAMer{3}","category":"page"},{"location":"types/#Skipmers-1","page":"BioSequences Types","title":"Skipmers","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"For some analyses, the contiguous nature of kmers imposes limitations. A single base difference, due to real biological variation or a sequencing error, affects all k-mers crossing that position thus impeding direct analyses by identity. Also, given the strong interdependence of local sequence, contiguous sections capture less information about genome structure, and so they are more affected by sequence repetition. ","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Skipmers are a generalisation of the concept of a kmer. They are created using a cyclic pattern of used-and-skipped positions which achieves increased entropy and tolerance to nucleotide substitution differences by following some simple rules.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Skipmers preserve many of the elegant properties of kmers such as reverse complementability and existence of a canonical representation. Also, using cycles of three greatly increases the power of direct intersection between the genomes of different organisms by grouping together the more conserved  nucleotides of protein-coding regions.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences currently does not provide a separate type for skipmers, they are represented using Mer and BigMer as their representation as a short immutable sequence encoded in an unsigned integer is the same. The distinction lies in how they are generated.","category":"page"},{"location":"types/#Skipmer-generation-1","page":"BioSequences Types","title":"Skipmer generation","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"A skipmer is a simple cyclic q-gram that includes m out of every n bases until a total of k bases is reached. ","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"This is illustrated in the figure below (from this paper.):","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"(Image: skipmer-fig)","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"To maintain cyclic properties and the existence of the reverse-complement as a skipmer defined by the same function, k should be a multiple of m.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"This also enables the existence of a canonical representation for each skipmer, defined as the lexicographically smaller of the forward and reverse-complement  representations.","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Defining m, n and k fixes a value for S, the total span of the skipmer, given by: ","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"S = n * (frackm - 1) + m","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"To see how to iterate over skipmers cf. kmers, see the Iteration section of the manual.","category":"page"},{"location":"types/#Reference-sequences-1","page":"BioSequences Types","title":"Reference sequences","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"LongDNASeq (alias of BioSequence{DNAAlphabet{4}}) is a flexible data structure but always consumes 4 bits per base, which will waste a large part of the memory space when storing reference genome sequences.  In such a case, ReferenceSequence is helpful because it compresses positions of 'N' symbols so that long DNA sequences are stored with almost 2 bits per base. An important limitation is that the ReferenceSequence type is immutable due to the compression. Other sequence-like operations are supported:","category":"page"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"julia> seq = ReferenceSequence(dna\"NNCGTATTTTCN\")\n12nt Reference Sequence:\nNNCGTATTTTCN\n\njulia> seq[1]\nDNA_N\n\njulia> seq[5]\nDNA_T\n\njulia> seq[2:6]\n5nt Reference Sequence:\nNCGTA\n\njulia> ReferenceSequence(dna\"ATGM\")  # DNA_M is not accepted\nERROR: ArgumentError: invalid symbol M ∉ {A,C,G,T,N} at 4\n in convert at /Users/kenta/.julia/v0.4/Bio/src/seq/refseq.jl:58\n in call at essentials.jl:56\n","category":"page"},{"location":"types/#Alphabet-types-1","page":"BioSequences Types","title":"Alphabet types","text":"","category":"section"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"BioSequences.Alphabet","category":"page"},{"location":"types/#BioSequences.Alphabet","page":"BioSequences Types","title":"BioSequences.Alphabet","text":"Alphabet is perhaps the most important type trait for biological sequences in BioSequences.jl.\n\nAn Alphabet represents a domain of biological symbols.\n\nFor example, DNAAlphabet{2} has a domain of unambiguous nucleotides (i.e. A, C, G, and T).\n\nAlphabet types restrict and define the set of biological symbols, that can be encoded in a given biological sequence type. They ALSO define HOW that encoding is done.\n\nAn Alphabet type defines the encoding of biological symbols with a pair of associated encoder and decoder methods. These paired methods map between biological symbol values and a binary representation of the symbol.\n\nAny type A <: Alphabet, is expected to implement the Base.eltype method for itself. It is also expected to implement the BitsPerSymbol method.\n\n\n\n\n\n","category":"type"},{"location":"types/#","page":"BioSequences Types","title":"BioSequences Types","text":"Alphabets control how biological symbols are encoded and decoded. They also confer many of the automatic traits and methods that any subtype of T<:BioSequence{A<:Alphabet} will get.","category":"page"}]
}
